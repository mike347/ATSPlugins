<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Bits of this plugin and ideas were borrowed and remixed from the MUSHclient community. http://www.gammon.com.au/forum/?id=9385 and others. -->
<!-- Modifications for Aardwolf and extra awesome sauce added by Fiendish with help from Orogan -->
<!-- Adapated by Nick Gammon for Smaug and similar MUDs -->
<!-- Adapted for ATS, multiwindow support and major enhancements by Mike Taylor (Qon@ATS) -->

<muclient>
    <plugin
    name="QonChatGrabber_Master"
    author="Qon@ATS|Nick Gammon|Fiendish"
    id="de6b99ef3f79191fd27d59b0"
    language="Lua"
    purpose="Move channels to a miniwindow"
    date_written="2010-04-04"
    date_modified="2015-01-04"
    requires="4.84"
    version="2.23"
    save_state="y"
    >

<description trim="y">
USAGE:
  
  LH-click a line to copy it to the clipboard
  RH-click main window to see menu of options
  Click title bar to drag window.
  
  You should do 'update channels' before anything else
   
</description>
  
</plugin>

<triggers>

    <trigger
    enabled="y" regexp="y"
    match="^(.+) (\(\d+\)) (\(.+->\)).+ \[([\d.]+)\].+$"
    script="message_handler"
    omit_from_output="y"
    sequence="100"
	send_to="14"
	name="navcomp"
	group="ATSChatGrabber"
    ></trigger>
    
    <trigger
    enabled="y" regexp="y"
    match="^Border\sCrossing:\s.+ --> .+ to dest.$"
    script="message_handler"
    omit_from_output="y"
    sequence="100"
	send_to="14"
	name="navcomp_bc"
	group="ATSChatGrabber"
    ></trigger>
    
    <trigger
    enabled="y"
	regexp ="y"
    match="^(?:\[.+\] )?<(.*?)> .*$"
    script="message_handler"
    omit_from_output="y"
    sequence="100"
	send_to="12"
	name="channel"
	group="ATSChatGrabber"
    ></trigger>
    
	<trigger
    enabled="y"
	regexp ="y"
    match="^\[.*\]--\[S2S to (.*):.*\]$"
    script="message_handler"
    omit_from_output="y"
    sequence="100"
	send_to="14"
	name="s2s_out"
	group="ATSChatGrabber"
    ></trigger>
	
	<trigger
    enabled="y"
	regexp ="y"
    match="^(?:\[.+\] )?<.*?>\-\-<.*?>$"
    script="message_handler"
    omit_from_output="y"
    sequence="40"
	send_to="14"
	name="s2s_in"
	group="ATSChatGrabber"
    ></trigger>
	
    <trigger
    enabled="y" regexp="y"
    match="^(?:\[.+\] )?<OOC> (.*)$"
    script="message_handler"
    omit_from_output="y"
    sequence="50"
	send_to="14"
	name="ooc"
	group="ATSChatGrabber"
    ></trigger>
    
    <trigger
     enabled="y" keep_evaluating="y" regexp="y" omit_from_output="y" 
     match="^(.* pages .*: |Long distance to |You paged |From afar(,)? |.* pages: |\(To: .*\) ).*"
     script="message_handler"
     sequence="100"
	 send_to="14"
	 name="pages"
	 group="ATSChatGrabber"
     ></trigger>
	 
    <trigger
     enabled="y" keep_evaluating="y" regexp="y" omit_from_output="y" 
     match="^\[([\d\:]+)\]\sIdle\smessage\ssent\sto.*$"
     script="message_handler"
     sequence="100"
	 send_to="14"
	 name="idlemsg"
	 group="ATSChatGrabber"
     ></trigger>
	 
     
</triggers>

<aliases>
    <alias
    script="chat_echo"
    match="^chats echo( on| off)?$"
    enabled="y"
    regexp="y"
    sequence="100"
    ignore_case="y"
	group="ATSChatGrabber"

    ></alias>

    <alias
    script="chat_show"
    match="chats show"
    enabled="y"
    sequence="100"
    ignore_case="y"
	group="ATSChatGrabber"
    ></alias>

    <alias
    script="chat_hide"
    match="chats hide"
    enabled="y"
    sequence="100"
    ignore_case="y"
	group="ATSChatGrabber"
    ></alias>
        
</aliases>

<script>
<![CDATA[

require "movewindow"  -- load the movewindow.lua module
require "copytable"
require "pairsbykeys"
require "serialize"

-- Storage for anti-spam filter
status_table = { }
tractor_table = { }
channel_table = { }
search_table = { }
last_search = nil
URL_table = { }

SEARCH_INFO = [[ 
Search chat window. You can use LUA-type regexp, or globular searches. 
E.g. '* says' or 
'(Cantitia|Spro) pages: .+'.

See http://lua-users.org/wiki/PatternsTutorial for more examples of searching using Lua Regex-style expressions

]]

assert(loadstring(GetVariable("channel_table") or ""))()

config_table = { }

assert(loadstring(GetVariable("config_table") or "config_table = { pages = false, ooc = false, navcomp = false, s2s = false, spam = true, autoshorten = false, wrapwords = false }"))()
window_title = GetVariable("title") or nil
assert(loadstring(GetVariable("DATA") or ""))()
last_line = 0
if (not window_title ) then
	if (GetPluginID() == "de6b99ef3f79191fd27d59b0")  then
		window_title = "Master"
	else
		window_title = "Slave"
	end
end
BODY_FONT_NAME = GetVariable("bodyfont") or "Dina"
BODY_FONT_SIZE = tonumber(GetVariable("font_size") or 8)

SCROLL_BAR_WIDTH = 15
MAX_LINES = 7500 -- how many lines to store in scrollback

-- date_format = "[%d %b %H:%M:%S] "        -- [30 Aug 13:29:49]   date and time 24 hour
-- date_format = "[%d %b %I:%M:%S%p] "  -- [30 Aug 01:20:12PM]     date and time 12 hour
-- date_format = "[%H:%M:%S] "          -- [13:29:08]          time 24 hour
-- date_format = "[%X] "                  -- [1:22:06 PM]            time 12 hour

TIMESTAMP_TEXT_COLOUR = "white"
TIMESTAMP_BACK_COLOUR = "black"

-- doing it this way makes them default to true the first time around
timestamp = not (GetVariable("timestamp") == "false")
echo = GetVariable("echo") or false

date_format = GetVariable("date_format")
WINDOW_WIDTH = tonumber(GetVariable("WINDOW_WIDTH"))
WINDOW_HEIGHT = tonumber(GetVariable("WINDOW_HEIGHT"))

-- offset of text from edge
TEXT_INSET = 5

-- where to store the chat line
lines = {}  -- table of recent chat lines
rawlines = {}

lineStart = ""
lineEnd = ""
WINDOW_COLUMNS = ""
WINDOW_LINES = ""
assert(loadstring(GetVariable("DATA") or ""))()

theme = {
    WINDOW_BACKGROUND = ColourNameToRGB ("#000000"), -- for miniwindow body
    WINDOW_BORDER = ColourNameToRGB("#E8E8E8"), -- for miniwindow body
    
    HIGHLIGHT=ColourNameToRGB("#FFFFFF"), -- for 3D surfaces
    FACE=ColourNameToRGB("#D4D0C8"), -- for 3D surfaces
    INNERSHADOW=ColourNameToRGB("#808080"), -- for 3D surfaces
    OUTERSHADOW = ColourNameToRGB("#404040"), -- for 3D surfaces
   
    BACK_FACE = ColourNameToRGB ("#E8E8E8"), -- for contrasting details
    DETAIL = ColourNameToRGB ("#000000"), -- for contrasting details

    TITLE_HEIGHT = 17, -- for miniwindow title area
    SUBTITLE_HEIGHT = 17, -- for miniwindow title area
    TITLE_FONT_NAME = "Dina", -- for miniwindow title area
    TITLE_FONT_SIZE = 8 -- for miniwindow title area
}  -- end theme table


-- replacement for WindowRectOp action 5, which allows for a 3D look while maintaining color theme
-- Requires global theme.HIGHLIGHT, theme.FACE, theme.INNERSHADOW, and theme.OUTERSHADOW rgb colors to be set.
function DrawThemed3DRect(Window, left, top, right, bottom)
    WindowRectOp(Window, miniwin.rect_fill, left, top, right, bottom, theme.FACE)
    WindowLine(Window, left, top, right, top, theme.HIGHLIGHT, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
    WindowLine(Window, left, top, left, bottom, theme.HIGHLIGHT, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
    WindowLine(Window, left, bottom-2, right, bottom-2, theme.INNERSHADOW, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
    WindowLine(Window, right-2, top, right-2, bottom-2, theme.INNERSHADOW, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
    WindowLine(Window, left, bottom-1, right, bottom-1, theme.OUTERSHADOW, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
    WindowLine(Window, right-1, top, right-1, bottom-1, theme.OUTERSHADOW, 
                miniwin.pen_solid + miniwin.pen_endcap_flat, 1)    
end

function DrawThemedResizeTag(Window, x1, y1, size)
    local x2, y2 = x1+size, y1+size
    DrawThemed3DRect(Window, x1, y1, x2, y2)
    local m = 2
    local n = 2
    while (x1+m+2 <= x2-3 and y1+n+1 <= y2-4) do
        WindowLine(Window, x1+m+1, y2-4, x2-3, y1+n, theme.HIGHLIGHT, 
                    miniwin.pen_solid, 1)
        WindowLine(Window, x1+m+2, y2-4, x2-3, y1+n+1, theme.INNERSHADOW, 
                    miniwin.pen_solid, 1)
        m = m+3
        n = n+3
    end
end  -- function DrawThemedResizeTag


Win = GetPluginID()
font_height = ""
line_height = ""
windowinfo = ""
startx = ""
starty = ""

function ResizeMoveCallback()

    posx, posy = WindowInfo (Win, 17), WindowInfo (Win, 18)
    if (WindowTextWidth(Win, "titlefont"..Win, window_title)+2*SCROLL_BAR_WIDTH <= WINDOW_WIDTH+posx-startx) then
        WINDOW_WIDTH = WINDOW_WIDTH+posx-startx
        startx = posx
    end  -- if
    if (3*SCROLL_BAR_WIDTH+10+line_height+theme.TITLE_HEIGHT <= WINDOW_HEIGHT+posy-starty) then
        WINDOW_HEIGHT = WINDOW_HEIGHT+posy-starty
        starty = posy
    end -- if
    init(false)
end -- function ResizeMoveCallback

function ResizeReleaseCallback()
    WINDOW_HEIGHT = theme.TITLE_HEIGHT+(line_height*(WINDOW_LINES-1))+3
    init(true)
end  -- ResizeReleaseCallback

function OnPluginInstall()
	local myID = GetPluginID()
	-- If we are a slave, disable the triggers and aliases
	if (GetPluginID() ~= "de6b99ef3f79191fd27d59b0") then	
		EnableTriggerGroup("ATSChatGrabber", false)
		EnableAliasGroup("ATSChatGrabber", false)
	end
	    -- Dummy window to get font characteristics
    check (WindowCreate (Win, 0, 0, 1, 1, 0, 0, theme.WINDOW_BACKGROUND) )
    check (WindowFont(Win, "bodyfont"..Win, BODY_FONT_NAME, BODY_FONT_SIZE))
    check (WindowFont(Win, "titlefont"..Win, theme.TITLE_FONT_NAME, theme.TITLE_FONT_SIZE))
    check (WindowFont(Win, "bodyfontul"..Win, BODY_FONT_NAME, BODY_FONT_SIZE,false, false, true))
    
    font_height = WindowFontInfo (Win, "bodyfont"..Win, 1) -  WindowFontInfo (Win, "bodyfont"..Win, 4) + 1
    line_height = font_height+1
    font_width = WindowTextWidth (Win, "bodyfont"..Win, "W")
    
    -- install the window movement handler, get back the window position
    windowinfo = movewindow.install (Win, miniwin.pos_top_right, miniwin.create_absolute_location, true)

    -- check for Echo/Timestamp/date_format/window size (in pixels) variables, if not there, set them
    if date_format == nil then
        date_format = "[%d %b %H:%M:%S] "
    end -- if
    if WINDOW_WIDTH == nil then
        WINDOW_WIDTH = (font_width*80)+SCROLL_BAR_WIDTH -- 80 columns
    end
    if WINDOW_HEIGHT == nil then
        WINDOW_HEIGHT = theme.TITLE_HEIGHT+(line_height*6)+2 -- 6 lines
    end -- if
    init(true)
    OnPluginEnable ()  -- do initialization stuff
end -- function OnPluginInstall

function init(firstTime)
    -- how many lines and columns will fit?
    WINDOW_LINES = math.ceil((WINDOW_HEIGHT-theme.TITLE_HEIGHT)/line_height)
    WINDOW_COLUMNS = math.ceil((WINDOW_WIDTH-SCROLL_BAR_WIDTH)/font_width)
    local reallyFirstTime = false
      if firstTime then
        WindowCreate(Win, windowinfo.window_left, windowinfo.window_top, WINDOW_WIDTH, WINDOW_HEIGHT, windowinfo.window_mode, windowinfo.window_flags, theme.WINDOW_BACKGROUND)

        -- catch for right-click menu and line selection
        WindowAddHotspot(Win, "textarea", 0, theme.TITLE_HEIGHT, WINDOW_WIDTH-SCROLL_BAR_WIDTH,0, 
            "", "", "MouseDown", "CancelMouseDown", "MouseUp", "", 
            miniwin.cursor_ibeam, 0)
		-- Scrollwheel hook
		WindowScrollwheelHandler(Win, "textarea", "wheel_move")
        -- add the drag handler so they can move the window around
        movewindow.add_drag_handler (Win, 0, 0, 0, theme.TITLE_HEIGHT)
        
        -- scroll bar up/down buttons
        WindowAddHotspot(Win, "up", WINDOW_WIDTH-SCROLL_BAR_WIDTH, theme.TITLE_HEIGHT, 0, theme.TITLE_HEIGHT+SCROLL_BAR_WIDTH, 
            "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 
            miniwin.cursor_hand, 0)
        WindowAddHotspot(Win, "down", WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-(2*SCROLL_BAR_WIDTH), 0, WINDOW_HEIGHT-SCROLL_BAR_WIDTH, 
            "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 
            miniwin.cursor_hand, 0)

        -- add the resize widget hotspot
        WindowAddHotspot(Win, "resizer", WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-SCROLL_BAR_WIDTH, WINDOW_WIDTH, WINDOW_HEIGHT, 
            "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 
            miniwin.cursor_nw_se_arrow, 0)
        WindowDragHandler(Win, "resizer", "ResizeMoveCallback", "ResizeReleaseCallback", 0)    
    else
        WindowResize(Win, WINDOW_WIDTH, WINDOW_HEIGHT, theme.WINDOW_BACKGROUND)
        WindowMoveHotspot(Win, "textarea", 0, theme.TITLE_HEIGHT, WINDOW_WIDTH-SCROLL_BAR_WIDTH, 0)
        WindowMoveHotspot(Win, "up", WINDOW_WIDTH-SCROLL_BAR_WIDTH, theme.TITLE_HEIGHT, 0, theme.TITLE_HEIGHT+SCROLL_BAR_WIDTH)
        WindowMoveHotspot(Win, "down", WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-(2*SCROLL_BAR_WIDTH), 0, WINDOW_HEIGHT-SCROLL_BAR_WIDTH)
        WindowMoveHotspot(Win, "resizer", WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-SCROLL_BAR_WIDTH, WINDOW_WIDTH, 0)
    end -- if
    WindowShow(Win, true)
	lineStart = 1
    lineEnd = #rawlines or 1
    if (firstTime == true) then

		local startTime = GetInfo (232)
        lines = {}
        for _,styles in ipairs(rawlines) do 
            fillBuffer(styles)
        end  -- for each line

		local endTime = GetInfo (232)
		ColourNote("orange", "", string.format("%s v%s (%s) loaded. (%fs)",GetPluginInfo(GetPluginID(),1), GetPluginInfo(GetPluginID(),19), 
				window_title, endTime - startTime))
    end -- if

    lineStart = math.max(1, #lines-WINDOW_LINES+2)
    lineEnd = math.max(1, #lines)
    refresh()
end  -- function init

function OnPluginClose ()
    -- if enabled
    if GetPluginInfo (GetPluginID(), 17) then
        OnPluginDisable()
    end -- if enabled
end -- function OnPluginClose

function OnPluginEnable ()
    WindowShow (Win, true)
end -- function OnPluginEnable

function OnPluginSaveState ()
    -- save window current location for next time  
    SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID(), 17)))
    movewindow.save_state (Win)
    -- save echo/timestamp status
	if (echo) then
		SetVariable ("echo", 1) 
	else
		DeleteVariable("echo")
	end
    SetVariable ("timestamp", tostring (timestamp))
    SetVariable("date_format", date_format)
    SetVariable("WINDOW_WIDTH", WINDOW_WIDTH)
    SetVariable("WINDOW_HEIGHT", WINDOW_HEIGHT)
	SetVariable("channel_table", serialize.save("channel_table"))
	SetVariable("title", window_title)
	
	local rawStart, rawEnd = 1, #rawlines
	local r = { }
	if(rawEnd > 500) then
		rawStart = #rawlines - 500
	end
	local ii = 1
	for i = rawStart, rawEnd do
		r[ii] = rawlines[i]
		ii = ii + 1
	end
	
	SetVariable("DATA", serialize.save("rawlines", r))
end -- function OnPluginSaveState

function OnPluginDisable ()
    WindowShow( Win, false )
end -- function OnPluginDisable

-- display one line
function Display_Line (line, styles)
 
  local left    = TEXT_INSET
  local top     = theme.TITLE_HEIGHT + (line * line_height) + 1
  local bottom  = top + line_height
  local font    = "bodyfont" .. Win
  local fontul  = "bodyfontul" .. Win

-- Delete any current hotspots.
  WindowDeleteHotspot(Win, "line_1_" .. tostring(line))
  WindowDeleteHotspot(Win, "line_2_" .. tostring(line))
  --WindowDeleteHotspot(Win, "line_" .. tostring(line)) -- Probably don't need this, since we ALWAYS reuse this?
  WindowDeleteHotspot(Win, "hyperlink_" .. tostring(line))
  
  
  if backfill then
      WindowRectOp (Win, miniwin.rect_fill, 1, top, WINDOW_WIDTH - SCROLL_BAR_WIDTH, bottom, ColourNameToRGB("#333333"))
  end -- backfill
  
  if (styles) then
    for _, style in ipairs (styles) do
		if (config_table.tooltip and timestamp and style.timestamp) then
		else
        local width = WindowTextWidth (Win, font, style.text) -- get width of text
        local right = left + width
        local urls = findURLs(style.text)
       
        if (style.hilite or styles.hilite) then
            WindowRectOp (Win, miniwin.rect_fill, left, top, right, bottom, ColourNameToRGB("yellow"))  -- draw background
            WindowText (Win, font, style.text, left, top, 0, 0, ColourNameToRGB("black"))  -- draw text
        else
            WindowRectOp (Win, miniwin.rect_fill, left, top, right, bottom, style.backcolour)  -- draw background
            if(urls) then
                local sStart = style.text:sub(1, urls.start-1)
                local sEnd = style.text:sub(urls.stop+1, #style.text)
                
                local ws = WindowTextWidth(Win, font, sStart) -- Width of text BEFORE the hyperlink
                local we = WindowTextWidth(Win, font, sEnd) -- Width of text AFTER hyperlink
                local wh = WindowTextWidth(Win, fontul, urls.text) -- Width of the hyperlink itself
                WindowText (Win, font, sStart, left, top, 0, 0, style.textcolour)  -- draw text
                WindowText (Win, fontul, urls.text, (left + ws + 1), top, 0, 0, ColourNameToRGB("blue"))  -- draw text
                WindowText (Win, font, sEnd, (left + ws + wh + 1), top, 0, 0, style.textcolour)  -- draw text
            else    
                WindowText (Win, font, style.text, left, top, 0, 0, style.textcolour)  -- draw text
            end -- if url
        end -- if hilite
                   
        left = left + width  -- advance horizontally
		end -- first
    end -- for each style run        
  end -- if  styles
  local text = GetLineText(styles,true)
  local urls = findURLs(text)
  if (urls and urls.start) then -- Special case for making clickable hyperlinks
    local sStart = text:sub(1, urls.start-1)
    local sEnd = text:sub(urls.start, urls.stop)
    
    local ws = WindowTextWidth(Win, font, sStart) -- Width of text BEFORE the hyperlink
    local we = WindowTextWidth(Win, font, sEnd) -- Width of text AFTER hyperlink
    local wh = WindowTextWidth(Win, font, urls.text) -- Width of the hyperlink itself
    --Note(string.format("%s: WS:%d, WE:%d, WH: %d,%s/%s", urls.text, ws, we, wh, sStart, sEnd))
    
    if (timestamp and styles[1].text and config_table.tooltip) then -- Ugh, tooltip AND hyperlink
        WindowAddHotspot(Win, "line_1_" .. tostring(line), TEXT_INSET, top, TEXT_INSET + ws, bottom, 
            "", "", "MouseDown", "CancelMouseDown", "MouseUp", styles[1].text .. "Start", 
            miniwin.cursor_ibeam, 0)
        WindowScrollwheelHandler(Win, "line_1_" .. tostring(line), "wheel_move")
    end
    WindowAddHotspot(Win, "hyperlink_" .. tostring(line), TEXT_INSET + ws + 1, top, (TEXT_INSET + ws + 1 + wh), bottom, "", "", "MouseDown", "", "", styles[1].text .. " Click to open",
        0, 0)
    WindowScrollwheelHandler(Win, "hyperlink_" .. tostring(line), "wheel_move")
    URL_table["hyperlink_" .. tostring(line)] = urls.text -- Insert into our table for later use

    if ((ws +1 + we) < left and timestamp and styles[1].text and config_table.tooltip) then -- If there is text left, add another hotspot to cover it.
        WindowAddHotspot(Win, "line_2_" .. tostring(line), we + 1, top, left, bottom, 
            "", "", "MouseDown", "CancelMouseDown", "MouseUp", styles[1].text .. "End", 
            miniwin.cursor_ibeam, 0)
        WindowScrollwheelHandler(Win, "line_2_" .. tostring(line), "wheel_move")
    end
  else
    if (timestamp and styles[1].text and config_table.tooltip) then
	  WindowAddHotspot(Win, "line_" .. tostring(line), TEXT_INSET, top, left, bottom, 
            "", "", "MouseDown", "CancelMouseDown", "MouseUp", styles[1].text, 
            miniwin.cursor_ibeam, 0)
      WindowScrollwheelHandler(Win, "line_" .. tostring(line), "wheel_move")
	end
  end
end -- Display_Line


-- display all visible lines
function writeLines()
    for count = lineStart, lineEnd do
        if (lines[count] and lines[count][1] ) then
		  Display_Line( count-lineStart, lines[count][1], false )
		end
    end  -- for each line	
    Redraw()

end  -- function writeLines

-- clear and redraw
function refresh()
    WindowRectOp(Win, miniwin.rect_fill, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, theme.WINDOW_BACKGROUND)
    drawStuff()
end  -- function refresh

barPos = ""
barSize = ""
totalSteps = ""

function drawStuff()
	
    -- draw border
    WindowRectOp (Win, miniwin.rect_frame, 0, 0, 0, 0, theme.WINDOW_BORDER)
    
    -- Title bar
    DrawThemed3DRect(Win, 0, 0, WINDOW_WIDTH, theme.TITLE_HEIGHT)

    -- Title text
    WindowText(Win, "titlefont"..Win, window_title, ((WINDOW_WIDTH)-(7.5*line_height))/2, (theme.TITLE_HEIGHT-line_height)/2, WINDOW_WIDTH, theme.TITLE_HEIGHT, theme.DETAIL, false)

    if #lines >= 1 then
        writeLines()
    end -- if
        
    -- Scrollbar base
    WindowRectOp(Win, miniwin.rect_fill, WINDOW_WIDTH-SCROLL_BAR_WIDTH, theme.TITLE_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, theme.BACK_FACE) -- scroll bar background
    WindowRectOp(Win, miniwin.rect_frame, WINDOW_WIDTH-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+theme.TITLE_HEIGHT+1, WINDOW_WIDTH-1, WINDOW_HEIGHT-(2*SCROLL_BAR_WIDTH)-1, theme.DETAIL) -- scroll bar background inset rectangle
    DrawThemed3DRect(Win, WINDOW_WIDTH-SCROLL_BAR_WIDTH, theme.TITLE_HEIGHT, WINDOW_WIDTH, theme.TITLE_HEIGHT+SCROLL_BAR_WIDTH) -- top scroll button
    DrawThemed3DRect(Win, WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-(SCROLL_BAR_WIDTH*2), WINDOW_WIDTH, WINDOW_HEIGHT-SCROLL_BAR_WIDTH) -- bottom scroll button
    
    -- draw triangle in up button
    points = string.format ("%i,%i,%i,%i,%i,%i", (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+2, theme.TITLE_HEIGHT+8,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+6, theme.TITLE_HEIGHT+4,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+10, theme.TITLE_HEIGHT+8)
    WindowPolygon (Win, points,
        theme.DETAIL, miniwin.pen_solid, 1,   -- pen (solid, width 1)
        theme.DETAIL, miniwin.brush_solid, --brush (solid)
        true, --close
        false)  --alt fill

    -- draw triangle in down button    
    points = string.format ("%i,%i,%i,%i,%i,%i", (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+2, (WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-10,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+6, (WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-6, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+10,(WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-10)
    WindowPolygon (Win, points,
        theme.DETAIL, miniwin.pen_solid, 1,   -- pen (solid, width 1)
        theme.DETAIL, miniwin.brush_solid, --brush (solid)
        true, --close
        false) --alt fill
    
    -- The scrollbar position indicator
    totalSteps = #lines
    if (totalSteps <= WINDOW_LINES-1) then totalSteps = 1 end
    SCROLL_BAR_HEIGHT = (WINDOW_HEIGHT-(3*SCROLL_BAR_WIDTH)-theme.TITLE_HEIGHT)
    if (not dragscrolling) then
        stepNum = lineStart-1
        barPos = SCROLL_BAR_WIDTH +theme.TITLE_HEIGHT+ ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
        barSize = (SCROLL_BAR_HEIGHT/math.max(WINDOW_LINES-1,totalSteps)) * (WINDOW_LINES-1)
        if barSize < 10 then
            barSize = 10
        end
        if barPos+barSize > SCROLL_BAR_WIDTH+theme.TITLE_HEIGHT+SCROLL_BAR_HEIGHT then
            barPos = SCROLL_BAR_WIDTH+theme.TITLE_HEIGHT+SCROLL_BAR_HEIGHT - barSize
        end
        WindowAddHotspot(Win, "scroller", (WINDOW_WIDTH-SCROLL_BAR_WIDTH), barPos, WINDOW_WIDTH, barPos+barSize, 
                        "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 
                        miniwin.cursor_hand, 0)
        WindowDragHandler(Win, "scroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
    end  -- if
    DrawThemed3DRect(Win, WINDOW_WIDTH-SCROLL_BAR_WIDTH, barPos, WINDOW_WIDTH, barPos+barSize)
    
    -- resizer tag
    DrawThemedResizeTag(Win, WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH)
    
    Redraw()
end  -- function drawStuff

function ScrollerMoveCallback(flags, hotspot_id)
    mouseposy = WindowInfo(Win, 18)
    windowtop = WindowInfo(Win, 2)
    barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+theme.TITLE_HEIGHT)
	
    if barPos > WINDOW_HEIGHT-(SCROLL_BAR_WIDTH*2)-barSize then
        barPos = WINDOW_HEIGHT-(SCROLL_BAR_WIDTH*2)-barSize
        lineStart = math.max(1,#lines-WINDOW_LINES+2)
        lineEnd = #lines
    else
        lineStart = math.floor((barPos-SCROLL_BAR_WIDTH-theme.TITLE_HEIGHT)/(SCROLL_BAR_HEIGHT/totalSteps)+1)
        lineEnd = math.min(lineStart + WINDOW_LINES-2, #lines)
    end -- if
    refresh()
end  -- function ScrollerMoveCallback

function ScrollerReleaseCallback(flags, hotspot_id)
    dragscrolling = false
    refresh()
end  -- function ScrollerReleaseCallback

function fillBuffer(rawstyles, location)

	local loc = location or nil
    local avail = 0
    local line_styles
    local beginning = true
    local ts = nil
    -- keep pulling out styles and trying to fit them on the current line

    local styles = copytable.deep (rawstyles)
    local remove = table.remove
    local insert = table.insert
    local text = GetLineText(rawstyles)
    local urls = findURLs(text)
    
    while #styles > 0 do
        if avail <= 0 then -- no room available? start new line
            -- remove first line if filled up
            if (#lines >= MAX_LINES and not loc) then
                remove (lines, 1)
            end -- if 
            avail = WINDOW_WIDTH - (TEXT_INSET * 2) - 9
            line_styles = {}
          
			if (loc) then
			    add_line( line_styles, beginning, loc )
				loc = loc + 1
			else
				add_line( line_styles, beginning )
			end
            beginning = false
        end -- line full
       -- get next style, work out how long it is
        local style = remove (styles, 1)
        local width = WindowTextWidth (Win, "bodyfont"..Win, style.text)
        if (style.timestamp and config_table.tooltip) then
            width = 0
            ts = style -- Save the timestamp for adding back into split lines. fuck.
           end
        -- if it fits, copy whole style in
        if width <= avail then
            line_styles[#line_styles+1] = style
            avail = avail - width
        else -- otherwise, have to split style   
            -- look for trailing space (work backwards). remember where space is
            local col = style.length - 1
            local split_col
            -- keep going until out of columns
            while col > 1 do
                width = WindowTextWidth (Win, "bodyfont"..Win, style.text:sub (1, col)) 
                if width <= avail then
                    if ((not split_col and not config_table.wrapwords)) then
                        split_col = col  -- in case no space found, this is where we can split
                    end -- if
                    -- see if space here
                    if style.text:sub (col, col) == " " then
                        split_col = col
                        break
                    end -- if space
                end -- if will now fit
                col = col - 1
            end -- while

            -- if we found a place to split, use old style, and make it shorter. Also make a copy and put the rest in that
            if split_col then
                line_styles[#line_styles+1] = style
                local style_copy = copytable.shallow (style)
                style.text = style.text:sub (1, split_col)
                style.length = split_col 
                style_copy.text = style_copy.text:sub (split_col + 1)
                style_copy.length = #style_copy.text
                insert (styles, 1, style_copy)
                if (ts and config_table.tooltip) then
                    insert(styles, 1, ts)
                end
            elseif next (line_styles) == nil then
                line_styles[#line_styles + 1] = style
            else
                insert (styles, 1, style)
            end -- if    
            avail = 0  -- now we need to wrap     
        end -- if could not fit whole thing in
    end -- while we still have styles over
    
end  -- function fillBuffer


-- Main capture routine
function chats (name, styles)
    
    -- echo in this world as well if the user wants
    if echo then
        for _, v in ipairs (styles) do
            ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),v.text)
        end -- for each style run
        Note ("")  -- wrap up line
    end -- echo wanted

    -- inject timestamp if wanted
    if timestamp then
        local tstamp = os.date (date_format)
        table.insert (styles, 1, {
          text = tstamp,
          textcolour  = ColourNameToRGB (TIMESTAMP_TEXT_COLOUR),
          backcolour = ColourNameToRGB (TIMESTAMP_BACK_COLOUR),
          length = string.len (tstamp),
          style = 0,
          timestamp = true,
        } )
    end -- if
    
    -- store the raw lines for use during resizing
    if #rawlines >= MAX_LINES then
        table.remove(rawlines, 1)
    end
    rawlines[#rawlines+1] = styles
    
    fillBuffer(styles)
    refresh( )
end -- function chats 

function add_line ( line, is_beginning_of_message, location )
    

	if (location) then

		table.insert(lines, location, {line, false})
		lines[location][2] = is_beginning_of_message
	else

		lines[#lines+1] = {line, false}

		lines[#lines][2] = is_beginning_of_message

	end

	
    -- advance the count
    if #lines >= WINDOW_LINES then
        lineStart = lineStart + 1
    end -- if
        
    if #lines > 1 then
        lineEnd = lineEnd + 1
    end -- if
end -- function add_line

keepscrolling = false
require "wait"

function scrollbar(calledBy)
    wait.make (function()
        while keepscrolling == true do
            if calledBy == "up" then
                if (lineStart > 1) then
                    lineStart = lineStart - 1
                    lineEnd = lineEnd - 1
                    WindowRectOp(Win, miniwin.rect_draw_edge, (WINDOW_WIDTH-SCROLL_BAR_WIDTH), theme.TITLE_HEIGHT, 0, theme.TITLE_HEIGHT+SCROLL_BAR_WIDTH, 
                        miniwin.rect_edge_sunken,  miniwin.rect_edge_at_all + miniwin.rect_option_fill_middle) -- up arrow pushed
                    points = string.format ("%i,%i,%i,%i,%i,%i", (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+3, theme.TITLE_HEIGHT+9,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, theme.TITLE_HEIGHT+5,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+11, theme.TITLE_HEIGHT+9)
                    WindowPolygon (Win, points,
                        theme.DETAIL, miniwin.pen_solid, 1, -- pen (solid, width 1)
                        theme.DETAIL, miniwin.brush_solid, -- brush (solid)
                        true, -- close
                        false) -- alt fill
                else
                    keepscrolling = false
                end
            elseif calledBy == "down" then
                if (lineEnd < #lines) then
                    lineStart = lineStart + 1
                    lineEnd = lineEnd + 1
                WindowRectOp(Win, miniwin.rect_draw_edge, (WINDOW_WIDTH-SCROLL_BAR_WIDTH), WINDOW_HEIGHT-(SCROLL_BAR_WIDTH*2), 0, WINDOW_HEIGHT-SCROLL_BAR_WIDTH-1, 
                    miniwin.rect_edge_sunken,  miniwin.rect_edge_at_all + miniwin.rect_option_fill_middle) -- down arrow pushed
                points = string.format ("%i,%i,%i,%i,%i,%i", (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+3, (WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-11,(WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, (WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-7, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+11,(WINDOW_HEIGHT-SCROLL_BAR_WIDTH)-11) -- draw triangle in up button
                WindowPolygon (Win, points,
                    theme.DETAIL, miniwin.pen_solid, 1, -- pen (solid, width 1)
                    theme.DETAIL, miniwin.brush_solid, -- brush (solid)
                    true, -- close
                    false) -- alt fill
                else
                    keepscrolling = false
                end
            end -- if
            wait.time(0.1)
            refresh()
        end -- while keepscrolling
    end)  -- wait.make
end  -- function scrollbar

function GetLineText (styles, tsonly)
  local t = {}
  for _, style in ipairs (styles) do
    if ((tsonly and not style.timestamp) or not tsonly) then
        table.insert (t, style.text)
    end
  end -- for
  return table.concat (t)
end -- function GetLineText

function GetAllBufferedMessages()
    local t = {}
    for _,styles in ipairs(rawlines) do
      table.insert (t, GetLineText (styles))
    end -- for
    SetClipboard(table.concat(t,"\r\n"))
end -- function GetAllBufferedMessages

function GetBufferedMessage(xpos, ypos)
    windowline = math.floor(((ypos-theme.TITLE_HEIGHT)/line_height)+1)-1
    text = ""
    
    if (#lines > windowline) then
        local line = windowline+lineStart
        -- go to beginning of message
		if (not lines[line]) then return		end
        
        while lines[line][2] ~= true and line > 1 do
            line = line - 1
        end -- while
        -- first line
        local styles = copytable.deep(lines[line][1])
        if (line-lineStart+1 > 0) then
            Display_Line (line-lineStart, styles, true)
        end -- if
        text = GetLineText (styles)
        -- remaining lines
        line = line + 1
        while line <= #lines and lines[line][2] ~= true do
            local styles = copytable.deep(lines[line][1])
            if (line-lineStart+1 > 0 and line-lineStart < WINDOW_LINES) then
                Display_Line (line-lineStart, styles, true)
            end
            text = text.. GetLineText (styles,true)
            line = line + 1
        end -- while
        SetClipboard(text)
    end -- if
    Redraw()
    
end  -- function GetBufferedMessage

function MouseOver(flags, hotspot_id)
    keepscrolling = false
end  -- function MouseOver

function CancelMouseOver(flags, hotspot_id)
    keepscrolling = false
end  -- function CancelMouseOver

function MouseDown(flags, hotspot_id)
    if (hotspot_id == "resizer") then
        startx, starty = WindowInfo (Win, 17), WindowInfo (Win, 18)
    elseif (hotspot_id == "scroller") then
        clickdelta = WindowHotspotInfo(Win, "scroller", 2)-WindowInfo (Win, 15)
        dragscrolling = true
    elseif (hotspot_id == "textarea" and flags == miniwin.hotspot_got_lh_mouse) then
        GetBufferedMessage(WindowInfo(Win, 14), WindowInfo(Win,15))
    elseif (hotspot_id:match("line_*") and flags == miniwin.hotspot_got_lh_mouse) then
        local ln = hotspot_id:match("line_(%d+)")
        GetBufferedMessage(WindowInfo(Win, 14), WindowInfo(Win,15))
    elseif (hotspot_id:match("hyperlink_*") and flags == miniwin.hotspot_got_lh_mouse) then
        if (URL_table[hotspot_id]) then
            OpenBrowser(URL_table[hotspot_id])
        end
    else
        keepscrolling = true
        scrollbar(hotspot_id)
    end -- if
end  -- function MouseDown

function CancelMouseDown(flags, hotspot_id)
    keepscrolling = false
    refresh()
end  -- function CancelMouseDown

function MouseUp(flags, hotspot_id)
    if (hotspot_id == "textarea" and flags == miniwin.hotspot_got_rh_mouse) then
        -- build menu for current state
        right_click_menu()
    elseif (hotspot_id:match("line_*") and flags == miniwin.hotspot_got_rh_mouse) then
        right_click_menu()
    else
        refresh()
    end -- if
    keepscrolling = false
end  -- function MouseUp

function chat_echo (name, line, wildcards)
    if wildcards [1] == false then
      echo = not echo  -- toggle
    else
      echo = wildcards [1]:lower () == " on"
    end -- if

    if echo then
        ColourNote ("yellow", "", "Echoing chats in main window ENABLED.")
    else
        ColourNote ("yellow", "", "Echoing chats in main window DISABLED.")
    end -- if
end -- function chat_echo

function chat_show (name, line, wildcards)
   WindowShow( Win, true )
   ColourNote ("yellow", "", "Chats window now shown. Type 'chats hide' to hide it.")
end -- function chat_show

function chat_hide (name, line, wildcards)
   WindowShow( Win, false )
   ColourNote ("yellow", "", "Chats window now hidden. Type 'chats show' to see it again.")
end -- function chat_hide

-- right click menu
function right_click_menu ()
	menustring = string.format("^ChatGrabber v%s|-|", tostring(GetPluginInfo(GetPluginID(), 19)))
    menustring = menustring .. "Search|Copy All To Clipboard|Change Font|Rename Window"
    menustring = menustring .. string.format("|%sEcho", echo and "+" or "")
    menustring = menustring.. string.format("|>Timestamp|No Timestamps|30 Aug 13:29:49|30 Aug 01:20:12PM|13:29:08|1:22:06 PM|23:04|%sTooltip Timestamp",config_table.tooltip and "+" or "")
	menustring = menustring .. string.format("|<|Channels|>Other Communications|%sPages|%sSubspace|%sS2S|%sNavcomp|%sLocal OOC|<|Update Channel list",
		config_table.pages and "+" or "", config_table.subspace and "+" or "", config_table.s2s and "+" or "", config_table.navcomp and "+" or "", config_table.ooc and "+" or ""  )
    menustring = menustring .. string.format("|>Other options|%sWrap Words only|%sSubspace Spam Filtering|%sAuto-shorten URLS|Clear Buffer|<", config_table.wrapwords and "+" or "", 
        config_table.spam and "+" or "", config_table.autoshorten and "+" or "")
    result = WindowMenu (Win, 
        WindowInfo (Win, 14),  -- x position
        WindowInfo (Win, 15),   -- y position
        menustring) -- content
    if result == "Copy All To Clipboard" then
        GetAllBufferedMessages()
        ColourNote ("yellow", "", "All buffered messages copied to clipboard.")
    elseif result == "Change Font" then
        wanted_font = utils.fontpicker (BODY_FONT_NAME, BODY_FONT_SIZE) --font dialog
        if wanted_font then
            BODY_FONT_NAME = wanted_font.name
            BODY_FONT_SIZE = wanted_font.size
            SetVariable ("bodyfont", BODY_FONT_NAME)
            SetVariable ("font_size", BODY_FONT_SIZE)
            OnPluginInstall()
        end
	elseif result == "Rename Window" then
		local tmp = utils.inputbox ("New channel name? (Must be 16 characters or less)", "ATS ChatGrabber 2.0", window_title, "Courier", 9, {max_length = 16 }) 
		if (tmp and tmp ~= window_title) then
			ColourNote("yellow", "", window_title .. " has been renamed to " .. tmp)
			window_title = tmp
			SetVariable("title", window_title)
			OnPluginInstall()
		end
    elseif result == "Search" then
        local tmp = utils.inputbox(SEARCH_INFO, "QonChatGrabber", last_search or "Search terms?", "Courier", 9, {max_length = 16, min_length = 3})
        if (tmp) then
            last_search = tmp
            ColourNote("white", "", string.format("Searching for '%s' in %s window.", tmp, window_title))
            search(tmp)
         end
    elseif result == "Echo" then
        if (echo) then
			echo = false
			ColourNote ("yellow", "", "Echoing chats in " .. window_title .. " window DISABLED.")
		else
			echo = true
			ColourNote ("yellow", "", "Echoing chats in " .. window_title .. " window ENABLED.")
		end
    elseif result == "No Timestamps" then
        timestamp = false
        ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window DISABLED.")
    elseif result == "30 Aug 13:29:49" then
        timestamp = true
        date_format = "[%d %b %H:%M:%S] "
        ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window ENABLED using format like '30 Aug 13:29:49'.")
    elseif result == "30 Aug 01:20:12PM" then
        timestamp = true
        date_format = "[%d %b %I:%M:%S%p] "
        ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window ENABLED using format like '30 Aug 01:20:12PM'.")
    elseif result == "13:29:08" then
        timestamp = true
        date_format = "[%H:%M:%S] "
        ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window ENABLED using format like '13:29:08'.")
	elseif result == "23:04" then
		timestamp = true
		date_format = "[%H:%M] "
		ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window ENABLED using format like '23:04'.")
    elseif result == "1:22:06 PM" then
        timestamp = true
        date_format = "[%I:%M:%S%p] "
        ColourNote ("yellow", "", "Timestamps in " .. window_title .. " window ENABLED using format like '1:22:06 PM'.")
	elseif result == "Tooltip Timestamp" then
		if(not timestamp) then
			ColourNote("red", "", "You must first turn on timestamps to use tooltips.")
		else
			if (config_table.tooltip) then
				ColourNote("yellow", "", "Tooltip display mode disabled for " .. window_title .. " window. RELOADING...")
				config_table.tooltip = false
			else	
				ColourNote("yellow", "", "Tooltip display mode enabled for " .. window_title .. " window. RELOADING...")
				config_table.tooltip = true
			end
            lines = {}
            for _,styles in ipairs(rawlines) do 
                fillBuffer(styles)
            end  -- for each line
            lineStart = math.max(1, #lines-WINDOW_LINES+2)
            lineEnd = math.max(1, #lines)
            refresh()
			SetVariable("config_table", serialize.save("config_table", config_table))
		end
	elseif result == "Pages" then
		if (config_table.pages) then
			ColourNote("yellow", "", "Pages disabled for " .. window_title .. " window")
			config_table.pages = false
		else	
			ColourNote("yellow", "", "Pages enabled for " .. window_title .. " window" )
			config_table.pages = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
		BroadcastPlugin(config_table.pages and 1 or 0, "pages")
	elseif result == "Local OOC" then
		if (config_table.ooc) then
			ColourNote("yellow", "", "Local OOC disabled for " .. window_title .. " window ")
			config_table.ooc = false
		else
			ColourNote("yellow", "", "Local OOC enabled for " .. window_title .. " window " )
			config_table.ooc = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
		BroadcastPlugin(config_table.ooc and 1 or 0, "ooc")
	elseif result == "Navcomp" then
		if (config_table.navcomp) then
			ColourNote("yellow", "", "Navcomp disabled for " .. window_title .. " window ")
			config_table.navcomp = false
		else	
			ColourNote("yellow", "", "Navcomp enabled for " .. window_title .. " window ")
			config_table.navcomp = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
		BroadcastPlugin(config_table.navcomp and 1 or 0, "navcomp")
	elseif result == "Subspace" then
		if (config_table.subspace) then
			ColourNote("yellow", "", "Subspace disabled for " .. window_title .. " window " )
			config_table.subspace = false
		else	
			ColourNote("yellow", "", "Subspace enabled for " .. window_title .. " window ")
			config_table.subspace = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
		BroadcastPlugin(config_table.subspace and 1 or 0, "subspace")
	elseif result == "S2S" then
		if (config_table.s2s) then
			ColourNote("yellow", "", "S2S disabled for " .. window_title .. " window ")
			config_table.s2s = false
		else	
			ColourNote("yellow", "", "S2S enabled for " .. window_title .. " window ")
			config_table.s2s = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
		BroadcastPlugin(config_table.s2s and 1 or 0, "s2s")
	elseif result == "Update Channel list" then
			update_channels("channel_update_command")
			ColourNote("yellow", "", "Updating channel list for " .. window_title .. " window")
	elseif result == "Subspace Spam Filtering" then
		if (config_table.spam) then
			ColourNote("yellow", "", "SpamFilter disabled for " .. window_title .. " window ")
			config_table.spam = false
		else	
			ColourNote("yellow", "", "SpamFilter enabled for " .. window_title .. " window ")
			config_table.spam = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
	elseif result == "Wrap Words only" then
    	if (config_table.wrapwords) then
			ColourNote("yellow", "", "Wrapping on words only disabled for " .. window_title .. " window ")
			config_table.wrapwords = false
		else	
			ColourNote("yellow", "", "Wrapping on words only enabled for " .. window_title .. " window ")
			config_table.wrapwords = true
		end
		SetVariable("config_table", serialize.save("config_table", config_table))
    elseif result == "Auto-shorten URLS" then
        if(GetPluginID() ~= "de6b99ef3f79191fd27d59b0") then
            ColourNote("red", "", "Auto-URL Shortener can only be enabled on the master chatgrabber.")
        else
            if (config_table.autoshorten) then
                ColourNote("yellow", "", "Auto-URL shortening disabled.")
                config_table.autoshorten = false
            else
                ColourNote("yellow", "", "Auto-URL shortening enabled.")
                config_table.autoshorten = true
            end
            SetVariable("config_table", serialize.save("config_table", config_table))
        end
    elseif result == "Clear Buffer" then
        ColourNote("yellow", "", "Clearing buffer in " .. window_title .. " window.")
        clearbuffer()
    elseif result == "Channels" then
		local tbl = {}
		local defaults = {}
		local i = 2
		tbl[1] = "None"
		defaults[1] = false
		
		for k,v in pairsByKeys(channel_table) do
			tbl[i] = k
			defaults[i] = v["echo"]
			i = i+1
		end
		if(i == 2) then
			update_channels("channel_update_command")
			ColourNote("yellow", "", "Updating channels for " .. window_title .. " window. Try your menu selection again.")
			return
		end
		local echo_result = utils.multilistbox ("Choose which channels to show in the main window.", "Main Output Channel Selection", tbl, defaults)
		if echo_result and i > 1 then
			for i,v in ipairs(tbl) do
				if (i ~= 1) then
					if(channel_table[v] and channel_table[v]["echo"] ~= echo_result[i]) then
						BroadcastPlugin(echo_result[i] and 1 or 0, v)
						channel_table[v]["echo"] = echo_result[i]
					end
				end
			end
		end
    end -- if
end -- function right_click_menu

		
function update_channels(name,line,wildcards)

	if (name == "channel_update_command") then
		if (IsTrigger("channel_update_trigger") == 0) then
			DeleteTrigger("channel_update_trigger")
		end
		Send("thi " .. GetPluginID() .. ":[squish(iter(channels(me),if(not(match(##,Subspace-*)),##)))] :END")
		check(AddTriggerEx("channel_update_trigger", "^" .. GetPluginID() .. ":(.*) :END$", "-- update_channels", trigger_flag.Enabled + trigger_flag.OmitFromOutput + trigger_flag.KeepEvaluating + trigger_flag.OneShot + trigger_flag.RegularExpression,
			custom_colour.NoChange, 0, "",  "update_channels", 
            12, 100))
	elseif (name == "channel_update_trigger") then
		local wstring = wildcards[1]
		DeleteTrigger("channel_update_trigger")
		for val in wstring:gmatch("%S+") do 
			if (not channel_table[val]) then
				channel_table[val] = { echo = false }
			end
		end
	end
end


-- Handle triggers, decide if we do it locally, or if a slave wants it
function message_handler(name, line, wildcards, styles)
	local myID = GetPluginID()
	local wild = nil
	local mystyles = { }
	
	-- If we received a string, it's from CallPlugin, unserialize it.
	if (type(styles) == "string") then
		
		local t = { }
		setfenv(assert(loadstring(styles or "")),t)()
		mystyles = t.mystyles
		
		wild = wildcards
	else	
		mystyles = styles
		wild = wildcards[1]
	end
		
	if ((name == "pages" or name == "idlemsg")  and config_table.pages) then
		chats(name, mystyles)
		return true
	elseif (name == "ooc" and config_table.ooc) then	
		chats(name, mystyles)
		return true
	elseif (name:match("navcomp*") and config_table.navcomp) then
		chats(name, mystyles)
		return true
	elseif ((name == "s2s_in" or name == "s2s_out") and config_table.s2s) then
		chats(name, mystyles)
		return true
	elseif (name == "channel") then
		if (not wild) then	
			Note("ERROR: Why are you receiving a nil wildcard?")
			return false
		end
		local subspace = string.match(wild, "(.*)|")
		if (subspace and config_table.subspace) then
			local pattern = "^<([%w.%d<>()\-_']+)\|([%s%w.%d<>()\-_']+)> Status: .+$"
			local tpattern = "^<([%w.%d<>()%-_']+)%|([%s%w.%d<>()%-_']+)> ([%s%w.%d<>()%-_']+) ([%d()]+) has locked tractor beams on ([%s%w.%d<>()%-_']+)%s([%d()]+)"
			local _, source = line:match(pattern)
			local _, tsource, tractoror = line:match(tpattern)		
			
			if (source and config_table.spam) then -- Spam filtering is on and we got a status message
				if (status_table[source] and status_table[source] >= lineStart and status_table[source] <= lineEnd) then  
				-- Old status from same base is visible, let's replace it.
					replace_line(mystyles, status_table[source]) 
					refresh()
				else
					status_table[source] = #lines + 1 -- Otherwise, store it for next iteration
					chats(name, mystyles)
				end
				return true
			elseif (tsource and tractoror and config_table.spam) then
				if (tractor_table[tsource] and tractor_table[tsource].tractoror == tractoror and tractor_table[tsource].line >= lineStart and 				tractor_table[tsource].line <= lineEnd) then
					replace_line(mystyles, tractor_table[tsource].line)
					refresh()
				else
					tractor_table[tsource] = { line = #lines + 1, tractoror = tractoror }
					chats(name, mystyles)
				end
				return true
			else
				chats(name,mystyles)
				return true
			end
		elseif (not subspace and channel_table[wild] and channel_table[wild].echo) then
			--Note(serialize.save("channel_table"))
			chats(name, mystyles)
			return true
		end
	end
	-- A good slave knows when to shutup and stop!
	if (myID ~= "de6b99ef3f79191fd27d59b0") then
		return false
	end
	-- Ok if we got THIS far, we don't want it. Let's scan for slaves that might.
	for k, v in pairs (GetPluginList()) do 
		if (GetPluginInfo(v,1):match("QonChatGrabber_(.+)") and v ~= myID) then
			local err, wanted = CallPlugin(v, "message_handler", name, line, wild, "mystyles = " .. serialize.save_simple(mystyles))
			if (wanted) then -- It wants it, let it handle the printing and we're done
				return
			end
		end
	end
	
	-- Okay.. now we've tried all slaves, if we are still executing, it's not wanted to.. send it back to the main screen.
	
    for _, v in ipairs (styles) do
        local urls = findURLs(v.text)
        if (urls and urls.start) then -- Contains a hyperlink. Handle it.
            local sStart = v.text:sub(1, urls.start-1)
            local sEnd = v.text:sub(urls.stop+1, #v.text)
            
            if (sStart and urls.start ~= 1) then -- We have text before hyperlink. Print it.
                ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),sStart)
            end
            Hyperlink(urls.text, urls.text, "Click to open", "blue", RGBColourToName(v.backcolour), 1)
            if (sEnd) then -- We have text after the hyperlink. Print it.
                ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),sEnd)
            end
        else
            ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),v.text)
        end
    end 
    Note ("")  
end

-- Another window has changed configuration, let's make sure we're not double dipping	
function OnPluginBroadcast(msg, id, name, text)
	if (id == GetPluginID()) then
		return
	end
	if (name:match("QonChatGrabber_(.+)") and msg == 1) then
		if(text == "subspace") then
			config_table.subspace = false
		elseif ( text == "pages") then
			config_table.pages = false
		elseif (text == "ooc") then	
			config_table.ooc = false
		elseif (text == "navcomp") then
			config_table.navcomp = false
		elseif (text == "s2s") then	
			config_table.s2s = false
		else
			if (channel_table[text] and channel_table[text].echo) then
				channel_table[text].echo = false
			end
		end
	end
end

-- Return false if we should print the status message
function handleSpam(source)
  for k, v in pairs(status_table) do
    if (k == source) then
      if (math.abs(v - GetInfo(232)) > 120) then
        status_table[k] = GetInfo(232)
		return false
      else
		return true
	  end
    end
  end
	-- If we got this far, it's not in the table, add it and announce it.
  status_table[source] = GetInfo(232)
    return false
end

function handleTractorSpam(source, tractoror)
	for k, v in pairs(tractor_table) do
	  if (k == source) then
        if (v.tractoror == tractoror) then -- We got a match. We only check tractoror because we want to know if he switched to tractoring someone else
          if(math.abs((v.lastTime - GetInfo(232))) > 120) then -- Has it been at least 2 mins?
            v.lastTime = GetInfo(232)
            return false
		  else
		    return true
          end
        end
      end -- if (source)
    end -- for
	-- If we got this far, it's not in the table. Add it and announce.
	tractor_table[source] = { tractoror = tractoror, lastTime = GetInfo(232) }
	return false
end

function wheel_move (flags, hotspot_id)
	local direction = (bit.band(flags,0x100) ~= 0) and "down" or "up"
	
	if (direction == "up" and lineStart > 1) then
		lineStart = lineStart - 1
		lineEnd = lineEnd - 1
	elseif (direction == "down" and lineEnd < #lines) then
		lineStart = lineStart + 1
		lineEnd = lineEnd + 1
	end
	refresh()
	return
end -- wheel_move


function replace_line(styles, location)

	local length = 1
	local remove = table.remove

	-- Add new timestamp if it's enabled

	if (timestamp) then
	  local tstamp = os.date (date_format)
      table.insert (styles, 1, 
		{ text = tstamp, textcolour  = ColourNameToRGB (TIMESTAMP_TEXT_COLOUR), backcolour = ColourNameToRGB (TIMESTAMP_BACK_COLOUR),
          length = string.len (tstamp), style = 0, timestamp = true,
		})
	end

	-- Find how long the old line is, in case it's split.
	while lines[location + length] and lines[location + length][2] ~= true do
		length = length + 1
	end
	-- Remove line + split lines
	while length > 0 do
		remove(lines,location)
		length = length - 1
	end	
	
	-- Fill in new line
	fillBuffer(styles,location)
	local IsLive = (lineEnd == #lines)

	-- This resets the visible lines. Needed if we replace a shorter string with a longer one, or vise versa. Catch both cases.
	if (lineEnd > #lines or (IsLive and lineEnd < #lines)) then 
		lineStart = math.max(1, #lines-WINDOW_LINES+2)
		lineEnd = math.max(1, #lines)
	end
end

function search(term)
    local matchedLine, searchStart = 1, 1
        
        if (search_table[term]) then
            searchStart = search_table[term] + 1 -- We had a previous match, start 1 line after that
            matchedLine = searchStart
        end
        for i = searchStart, #lines do
            if (lines[i] and lines[i][1]) then
                local tmp = GetLineText(lines[i][1])
                if(tmp:match(term)) then -- We found a match
                    if (lines[matchedLine][1].hilite) then -- If we had an old hilite, remove it
                        lines[matchedLine][1].hilite = nil
                    end
                    matchedLine = i
                    search_table[term] = i -- Save it so we don't match it again
                    lines[i][1].hilite = true
                    if ( i > 1) then
                        lineStart = i-1
                    else 
                        lineStart = 1
                    end
                    lineEnd = math.min(lineStart + WINDOW_LINES-2, #lines)
                    refresh()
                    return;
                end -- if match
            end -- if line
        end -- for
        -- If we got this far, no match found.
        ColourNote("white", "", string.format("Search term %s not found.", term))
 end -- function
 
 function findURLs(text)
	local URLs = {}
	local start, position = 0, 0
	-- "rex" is a table supplied by MUSHclient for PCRE functionality.
	local re = rex.new("(?:https?://|mailto:)\\S*[\\w/\=@#\*\\-\\?]")
	re:gmatch(text,
		function (link, _)
			start, position = string.find(text, link, position, true)
			URLs = {start=start, stop=position, text=link}
		end
	)
    if (URLs.text) then
        
      return URLs
    else 
      return nil
    end
end -- function findURL

function clearbuffer()
    for k,_ in ipairs(rawlines) do 
        rawlines[k] = nil
    end
    for i = 1, #lines do
        lines[1] = nil
    end
    lines = { }
    rawlines = { }
    lineStart = 1
    lineEnd = 1
    refresh()
end

-- Uses the tinyurl.com API to generate a shortened URL and return it
function tinyify(text)
    
    if (not text) then
        ColourNote("red", "", "Error shortening URL (Nil)")
        return
    end
    
    local URL = "http://tinyurl.com/api-create.php?url="
    local http = require("socket.http")
    local urls = findURLs(text)
    if (not urls or not urls.start) then
        ColourNote("red", "", "Error shortening URL (No URL given)")
        return text
    end
    local page, retval = http.request(URL .. text)
    
    if (retval ~=200) then
        ColourNote("red", "", "Error shortening URL. (" .. tostring(retval) .. ")")
    else
        return page
    end
end

function OnPluginCommandEntered (sText)
    if (config_table.autoshorten == true) then
        local urls = findURLs(sText)
        if (urls and urls.start and #urls.text >24) then -- We found a URL. Shorten and replace
            local sStart = sText:sub(1, urls.start-1)
            local sEnd = sText:sub(urls.stop+1, #sText)
            local tURL = tinyify(urls.text)
           return sStart .. tURL .. sEnd
        else
            return sText
        end
    else
        return sText
    end
 end

]]>
</script>
</muclient>