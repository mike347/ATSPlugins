<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, May 23, 2014, 9:34 PM -->
<!-- MuClient version 4.84 -->

<!-- Plugin "ATS_ShieldStatus" generated by Plugin Wizard -->

<muclient>
<plugin
   name="AAATS_ShieldStatus"
   author="marQon @ATS"
   id="57a49cca2ef1da0b52498a94"
   language="Lua"
   purpose="To visually show shield status"
   date_written="2014-05-23 21:33:22"
   requires="4.84"
   version="1.15"
   save_state="y"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>

  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="^Superstructure\s+([-\d]+)%\s+(Patched|Minor|Light|Moderate|Major|Severe|Heavy|Inoperative|Destroyed)([\s&quot;Damage&quot;]*)([\d.]+)$"
   keep_evaluating="y"
   name="damstat_ss"
   regexp="y"
   script="fun_update_ss"
   sequence="100"
  > 
  
    </trigger>
<trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="^Impulse\sDrive\s+.*\s?Superstructure\s+([\d-]+)%\s+.*\s?[-]{79}$"
   keep_evaluating="y"
   name="engstat_ss"
   regexp="y"
   script="fun_update_ss"
   sequence="100"
  > 
  </trigger>
  
  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   lines_to_match="12"
   match="^\s+Shield Freq:\s+[\d.\sGHz]+.*\s+[-]{79}\s+System Name\s+Funct Status\s+Specifics\s+[-\s]+Cloaking Device\s+[\d-%]+\s.*\s+Forward shield\s+([\d-]+)%\s.*\s+Starboard shield\s+([\d-]+)%.*\s+Aft shield\s+([\d-]+)%\s.*\s+Port shield\s+([\d-]+)%\s.*\s+Dorsal shield\s+([\d.-]+)%\s.*\s+Ventral\sshield\s+([\d-.]+)%\s.*\s+[-]{79}$"
   multi_line="y"
   name="helmstat_shields1"
   regexp="y"
   script="fun_update_shields"
   sequence="100"
  >

  </trigger>

  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="\[Superstructure:\s+([\d-]+)%\s.*\]$"
   name="damaged_ss"
   regexp="y"
   script="fun_update_ss"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="^\[.*\]--\[Superstructure (repaired to (\d+)%|repairs complete)\]$"
   name="repaired_ss"
   regexp="y"
   script="fun_update_ss"
   sequence="100"
  >
  </trigger>
	
  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="^(Forward|Starboard|Aft|Port|Dorsal|Ventral)\s+shield\s+([-\d]+)%\s+(Patched|Minor|Light|Moderate|Major|Severe|Heavy|Inoperative|Destroyed)([\s&quot;Damage&quot;]*)([\d.]+)$"
   name="damstat_shields"
   keep_evaluating="y"
   regexp="y"
   script="fun_update_shields"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   group="ATS_ShieldStatus"
   match="^\[(Forward|Aft|Port|Starboard|Dorsal|Ventral)\s+shield:\s+([\d-]+)%\s+.*\]$"
   name="damaged_shields"
   regexp="y"
   script="fun_update_shields"
   sequence="100"
  >
  </trigger>

  </triggers>
<!-- <timers>
  <timer name="ShieldStatus_Updater" enabled="n" second="1.00" offset_second="0.00"    send_to="12"
>
  <send>CallPlugin("74f8c420df7d59ad5aa66246", "Send_GMCP_Packet", "Space.FullUpdate")</send>

  </timer>
</timers>
-->
<!--  Script  -->


<script>
<![CDATA[
require "mw"
require "json"
local GMCPID = "74f8c420df7d59ad5aa66246"

local ShieldStatus = { ["Forward"] = 1.0, ["Starboard"] = 1.0, ["Aft"] = 1.0, ["Port"] = 1.0, ["Dorsal"] = 1.0, ["Ventral"] = 1.0, ["SS"] = 1.0, ["Name"] = nil, ["Mode"] = "Unknown" }
local Course = { ["Autopilot"] = 0, ["Pitch"] = 0.0, ["Yaw"] = 0.0, ["Roll"] = 0.0, ["Speed"] = 0.0, ["Velocity"] = 0.0, ["Cochranes"] = 0.0, ["DestX"] = 0.0, ["DestY"] = 0.0, ["DestZ"] = 0.0, ["CoordX"] = 0.0, ["CoordY"] = 0.0, ["CoordZ"] = 0.0 }
local ShieldPriority = { ["Forward"] = 0, ["Starboard"] = 0, ["Aft"] = 0, ["Port"] = 0, ["Dorsal"] = 0, ["Ventral"] = 0, ["SS"] = 0, ["RepCapRate"] = 0 }
local Specials = { ["Hellbore"] = 20, ["HellboreRecycle"] = " 0s", ["PlasmaBomb"] = 35, ["PlasmaBombRecycle"] = " 0s", ["AblativeArmor"] = 2.0, ["HazardEmitter"] = 1, ["HazardEmitterRecycle"] = " 5s"}
local last_packet = {} -- Store the last packet
local update_rate = 1 -- Store current rate of refreshes in seconds
local update_repeat = 0 -- How many times in a row have we received same packet?
local debugmode = false
local colorscheme = "Default"
local GAUGE_LEFT = 100
local GAUGE_HEIGHT = 15

local WINDOW_WIDTH = 260
local WINDOW_HEIGHT = 215
local NUMBER_OF_TICKS = 4

local BACKGROUND_COLOR = ColourNameToRGB("black")
local FONT_COLOR = ColourNameToRGB("orange")
local BORDER_COLOR = ColourNameToRGB("#553333")
local FONT2_COLOR = ColourNameToRGB("white")
local TEXT_VALUE_COLOR = ColourNameToRGB("lightsteelblue")
local TEXT_ITEM_COLOR = ColourNameToRGB("lime")
local TEXT_VALUE_COLOR2 = ColourNameToRGB("yellow")

local win = GetPluginID ()
local font_id = "fn_" .. GetPluginID()
local font_name = "Verdana"    -- the actual font
local font_size = 9
local font_height = 0 -- These are set later when we make the actual window
local font_width = 0 -- Because we cant get this until a window exists

function send_pulse()
  CallPlugin(GMCPID, "Send_GMCP_Packet", "Space.FullUpdate")
end

local function Debug(t, ...)
  if not debugmode or not t then 
    return 
  end
  Note("DEBUG: " .. string.format(t,...))
end

function OnPluginBroadcast (msg, id, name, text)
   if (id ~= "74f8c420df7d59ad5aa66246" ) then  -- GMCP_handler
     return
   end
 
 -- pull out GMCP message, plus the data belonging to it
   message, params = string.match (text, "([%a.]+)%s+(.*)")
  
  -- No match.. something is wrong. Stop.
  if (not message) then
    return
  end 
   
  if (message == "console.unman") then -- Server sends this when you unman a console.
    
    if (IsTimer("ShieldStatus_Updater")) then
      EnableTimer("ShieldStatus_Updater", false);
      DeleteTimer("ShieldStatus_Updater")
    end
    WindowFilter (win, 0, 0,  WINDOW_WIDTH, WINDOW_HEIGHT, 25, 0) -- blur both directions
    return
   elseif (message == "console.man") then  -- Server sends this when you man a console.
     
     if(IsTimer("ShieldStatus_Updater")) then
       DeleteTimer("ShieldStatus_Updater")
     end  
     AddTimer("ShieldStatus_Updater", 0, 0, 1, "", timer_flag.Enabled, "send_pulse")
     UpdateDisplay()
     return
   end
  
  if (message ~= "shield.status") then -- We only care about shields
     return
   end
   
   -- ensure we have an array or object
  if not string.match (params, "^[%[{]") then
      params =  "[" .. params .. "]"  -- JSON hack, make msg first element of an array.
   end -- if 
   
   -- decode it
  result = assert (json.decode (params))
  if (result["fore"]) then
    ShieldStatus.Forward = result["fore"]
   end
  if (result["star"]) then
    ShieldStatus.Starboard = result["star"]
   end
  if (result["aft"]) then 
     ShieldStatus.Aft = result["aft"]
   end
  if (result["port"]) then
     ShieldStatus.Port = result["port"]
   end
  if (result["dors"]) then
     ShieldStatus.Dorsal = result["dors"]
   end
  if (result["vent"]) then
     ShieldStatus.Ventral = result["vent"]
   end
  if (result["ss"]) then
     ShieldStatus.SS = result["ss"]
   end
  if (result["name"]) then
     ShieldStatus.Name = result["name"]
   end
  if (result["pri_fore"]) then
    ShieldPriority.Forward = result["pri_fore"]
   end
  if (result["pri_star"]) then
    ShieldPriority.Starboard = result["pri_star"]
   end
  if (result["pri_aft"]) then 
     ShieldPriority.Aft = result["pri_aft"]
   end
  if (result["pri_port"]) then
     ShieldPriority.Port = result["pri_port"]
   end
  if (result["pri_dors"]) then
     ShieldPriority.Dorsal = result["pri_dors"]
   end
  if (result["pri_vent"]) then
     ShieldPriority.Ventral = result["pri_vent"]
   end
  if (result["pri_ss"]) then
     ShieldPriority.SS = result["pri_ss"]
   end
  if (result["repcap_rate"]) then
	 ShieldPriority.RepCapRate = result["repcap_rate"]
	end
	
  for k, v in pairs(Course) do
    if(result[k]) then
      Course[k] = tonumber(result[k])
    end
  end
  
  for k, v in pairs(Specials) do
    if (result[k]) then
      Specials[k] = tonumber(result[k])
    end
  end
  UpdateDisplay()
   
  local new_rate = 1
   
  if(equals(result, last_packet, true)) then
     update_repeat = update_repeat + 1
   else
     update_repeat = 1
  end
  
  if(update_repeat > 10) then -- After 10 seconds of same data, we start throttling
    new_rate = update_repeat
    if (new_rate > 60) then
      new_rate = 60
    end
    
  else
    new_rate = 1
  end
  -- Save this packet 
  last_packet = result
    
  if (new_rate ~= old_rate) then -- Our update rate is changing. Delete timer and re-add.
    -- Make sure timer exists before we try to delete
    if (IsTimer("ShieldStatus_Updater")) then
      DeleteTimer("ShieldStatus_Updater")
    end
    if (new_rate >= (60 * 60)) then -- 1 hour is our max
      AddTimer("ShieldStatus_Updater", 1, 0, 0, "", timer_flag.Enabled, "send_pulse")
      ColourNote("orange", "", "ShieldStatus: Throttling updates to 1 hour. Consider unmanning your console if you are idling.")
    elseif (new_rate >= 60) then -- Convert seconds to minutes
      AddTimer("ShieldStatus_Updater", 0, new_rate, 0, "", timer_flag.Enabled, "send_pulse")
      if(new_rate > 60 and update_rate < 60) then
        ColourNote("orange", "", "Shieldstatus: Throttling updates to 1 minute intervals. Consider unmanning a console if you are idling.")
      end      
    else -- Seconds
      AddTimer("ShieldStatus_Updater", 0, 0, new_rate, "", timer_flag.Enabled, "send_pulse")
    end
  end
  update_rate = new_rate
  
  -- If we get this far and don't have a timer, set one because we're obviously on a console somehow.
  if (not IsTimer("ShieldStatus_Updater")) then
    AddTimer("ShieldStatus_Updater", 0, 0, 1, "", timer_flag.Enabled, "send_pulse")
  end
end

-- Forward, Starboard, Aft, Port, Dorsal, Ventral

function fun_update_shields(name, _, wildcards)
  
  if (name == "helmstat_shields1" or name == "helmstat_shields2") then -- From helm stats
    for i = 1, #wildcards do -- Turns wildcards into numbers, makes sure they aren't null.
      wildcards[i] = tonumber(wildcards[i])
      if not i then
        return
      end
      
    end
    ShieldStatus.Forward = wildcards[1]/100
    ShieldStatus.Starboard = wildcards[2]/100
    ShieldStatus.Aft = wildcards[3]/100
    ShieldStatus.Port = wildcards[4]/100
    ShieldStatus.Dorsal = wildcards[5]/100
    ShieldStatus.Ventral = wildcards[6]/100
    UpdateDisplay()
    return
    
  else  -- Damstat or from damage received. Wildcards[1] should be name, wildcards[2] should be percentage
    
    local i = tonumber(wildcards[2])
    
    if (wildcards[1] == "Forward") then
      ShieldStatus.Forward = i/100
    elseif (wildcards[1] == "Starboard") then
      ShieldStatus.Starboard = i/100
    elseif (wildcards[1] == "Aft") then
      ShieldStatus.Aft = i/100
    elseif (wildcards[1] == "Port") then
      ShieldStatus.Port = i/100
    elseif (wildcards[1] == "Ventral") then
      ShieldStatus.Ventral = i/100
    elseif (wildcards[1] == "Dorsal") then
      ShieldStatus.Dorsal = i/100
    end
    UpdateDisplay()
  end
end

function fun_update_ss(name, _, wildcards)
  local i = 100
  
  if (name == "repaired_ss") then -- If we pass 2 arguments, its repaired to a percentage, else it's fully repaired.
    if(wildcards[2]) then
      i = tonumber(wildcards[2]) or 100
    end
    ShieldStatus.SS = i/100
    UpdateDisplay()
    Debug("SS: ".. i)
    return
  else
    i = tonumber(wildcards[1])
    if not i then 
      return
    end
    ShieldStatus.SS = i/100
    UpdateDisplay()
    Debug("SS: ".. i)
  end
end
 
  function fun_shieldstatus(_,_,_)
    return string.format("For: %d%%, Star: %d%%, Aft: %d%%, Port: %d%%, Dors: %d%%, Vent: %d%%, SS: %d%%", ShieldStatus.Forward*100, ShieldStatus.Starboard*100, ShieldStatus.Aft*100, ShieldStatus.Port*100,ShieldStatus.Dorsal*100, ShieldStatus.Ventral*100, ShieldStatus.SS*100)
  end

function fun_reset()
  
  for i,v in pairs(ShieldStatus) do
    ShieldStatus[i] = 1.0
  end
  UpdateDisplay()
  
  Debug("Shields/SS Reset.")
end

function fun_shield_repaired(name,_,wildcards)
  local percent = 1.0
  
  if (#wildcards == 2) then -- 2 wildcards means we got percentage, otherwise it's a full repair
    percent = tonumber(wildcards[2]) 
  end
    
  if not percent then
    percent = 1.0
  else
    percent = percent / 100
  end
  
  local lowest = 1.0
  local lowname = nil
    for i, v in pairs(ShieldStatus) do
      if (v < lowest and v <= percent and math.abs(percent - v) <= 0.2) then -- Lower than previous low, less than or equal to percent, and the difference is not greater than 0.2
        lowest = v
        lowname = i
      end
    end
    if (not lowname) then -- We didn't find the lowest obvious shield, lets try just adding 20% (Maxrepcap) to each shield and see if we hit paydirt.
      for i, v in pairs(ShieldStatus) do
        if (math.abs(v - percent) == 0.2) then
          ShieldStatus[i] = percent
          Debug("Found shield by repair: " .. i)
          UpdateDisplay()
          return
        end
      end
    else
      ShieldStatus[lowname] = percent
      Debug("Found shield by repair: " .. lowname)
      UpdateDisplay()

      return
    end
  end  
  
--[[
-- Below this line is a modified version of Nick Gammon's Health_Bar_Miniwindow.xml
-- Modified for our own usage.
--]]

function right_click_menu ()
	menustring = string.format("^Shield Status v%s|-|", tostring(GetPluginInfo(GetPluginID(), 19)))
  menustring = menustring .. "Manual Refresh"
  menustring = menustring .. "|>Settings|Change Font|Gauge Width|Gauge Ticks|<"
  menustring = menustring .. string.format("|>Color Scheme|%sDefault|%sNausicaan|%sCustom", colorscheme == "Default" and "+" or "", colorscheme == "Nausicaan" and "+" or "", colorscheme == "Custom" and "+" or "")
  menustring = menustring .. "|>Custom Colors|Label Color|Value Color|Value Hilight Color|Background Color|System Name Color|System Percent Color|Border Color|<|Reload Defaults|<"
  if (update_rate > 10) then
    local rate = ""
    if (update_rate > (60 * 60)) then
      rate = "1 hour"
    elseif (update_rate > 60) then
      rate = (update_rate / 60) .. " minutes"
    else
      rate = update_rate .. " seconds"
    end
    menustring = menustring .. "|-|^Throttling: " .. rate
  end
  
  local result = WindowMenu (win, 
        WindowInfo (win, 14),  -- x position
        WindowInfo (win, 15),   -- y position
        menustring) -- content
  if ( result == "Manual Refresh") then
        CallPlugin(GMCPID, "Send_GMCP_Packet", "Space.FullUpdate")
        ColourNote("yellow", "", "Sending manual GMCP Update request..")
  elseif (result == "Default") then
    colorscheme = "Default"
    ColourNote("yellow", "", "Shield Status: Setting color scheme to Default.")
  elseif (result == "Nausicaan") then
    colorscheme = "Nausicaan"
    ColourNote("yellow", "", "Shield Status: Setting color scheme to Nausicaan.")
  elseif (result == "Custom") then
    colorscheme = "Custom"
    ColourNote("yellow", "", "Shield Status: Loading custom color scheme.")
  elseif (result == "Change Font") then
        wanted_font = utils.fontpicker (font_name, font_size) --font dialog
        if (wanted_font) then
            font_name = wanted_font.name
            font_size = wanted_font.size
            SetVariable ("font_name", font_name)
            SetVariable ("font_size", font_size)
            OnPluginInstall()
        end
  elseif (result == "Gauge Width") then
      local tmp = utils.inputbox ("Gauge Width in pixels. Default is 100. Lower numbers increase size, higher decreases.", "ATS Shield Status", GAUGE_LEFT, "Courier", 9, {max_length = 4 }) 
      if (tmp and tonumber(tmp) ~=GAUGE_LEFT) then
        ColourNote("yellow", "", "Gauge width changed to " .. tmp)
        GAUGE_LEFT = tonumber(tmp)
        UpdateDisplay()
      end
  elseif (result == "Gauge Ticks") then
      local tmp = utils.inputbox("Number of Gauge ticks (seperators in the percentage bar). Set to 0 to disable entirely.", "ATS Shield Status", NUMBER_OF_TICKS, "Courier", 9, {max_length = 4})
      if (tmp and tonumber(tmp) ~= NUMBER_OF_TICKS) then
        ColourNote("yellow", "", "ShieldStatus: Gauge Ticks set to " .. tmp)
        NUMBER_OF_TICKS = tonumber(tmp)
        UpdateDisplay()
      end
  elseif (result == "Label Color") then
    SetVariable("TEXT_ITEM_COLOR", PickColour(TEXT_ITEM_COLOR))
  elseif (result == "Value Color") then
    SetVariable("TEXT_VALUE_COLOR", PickColour(TEXT_VALUE_COLOR))
  elseif (result == "Value Hilight Color") then
    SetVariable("TEXT_VALUE_COLOR2", PickColour(TEXT_VALUE_COLOR2))
  elseif (result == "Background Color") then
    SetVariable("BACKGROUND_COLOR", PickColour(BACKGROUND_COLOR))
  elseif (result == "System Name Color") then
    SetVariable("FONT_COLOR", PickColour(FONT_COLOR))
  elseif (result == "System Percent Color") then
    SetVariable("FONT2_COLOR", PickColour(FONT2_COLOR))
  elseif (result == "Border Color") then
    SetVariable("BORDER_COLOR", PickColour(BORDER_COLOR))
  elseif (result == "Reload Defaults") then
    SetVariable("BACKGROUND_COLOR", ColourNameToRGB("black"))
    SetVariable("FONT_COLOR",  ColourNameToRGB("orange"))
    SetVariable("BORDER_COLOR", ColourNameToRGB("#553333"))
    SetVariable("FONT2_COLOR",  ColourNameToRGB("white"))
    SetVariable("TEXT_VALUE_COLOR",  ColourNameToRGB("lightsteelblue"))
    SetVariable("TEXT_ITEM_COLOR",  ColourNameToRGB("lime"))
    SetVariable("TEXT_VALUE_COLOR2", ColourNameToRGB("yellow"))
  end
  set_color_scheme(colorscheme)
end


function mouseUp(flags, hotspot_id)
  if(flags == miniwin.hotspot_got_rh_mouse) then
    right_click_menu()
  end
end

function mousedown(flags, hotspot_id)

  -- find where mouse is so we can adjust window relative to mouse
  startx, starty = WindowInfo (win, 14), WindowInfo (win, 15)
  
  -- find where window is in case we drag it offscreen
  origx, origy = WindowInfo (win, 10), WindowInfo (win, 11)
end -- mousedown

function dragmove(flags, hotspot_id)
  if (flags == miniwin.hotspot_got_rh_mouse) then
    return
  end
  
  -- find where it is now
  local posx, posy = WindowInfo (win, 17),
                     WindowInfo (win, 18)

  -- move the window to the new location
  WindowPosition(win, posx - startx, posy - starty, 0, 2);
  
  -- change the mouse cursor shape appropriately
  if posx < 0 or posx > GetInfo (281) or
     posy < 0 or posy > GetInfo (280) then
    check (SetCursor ( 11))   -- X cursor
  else
    check (SetCursor ( 1))   -- hand cursor
  end -- if
  
end -- dragmove

function dragrelease(flags, hotspot_id)
  local newx, newy = WindowInfo (win, 17), WindowInfo (win, 18)
  
  -- don't let them drag it out of view
  if newx < 0 or newx > GetInfo (281) or
     newy < 0 or newy > GetInfo (280) then
     -- put it back
    WindowPosition(win, origx, origy, 0, 2);
  end -- if out of bounds
  
end -- dragrelease


function DoGauge (sPrompt, Fraction)
  local Percent = Fraction -- We do this just incase it's a negative number, we can print it.
  local Background = BACKGROUND_COLOR
  
  if Fraction > 1 then Fraction = 1 end
  if Fraction < 0 then Fraction = 0 end
  
  Color = (Fraction > 0.5 and ColourNameToRGB("green") or ColourNameToRGB("red")) 
  
  local width = WindowTextWidth (win, font_id, sPrompt)

if (Fraction > 0.5 ) then
	Background = ColourNameToRGB("yellow")
  elseif (Fraction > 0.0 and Fraction < 0.5) then
	Background = ColourNameToRGB("red")
end

  WindowText (win, font_id, sPrompt,
                             GAUGE_LEFT - width, vertical, 0, 0, FONT_COLOR)

  WindowRectOp (win, 2, GAUGE_LEFT, vertical, WINDOW_WIDTH -5 , vertical + GAUGE_HEIGHT, 
                          Background)  -- fill entire box
 
    
  local gauge_width = (WINDOW_WIDTH - GAUGE_LEFT - 5) * Fraction
  
   -- box size must be > 0 or WindowGradient fills the whole thing 
  if math.floor (gauge_width) > 0 then
    
    -- top half
    WindowGradient (win, GAUGE_LEFT, vertical, GAUGE_LEFT + gauge_width, vertical + GAUGE_HEIGHT / 2, 
                    0x000000,
                    Color, 2) 
    
    -- bottom half
    WindowGradient (win, GAUGE_LEFT, vertical + GAUGE_HEIGHT / 2, 
                    GAUGE_LEFT + gauge_width, vertical +  GAUGE_HEIGHT,   
                    Color,
                    0x000000,
                    2) 

  end -- non-zero
  
  -- show ticks
  
  
  -- ticks
  if (NUMBER_OF_TICKS > 0) then
    local ticks_at = (WINDOW_WIDTH - GAUGE_LEFT - 5) / (NUMBER_OF_TICKS + 1)
    for i = 1, NUMBER_OF_TICKS do
      WindowLine (win, GAUGE_LEFT + (i * ticks_at), vertical, 
                  GAUGE_LEFT + (i * ticks_at), vertical + GAUGE_HEIGHT, ColourNameToRGB ("silver"), 0, 1)
    end -- for
  end
  -- draw a box around it
  check (WindowRectOp (win, 1, GAUGE_LEFT, vertical, WINDOW_WIDTH - 5, vertical + GAUGE_HEIGHT, 
          ColourNameToRGB ("lightgrey")))  -- frame entire box
  if (Percent == -1.0) then
    WindowText(win, font_id, Percent*100 .. "%" .. " (Dest)", GAUGE_LEFT + 5, vertical, 0, 0, FONT2_COLOR) -- Draw's our percentage
  elseif (Percent < 0.0 and Percent > -1.0) then
    WindowText(win, font_id, Percent*100 .. "%" .. " (Inop)", GAUGE_LEFT + 5, vertical, 0, 0, FONT2_COLOR) -- Draw's our percentage
  else
    WindowText(win, font_id, Percent*100 .. "%", GAUGE_LEFT + 5, vertical, 0, 0, FONT2_COLOR) -- Draw's our percentage
  end
  
  vertical = vertical + font_height + 3
end -- function

function UpdateDisplay()

  vertical = 6
  offset = 5
  offset_tmp = 0
  
  -- fill entire box to clear it
  check (WindowRectOp (win, 2, 0, 0, 0, 0, BACKGROUND_COLOR))  -- fill entire box
  
  -- Edge around box rectangle
  check (WindowCircleOp (win, 3, 0, 0, 0, 0, BORDER_COLOR, 0, 2, 0, 1))

  if(ShieldStatus.Name == nil or #ShieldStatus.Name <= 1) then
    WindowText(win, font_id, "Please man a console", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    vertical = vertical + font_height +3
    WindowText(win, font_id, " or type a space command to", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    vertical = vertical + font_height +3
    WindowText(win, font_id, "update data.", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    WindowShow (win, true)
    return
  end
  
  WindowText(win, font_id, "Ship: ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
  WindowText(win, font_id, ShieldStatus.Name, offset + (font_width * string.len("Ship: ")), vertical, 0, 0, TEXT_VALUE_COLOR)
  vertical = vertical + font_height + 3
  
--  WindowText(win, font_id, "Class: ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
  --WindowText(win, font_id, ShieldStatus.Class, offset + (font_width * string.len("Class: ")), vertical, 0, 0, TEXT_VALUE_COLOR)
  --vertical = vertical + font_height + 3
  
  WindowText(win, font_id, "Heading: ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
  tmptxt = " " .. Course.Yaw .. " / " .. Course.Pitch
  
  WindowText(win, font_id, tmptxt, offset + (font_width * string.len("Heading: ")), vertical, 0, 0, TEXT_VALUE_COLOR)
  WindowText(win, font_id, "(" .. round(Course.Cochranes,0) .. "c)", offset + (font_width * string.len("Heading:  " .. tmptxt .. "  ")), vertical, 0, 0, TEXT_VALUE_COLOR2)
  
  vertical = vertical + font_height + 3
  local distance = xyz2range(Course.CoordX, Course.CoordY, Course.CoordZ, Course.DestX, Course.DestY, Course.DestZ)
  if (distance > 0.0) then
    local d = format_distance(distance) 
        
    offset_tmp = WindowText(win, font_id, "Dest: ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    --WindowText(win, font_id, d, offset + (font_width * (string.len("Dest:") + 2)), vertical, 0, 0, TEXT_VALUE_COLOR)
    offset_tmp = offset_tmp + WindowText(win, font_id, d, offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    if (Course.Autopilot > 0) then
      offset_tmp = offset_tmp + WindowText(win, font_id, " (AP On)", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR2)
    else
      offset_tmp = offset_tmp + WindowText(win, font_id, " (AP Off)", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR2)
    end
    if (Course.Velocity > 0.0) then
      offset_tmp = offset_tmp + WindowText(win, font_id, " - ", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
      if ((distance / Course.Velocity) > 60*60*24) then
        WindowText(win, font_id, " A long time", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
      else
        WindowText(win, font_id, timestring(distance / Course.Velocity), offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
      end
    end
    vertical = vertical + font_height + 3
  end
    
  offset_tmp = WindowText(win, font_id, "Speed:" , offset, vertical, 0, 0, TEXT_ITEM_COLOR)
  
  
  if (Course.Speed == 0) then
    offset_tmp = offset_tmp + WindowText(win, font_id, "  Stationary", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
  else
    local s
    if (Course.Speed >= 1.0 or Course.Speed <= -1.0) then
      s = " w" .. round(Course.Speed,3)
    else
      s = " " .. round(Course.Speed,3) * 100 .. "%"
    end
    local v = format_distance(Course.Velocity)
    if (Course.Velocity >9999999.0) then
      v = v .. " PC/s"
    else
      v = v .. " SU/s"
    end
    
    offset_tmp = offset_tmp + WindowText(win, font_id, s .. " ", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    WindowText(win, font_id, v, offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR2)
  end
  
  vertical = vertical + font_height + 3 -- pixel to start at
  if (Specials.Hellbore > 0) then
    offset_tmp = WindowText(win, font_id, "Hellbore:  ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    if (Specials.HellboreRecycle >=90) then
      WindowText(win, font_id, Specials.Hellbore .. "  (Ready)", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    else
      WindowText(win, font_id, Specials.Hellbore .. "  (" .. timestring(Specials.HellboreRecycle), offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    end
    vertical = vertical + font_height + 3
  end
  if (Specials.PlasmaBomb > 0) then
   offset_tmp = WindowText(win, font_id, "PlasmaBomb:  ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    if (Specials.PlasmaBombRecycle >=90) then
   
      WindowText(win, font_id, Specials.PlasmaBomb .. "  (Ready)", offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    else
    
      WindowText(win, font_id, Specials.PlasmaBomb .. "  (" .. timestring(Specials.PlasmaBombRecycle), offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    end
    vertical = vertical + font_height + 3
  end
  if (Specials.HazardEmitter > 0) then
   offset_tmp = WindowText(win, font_id, "HazardEmitter:  ", offset, vertical, 0, 0, TEXT_ITEM_COLOR)
    if (Specials.HazardEmitterRecycle >= 90 ) then
   
      WindowText(win, font_id, "Ready", offset +   offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    else
      WindowText(win, font_id, timestring(Specials.HazardEmitterRecycle), offset + offset_tmp, vertical, 0, 0, TEXT_VALUE_COLOR)
    end
    vertical = vertical + font_height + 3
  end
  DoGauge ("(" .. ShieldPriority.Forward .. ") " .. "Fore: ", ShieldStatus.Forward)
  DoGauge ("(" .. ShieldPriority.Starboard .. ") " .. "Star: ", ShieldStatus.Starboard)
  DoGauge ("(" .. ShieldPriority.Aft .. ") " .. "Aft: ", ShieldStatus.Aft)
  DoGauge ("(" .. ShieldPriority.Port .. ") " .. "Port: ",ShieldStatus.Port)
  DoGauge ("(" .. ShieldPriority.Ventral .. ") " .. "Vent: ",ShieldStatus.Ventral)
  DoGauge ("(" .. ShieldPriority.Dorsal .. ") " .. "Dors: ", ShieldStatus.Dorsal)
  DoGauge ("(" .. ShieldPriority.SS .. ") " .. "SS: ", ShieldStatus.SS)
  
  
  WindowShow (win, true)
  
end -- draw_bar

function OnPluginConnect ()
  UpdateDisplay()
  EnableTimer("ShieldStatus_Updater", false);
   CallPlugin(GMCPID, "Send_GMCP_Packet", "Space.FullUpdate")
   
end -- function
function OnPluginDisable ()
  EnableTriggerGroup("ATS_ShieldStatus", false)
  EnableTimer("ShieldStatus_Updater", false);
  WindowShow (win, false)
end

function OnPluginDisconnect ()
  EnableTriggerGroup("ATS_ShieldStatus", false)
  EnableTimer("ShieldStatus_Updater", false);
  WindowShow (win, false)
end

function OnPluginInstall ()
  
  if (IsPluginInstalled(GMCPID)) then
    ColourNote("orange", "", "ATS_ShieldStatus (GMCP-Aware) v" .. GetPluginInfo(GetPluginID(),19) .. " loaded.")
    EnableTriggerGroup("ATS_ShieldStatus", true) -- Still use the trigger group, for damage, etc.
    CallPlugin(GMCPID, "Send_GMCP_Packet", "Space.FullUpdate")
  else
    ColourNote("orange", "", "Attempting to load GMCP Handler...")
       local finfo = utils.info()
       local plugin_folder = finfo["plugins_directory"]
    if (LoadPlugin (plugin_folder .. "/" .. "GMCP_Handler.xml") == error_code.eOK) then
      ColourNote("orange", "", "Success! Now loading Shield status plugin..")
      EnableTriggerGroup("ATS_ShieldStatus", true)
    else
      ColourNote("orange", "", "Error loading GMCP Handler. Please run Qupdate or re-install shield status plugin using qinstall.")
      EnableTriggerGroup("ATS_ShieldStatus", false)
    return
  end
end
    
  local x, y, mode, flags = 
      tonumber (GetVariable ("windowx")) or 0,
      tonumber (GetVariable ("windowy")) or 0,
      tonumber (GetVariable ("windowmode")) or 8, -- bottom right
      tonumber (GetVariable ("windowflags")) or 0
  font_name = GetVariable ("font_name") or "Verdana"
  font_size = tonumber(GetVariable ("font_size")) or 9
  colorscheme = GetVariable("colorscheme") or "Default"
  GAUGE_LEFT = tonumber(GetVariable("GAUGE_LEFT")) or 100
  NUMBER_OF_TICKS = tonumber(GetVariable("TICKS")) or 4
  

  
  -- create temp window so we can get font sizes, adjust the size, then make the window appropriately.
  
  check (WindowCreate (win, 0, 0, 1, 1, 0, 0, ColourNameToRGB ("#000000")))
  check (WindowFont (win, font_id, font_name, font_size, false, false, false, false, 0, 0))  -- normal
  
  font_height = WindowFontInfo (win, font_id, 1)  -- height
  font_width = WindowFontInfo (win, font_id, 6)
  set_color_scheme(colorscheme)
  WINDOW_HEIGHT = font_height * 18
  WINDOW_WIDTH = font_width * 40
  
  -- make miniwindow so I can grab the font info
  check (WindowCreate (win, 
                 x, y, WINDOW_WIDTH, WINDOW_HEIGHT,  
                 mode,   
                 flags,   
                 BACKGROUND_COLOR) )

  -- make a hotspot
  WindowAddHotspot(win, "hs1",  
                   0, 0, 0, 0,   -- whole window
                   "",   -- MouseOver
                   "",   -- CancelMouseOver
                   "mousedown",
                   "",   -- CancelMouseDown
                   "mouseUp",   -- MouseUp
                   "Drag to move or right-click to open menu",  -- tooltip text
                   1, 0)  -- hand cursor
                   
  WindowDragHandler(win, "hs1", "dragmove", "dragrelease", 0) 
                 

  UpdateDisplay()
  
  if GetVariable ("enabled") == "false" then
    ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
    check (EnablePlugin(GetPluginID (), false))
    return
  end -- they didn't enable us last time
 
end -- OnPluginInstall

function OnPluginDisable ()
  WindowShow (win, false)
end -- OnPluginDisable

function OnPluginSaveState ()
  SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
  SetVariable ("windowx", tostring (WindowInfo (win, 10)))
  SetVariable ("windowy", tostring (WindowInfo (win, 11)))
  SetVariable ("windowmode", tostring (WindowInfo (win, 7)))
  SetVariable ("windowflags", tostring (WindowInfo (win, 8)))
  SetVariable ("font_name", font_name)
  SetVariable ("font_size", font_size)
  SetVariable ("colorscheme", colorscheme)
  SetVariable ("GAUGE_LEFT", GAUGE_LEFT)
  SetVariable ("TICKS", NUMBER_OF_TICKS)
  
end -- OnPluginSaveState

--[[
-- xyz2range(xa,ya,za,xb,yb,zb) returns range from two XYZ coordinates
-- This is directly converted from aspace\space_utils.c
-- All credit to original author, Atuare @ TrekMUSH
--]]
function xyz2range(xa, ya, za, xb, yb, zb)
        local sqrt = math.sqrt
        assert(xa, "xyz2range(): xa is nil")
        assert(ya, "xyz2range(): ya is nil")
        assert(za, "xyz2range(): za is nil")
        assert(xb, "xyz2range(): xb is nil")
        assert(yb, "xyz2range(): yb is nil")
        assert(zb, "xyz2range(): zb is nil")
        
        local x = xb - xa
        local y = yb - ya
        local z = zb - za
        return sqrt(x * x + y*y + z * z)
end
function timestring(s)
  return string.format("%.2d:%.2d:%.2d", s/(60*60), s/60%60, s%60)
end

function format_distance(dist)
  local PARSEC = 3085659622.014257
  local retval = 0
  
  if(dist > PARSEC * 999.9) then
    retval = round(dist / PARSEC, 0) 
  elseif (dist > PARSEC * 99.99) then
    retval = round(dist / PARSEC, 1)
  elseif (dist > PARSEC * 9.999) then
    retval = round(dist / PARSEC, 2)
  elseif (dist > 9999999.0) then
    retval = round(dist / PARSEC,3)
  elseif (dist > 99999.9) then
    retval = round(dist, 0)
  elseif (dist > 9999.99) then
    retval = round(dist, 1)
  elseif (dist > 999.999) then
    retval = round(dist, 2)
  elseif (dist > 99.9999) then
    retval = round(dist, 3)
  else
    retval = round(dist, 4)
  end
  if (dist > 9999999.0) then
    return "[" .. retval .. "]"
  else
    return retval
  end
end


function round(what, precision)
  return math.floor(what*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function set_color_scheme(scheme)
  
  if (scheme == "Nausicaan") then
    
    BACKGROUND_COLOR = ColourNameToRGB("black")
    FONT_COLOR = ColourNameToRGB("gray")
    BORDER_COLOR = ColourNameToRGB("black")
    FONT2_COLOR = ColourNameToRGB("white")
    TEXT_VALUE_COLOR = ColourNameToRGB("lime")
    TEXT_ITEM_COLOR = ColourNameToRGB("gray")
    TEXT_VALUE_COLOR2 = ColourNameToRGB("green")
  elseif (scheme == "Custom") then
    BACKGROUND_COLOR = GetVariable("BACKGROUND_COLOR") or ColourNameToRGB("black")
    FONT_COLOR = GetVariable("FONT_COLOR") or ColourNameToRGB("orange")
    BORDER_COLOR = GetVariable("BORDER_COLOR") or ColourNameToRGB("#553333")
    FONT2_COLOR = GetVariable("FONT2_COLOR") or ColourNameToRGB("white")
    TEXT_VALUE_COLOR = GetVariable("TEXT_VALUE_COLOR") or ColourNameToRGB("lightsteelblue")
    TEXT_ITEM_COLOR = GetVariable("TEXT_ITEM_COLOR") or ColourNameToRGB("lime")
    TEXT_VALUE_COLOR2 = GetVariable("TEXT_VALUE_COLOR2") or ColourNameToRGB("yellow")
  else 
    BACKGROUND_COLOR = ColourNameToRGB("black")
    FONT_COLOR = ColourNameToRGB("orange")
    BORDER_COLOR = ColourNameToRGB("#553333")
    FONT2_COLOR = ColourNameToRGB("white")
    TEXT_VALUE_COLOR = ColourNameToRGB("lightsteelblue")
    TEXT_ITEM_COLOR = ColourNameToRGB("lime")
    TEXT_VALUE_COLOR2 = ColourNameToRGB("yellow")
  end
     UpdateDisplay()
end
   
function equals(o1, o2, ignore_mt)
    if o1 == o2 then return true end
    local o1Type = type(o1)
    local o2Type = type(o2)
    if o1Type ~= o2Type then return false end
    if o1Type ~= 'table' then return false end

    if not ignore_mt then
        local mt1 = getmetatable(o1)
        if mt1 and mt1.__eq then
            --compare using built in method
            return o1 == o2
        end
    end

    local keySet = {}

    for key1, value1 in pairs(o1) do
        local value2 = o2[key1]
        if value2 == nil or equals(value1, value2, ignore_mt) == false then
            return false
        end
        keySet[key1] = true
    end

    for key2, _ in pairs(o2) do
        if not keySet[key2] then return false end
    end
    return true
end
]]>
</script>


</muclient>
