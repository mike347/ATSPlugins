<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, January 04, 2015, 9:00 AM -->
<!-- MuClient version 4.94 -->

<!-- Plugin "QonUpdater" generated by Plugin Wizard -->

<muclient>
<plugin
   name="QonUpdater"
   author="Qon"
   id="1ec11b537d60054d832b896a"
   language="Lua"
   purpose="Autoupdater for Qon's ATS Plugins"
   save_state="y"
   date_written="2015-01-04 09:00:05"
   requires="4.94"
   version="0.94"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   name="Autoupdate"
   script="CheckUpdates"
   match="qupdate"
   enabled="y"
   group="QonUpdater"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   name="QInstall"
   script="InstallPlugin"
   match="^qinstall (FORCE\s)?(.+)$"
   enabled="y"
   group="QUpdater"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   name="Qlist"
   script="ListPlugins"
   match="qlist"
   enabled="y"
   group="QonUpdater"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>

<timers>
  <timer name="update_trigger" 
         script="CheckUpdates" 
         enabled="n" 
         minute="59" 
   >

  </timer>
</timers>

  <!--  Script  -->
  <script>
    <![CDATA[
 --[[ QonUpdater.lua
 -- Released 1/4/2015
 -- All code is copyrighted to me.
 -- All rights reserved.
 -- Do not redistribute my plugins without my authorization
 --]]

VERSION_URL   = "http://plugins.zens-world.org/versioninfo.lua"
local theme = { bad = "red", normal = "wheat", hilight = "orange", good = "springgreen" }
NavcompID = "8e3fd4f9c269365839520477"
myID = GetPluginID()

 function trim(s)
 local from = s:match"^%s*()"
 return from > #s and "" or s:match(".*%S", from)
end

 function string:split(sep)
    if not sep then
      sep = "%s"
    end
    
    local t={}  
    local i=1
    for str in string.gmatch(self, "([^"..sep.."]+)") do
      t[i] = str
      i = i + 1
    end
    return t
end

 function CN(font,t,...)
  if (...) then
    ColourNote(theme[font] or "white", "", string.format(t,...))
  else
    ColourNote(theme[font] or "white", "", t)
  end
end

function CT(font,t,...)
    if (...) then
    ColourTell(theme[font] or "white", "", string.format(t,...))
  else
    ColourTell(theme[font] or "white", "", t)
  end
end

function BackupFile(file)
  local f = io.open(file, "r")
  local s = nil
  if (not f) then
    return 
  end
    
  s = f:read("*a")
  f:close()

  f = io.open(file .. ".backup", "w+")
  f:write(s)
  f:close()
end

 function InstallPlugin(_,_,wildcards)
   local http = require("socket.http")
   local page, retval = http.request(VERSION_URL)
   local finfo = utils.info()
   local plugin_folder = finfo["plugins_directory"]
   local force = false
   
   if (wildcards[1] and wildcards[1] == "FORCE") then
     force = true
   end
   if (wildcards[2]:upper() == "CHATGRABBER") then
     wildcards[2] = "ChatGrabberMain"
   end
   
   if (retval ~=200) then
     CT("bad","QonInstaller: Error loading version file.")
     return
   end
  local t = { }
  setfenv(assert(loadstring(page)),t)() 
  local info = t.version_info
  if (not info) then
    CN("bad",  "QonInstaller: Error loading version file. Report to Qon.")
    return
  end
    if (wildcards[1]:upper() == "NAVCOMPDATA") then
      CN("bad", "QInstaller: Install Navcomp, it will install data automatically.")
      return
    end
  
  CN("normal",  string.format("QonInstaller: Scanning for uninstalled plugin named \"%s\"...", wildcards[2]))
  
  for k, v in pairs(t.version_info) do
      
    if (v.name:upper():match(wildcards[2]:upper()) and k ~= "NavcompData") then
      if (not force and IsPluginInstalled(k)) then -- It's installed
        CN("bad",  string.format("QonInstaller: %s v%s is already installed!", v.name, GetPluginInfo(k, 19)))
        return
      else
        CT("hilight", "QonInstaller: Found " .. v.name .. ".. Downloading... ")
        page, retval = http.request(v.page .. v.filename)
        if (retval == 200) then
          CT("good","SUCCESS!")
          CT("normal", ".. Attempting install...")
          local f = io.open(plugin_folder .. v.filename, "w+")
          if (not f) then
            CT("bad", "FAILED!")
            return
          end
          AnsiNote("")
          f:write(page)
          f:close()
          if (v.requires) then
            CT("normal", "Found dependencies.. attempting install..")
            for i = 1, #v.requires do
              local f = io.open(plugin_folder .. v.requires[i], "rb")
              if (not f) then
                f = io.open(plugin_folder .. v.requires[i], "wb+")
                if (not f) then
                  CT("bad", "FAILED on " .. v.requires[i])
                end
                page, retval = http.request(v.page .. v.requires[i])
                if (retval == 200) then
                  f:write(page)
                  f:close()
                end
              end
            end
          end
          
          if(k == NavcompID) then -- Load data file too!
            page, retval = http.request(t.version_info["NavcompData"].page .. t.version_info["NavcompData"].filename)
            if (retval ~= 200) then
              CN("red", "QInstaller: Unable to load Navcomp Database.")
              return
            end
            f = io.open(plugin_folder .. t.version_info["NavcompData"].filename, "w+")
            if (not f) then
              CN("red", "QInstaller: Unable to create Navcomp Database file.")
              return
            end
            f:write(page)
            f:close()
          end

         -- DoAfterSpecial (2, "LoadPlugin('" .. plugin_folder .. v.filename .. "')", sendto.script) -- Not working for some reason. screw it.
            if (IsPluginInstalled(k)) then
              ReloadPlugin(k)
            else
              LoadPlugin(plugin_folder .. v.filename, sendto.script)
            end
            return
          else
            CT("bad","FAILED!")
            AnsiNote("")
            return
          end -- retval
        end -- Installed
    end -- if (match)
  end -- for
  -- If we got this far, we found jack squat.
  CN("bad",  "QInstaller: Found nothing matching \"" .. wildcards[2] .. "\"")
  
end -- function
  
   
function CheckUpdates(name)
  
  local http = require("socket.http")
  local silent = false
  local results = 0
  local page, retval = http.request(VERSION_URL) -- Request Version file
  local dbupdate = false
  local finfo = utils.info()
  local plugin_folder = finfo["plugins_directory"]
  
  if (name == "update_trigger") then
    silent = true
  end
 
  if (retval ~= 200 ) then
    if (not silent) then
      CN("bad",  "QUpdater: Error loading version file.")
    end
    return
  end
  
  local t = { }
  setfenv(assert(loadstring(page)),t)() 
  local info = t.version_info
  
  if (not info) then
    if (not silent) then
      CN("bad",  "QUpdater: Error loading version file. Report to Qon.")
    end
    return
  end
  local myversion = GetPluginInfo(myID,19)
  
  if (myversion < t.version_info[myID].version) then
    local v = t.version_info[myID]
    local t = GetPluginInfo(myID,6):split("\\")
    local filename = t[#t]
    if (filename == v.filename) then  
      local page, retval = http.request(v.page .. v.filename)
      CN("hilight", "QUpdater: There is a new version of this plugin. I will download it for you, and attempt to self-update.")
      if (retval == 200 ) then
        local filename = GetPluginInfo(myID, 6)
        local f = io.open(filename, "w+")
        if (not f) then
          CN("bad", "QUpdater: Error updating. Try manually?")
          return
        end
        f:write(page)
        f:close()
        CN("hilite", "QUpdater: Attempting self-update. If this fails, reinstall using plugin manager.")
        BroadcastPlugin(1, "RELOAD")
        
        return
      else
        CN("bad", "QUpdater: Error updating. Try manually?")
        return
      end -- retval
    else -- filename
      CN("red", "Qupdater: I want to update myself.. but can't oh well.")
    end
    
  end -- self version check

  SetStatus("Checking for updated QonPlugins...")
  -- First of 3 loops. Why 3 loops? Because this allows better error handling
  -- First loop just checks for and tags any we want to update
  
   for k, v in pairs(t.version_info) do
    if (k == "NavcompData") then
      v.installed = IsPluginInstalled(NavcompID)
      local NavcompVersion = GetPluginInfo(NavcompID, 19) or 0.0
      if(v.installed and NavcompVersion >=1.17) then -- We do this incase they are using a pre-Qupdater version of Navcomp. It won't have teh dbfile() or dbversion() functions
        local _, file = CallPlugin(NavcompID, "dbfile")
        v.localfile = file
        local _, dbversion = CallPlugin(NavcompID, "dbversion")
        if (dbversion) then
          if (dbversion < v.version and v.localfile) then
            v.update = true
            dbupdate = true
            results = results + 1
          end
        end
      end
    else
      if (IsPluginInstalled(k)) then -- It's installed
        v.installed = GetPluginInfo(k, 19) -- Grab Installed version
        v.localfile = GetPluginInfo(k, 6) -- Grab Installed location
        if (v.installed < v.version) then -- Remote version is more recent, tag it
          v.update = true
          results = results + 1
        end
      end
    end
  end
  
  if (results == 0) then
    if (not silent) then
      CN("normal",  "QUpdater: No updates found.")
    end
  else -- Second loop Downloads the updates
    CN("hilight",  string.format("QUpdater: Found %d updates...preparing to update.", results))
    results = 0 -- Reset result counter so we can use it to slow down the reload process
    for k, v in pairs(t.version_info) do
      if (v.update) then
        CT("normal", "QUpdater: Downloading " .. v.name .. " ...")
        page, retval = http.request(v.page .. v.filename)
        if (retval == 200) then -- 200 is success, anything else we don't care it just means failure
          v.download = page
          CT("good", "SUCCESS!")
          AnsiNote("")
          results = results + 1
           if (v.requires) then
            for i = 1, #v.requires do
              local f = io.open(plugin_folder .. v.requires[i], "rb")
              if (not f) then
                f = io.open(plugin_folder .. v.requires[i], "wb+")
                if (f) then
                  page, retval = http.request(v.page .. v.requires[i])
                  if (retval == 200) then
                    f:write(page)
                    f:close()
                  end
                end
              end
            end
          end -- if (v.requires)
        else
          CT("bad", "FAILED!")
          AnsiNote("")
        end
      end
    end
    
    -- Third loop writes the files and sets up the reloading routine.
    for k, v in pairs(t.version_info) do
      if (v.download) then
        local tmp = v.localfile:split("\\")
        local testfilename = tmp[#tmp] or ""
        if (testfilename == v.filename) then
          BackupFile(v.localfile) -- Back the file up just incase
          local f = io.open(v.localfile, "w+") -- w+ means overwrite
          f:write(v.download) -- Write it
          f:close() -- Close it
          if (k == "NavcompData") then
              --CallPlugin(NavcompID, "load_json", true)
              ReloadPlugin(NavcompID)
          else
            DoAfterSpecial (2, "ReloadPlugin('" .. k .. "')", sendto.script) -- Wait 2 seconds then reload. 
            if (v.whatsnew) then
              ColourTell("yellow", "", "What's new for " .. v.name .. ":\r\n")
              ColourTell("green", "", v.whatsnew)
              AnsiNote("")
            end

          end
          
        else
          CN("bad", "QUpdater: %s filename has changed. Please update manually.", v.name, testfilename, v.filename)
        end
      end  
    end
  end
  SetStatus("")
end

function OnPluginInstall ()
  CN("hilight",  "QUpdater v" .. GetPluginInfo(GetPluginID(),19) .. " loaded.")
end

function ListPlugins()
  local http = require("socket.http")
  local results = 0
  local page, retval = http.request(VERSION_URL) -- Request Version file
  
  if (retval ~= 200 ) then
    CN("bad",  "QUpdater: Error loading version file.")
    return
  end
  
  local t = { }
  setfenv(assert(loadstring(page)),t)() 
  local info = t.version_info
  
  if (not info) then
    CN("bad",  "QUpdater: Error loading version file. Report to Qon.")
    return
  end
  --table.sort(t.version_info, function(a,b) return a.name < b.name end) -- Sort closest to furthest
  AnsiNote(string.format("%s--[%sQon's Plugin List%s]%s%s", ANSI(1,34), ANSI(1,33), ANSI(1,34), string.rep("-", 57), ANSI(0)))
  AnsiNote(string.format("%s%-25.25s %-10.10s\n%s%s%s", ANSI(36), "Plugin Name", "Version", ANSI(0,34), string.rep("-",78), ANSI(0)))
  for k, v in pairs(t.version_info) do
    if (k == "NavcompData") then
    else
      
      local installed = IsPluginInstalled(k)
      local version = installed and GetPluginInfo(k, 19) or nil
      local vcolor = theme.good
      if (installed and version >= v.version) then
        vcolor = theme.good
      elseif (installed and version < v.version) then
        vcolor = theme.bad
      else
        vcolor = theme.normal
      end
      
      if (v.infopage) then
        Hyperlink(v.infopage, v.name,  "Click to open in browser", installed and theme.good or theme.bad, "", true)
        if (#v.name < 25) then
          ColourTell("", "", string.rep(" ", 25 - #v.name))
        end
        ColourTell(vcolor, "", string.format(" %s%s", version or "Not installed", latest and "" or " (" .. v.version .. ")"))
        
      else
        ColourTell(installed and theme.good or theme.bad, "", string.format("%-25.25s",v.name))
        ColourTell(vcolor, "", string.format(" %s%s", version or "Not installed", latest and "" or " (" .. v.version .. ")"))
        
      end
      if (k == NavcompID and installed) then
        local _, dbversion = CallPlugin(NavcompID, "dbversion")
        if (dbversion) then
          local remotedbversion = t.version_info["NavcompData"].version or 0
          ColourTell(dbversion == remotedbversion and theme.good or theme.bad, "", 
              string.format(" DB v%.2f %s", dbversion, dbversion < remotedbversion and "(" .. remotedbversion .. ")" or "") )
          AnsiNote("")
        end
      else
        AnsiNote("")
      end
      
    end
  end -- for
  AnsiNote(ANSI(0,34), string.rep("-",78))
end -- function
  
--[[
-- Co Routine stuff. Didn't work as intended, but don't wanna toss the code just yet.
--

require "socket"
host = "marqon.pi-raspberry.com"
threads = {}    -- list of all live threads
downloads = { } -- Table of downloaded files
 function download (host, file, name)
    local c = assert(socket.connect(host, 80))
    local count = 0    -- counts number of bytes read
    c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
    while true do
      local s, status = receive(c)
      count = count + string.len(s)
      table.insert(downloads[name],s)
      if status == "closed" then break end
    end
    c:close()
    Note(string.format("%s: %d, %s", name, count, table.concat(downloads[name])))    
  end
    
    
  function receive (connection)
      connection:timeout(0)   -- do not block
      local s, status = connection:receive(2^10)
      if status == "timeout" then
        coroutine.yield(connection)
      end
      return s, status
    end
    
function get (host, file, name)
    downloads[name] = { }
    
    -- create coroutine
    local co = coroutine.create(function ()
        download(host, file, name)
      end)
      -- insert it in the list
      table.insert(threads, co)
    end
  
  function CN(n) 
    CN("normal",  n) 
    end
  
  -- Main thread dispatcher. Resumes threads as needed, turns off dispatcher timer when done.
function dispatcher ()
  local n = #threads
  
  if (n == 0) then
    EnableTimer ("dispatcher", false)
    FinishUpdate()
    return
  end   -- no more threads to run
  
  local connections = {}
  SetStatus(string.format("Threads: %d", n))
  for i=1,n do
    CN("Attempting to resume thread: " .. tostring(i))
    local status, res = coroutine.resume(threads[i])
    if not res then    -- thread finished its task?
      CN("Thread has finished: " .. tostring(i))
      table.remove(threads, i)
      break
    else    -- timeout
      CN("Thread timeout: " .. tostring(i))
      table.insert(connections, res)
    end
  end
  --[[if (#connections == n) then
    CN("Connection.select: " .. tostring(#connections))
    socket.select(connections)
  end
end--]]

  

function CheckUpdatesCo(name)
  
  local http = require("socket.http")
  local silent = false
  local results = 0
  
  if (name == "update_trigger") then
    silent = true
  end
  -- If we are already running updates, stop here. Should never happen, but you never know.
  
  if( #threads > 0) then
    return
  end
    
  local page, retval = http.request(VERSION_URL)
  if (retval ~= 200 ) then
    CN("bad",  "QUpdater: Error loading version file.")
    return
  end
  
  SetStatus("Checking for updated QonPlugins...")
  local t = { }
  setfenv(assert(loadstring(page)),t)() 
  local info = t.version_info
  
    for k, v in pairs(plugin_table) do
    if (IsPluginInstalled(k)) then
      v.version = GetPluginInfo(k,19)
      v.localfile = GetPluginInfo(k, 6)
      if (info[k]) then
        if (v.version < info[k].version) then
          results = results + 1
          v.update = true
          get(host, info[k].page, info[k].name)
        end
      else
        v.version = nil
        v.update = false
      end
    end
  end
  if (results > 0) then
    SetStatus(string.format("QUpdater: Downloading %d updates...", results))
    dispatcher()
    AddTimer ("dispatcher", 0, 0, 1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "dispatcher")
    end
  end
        
    function FinishUpdate()
      for k, v in pairs(downloads) do
        Note(string.format("Downloaded: %s", k))
      end
    end
    --]]


]]>
</script>
</muclient>
