<?xml version="1.0" encoding="iso-8859-1"?>

<!DOCTYPE muclient>

<!-- Saved on Sunday, June 22, 2014, 9:02 PM -->

<!-- MuClient version 4.84 -->

<!-- Plugin "ATS_Navcomp" generated by Plugin Wizard -->

<muclient>

  <plugin name="ATS_Navcomp" author="mar'Qon@TrekMUSH"

  id="8e3fd4f9c269365839520477" language="Lua"

  purpose="Navcomp functions and other stuff for ATS TrekMUSH"

  save_state="y" date_written="2014-06-22 21:02:54" requires="4.84" 

  date_modified="2018-02-27 09:02"

  version="1.64">

    <description trim="y">

      <![CDATA[

Type 'atshelp'   for a list of commands.


Your download of this plugin should have came with atsdata.json,

it should be in your plugins directory, but if not, a dialog box will come up asking for it on the first load.

Mostly fully functional and bug-free. 



If you find problems, have ideas, or anything related to this plugin, you can find me on ATS TrekMUSH as mar'qon. (trekmush.org:1701)




]]>

</description>

  </plugin>

  <!--  Get our standard constants -->

  <include name="constants.lua" />

  <!--  Triggers  -->

  <triggers>

  

    <trigger enabled="y" group="ATSPlugin"

    match="^<[\w'_\d<>]+\|(?P<sname>[<>\w\s\d'_]+)>\s+Lost:\s+(?P<cname>[\w\d\s'_\-\(\)<>]+)\s+\((?P<cnum>[\d+]+)\)(?:\s<(?P<class>.+?)>)?\s+H:\s+(?P<yaw>[\d.]+)\s+(?P<pitch>[\d.]+)\s+S:\s+(?P<speed>[\w\d.]+)\s+R:\s(?P<range>[\[\]\w\d.]+)\s+@:\s+(?P<x>[\d.-]+)\s+(?P<y>[\d.-]+)\s+(?P<z>[\d+-.]+)$"

    name="BaseBotTrigger" send_to="12" sequence="100" regexp="y"

    script="fun_traceheading"

    >

 </trigger> 

   <trigger enabled="y" group="ATSPlugin"

    match="^<[\w'_\d<>]+\|(?P<sname>[<>\w\s\d'_]+)>\s+Lost:\s+(?P<cname>[\w\d\s'_\-\(\)]+)\s+\((?P<cnum>[\d+]+)\)(?:\s<(?P<class>.+?)>)?\s+H:\s+(?P<yaw>[\d.]+)\s+(?P<pitch>[\d.]+)\s+S:\s+(?P<speed>[\w\d.]+)\s+R:\s(?P<range>[\[\]\w\d.]+)\s+@:\s(?P<source>[\w\d<>\(\)\s]+)$"

    name="BaseBotTriggerSource" send_to="12" sequence="100" regexp="y"

    script="fun_traceheading"

    >

</trigger>

  <trigger

   enabled="y"

   group="ATSPlugin"

   keep_evaluating="y"

   match="^\s*Visibility:\s+.*%\s*Cochranes:\s([\d.]+)\s*$"

   name="HelmCochraneGrabber"

   regexp="y"

   script="update_helm_info"

   sequence="100"

  >

  </trigger>


  <trigger

   enabled="y"

   group="ATSPlugin"

   match="^&lt;[\w'_\d&lt;&gt;]+\|([&lt;&gt;\w\s\d'_]+)&gt;\s+Border\s(Inbound|Outbound)\s+at\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)$"

   name="BorderCrossing"

   regexp="y"

   script="fun_border_calc"

   sequence="100"

  >

  </trigger>

<trigger

   enabled="y"

   group="ATSPlugin"

   match="^&lt;[\w'_\d&lt;&gt;]+\|([&lt;&gt;\w\s\d'_]+)&gt;\s+(?:.+ says, \&quot;)Border\s(Inbound|Outbound)\s+at\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)&quot;$"

   name="BorderCrossingFed"

   regexp="y"

   script="fun_border_calc"

   sequence="100"

  >

  </trigger>

    <trigger enabled="y" group="ATSPlugin" keep_evaluating="y"

    match="^\s*Galactic X Y Z\:\s*([+-]?\d*\.\d+)(?![-+0-9\.])\s*([+-]?\d*\.\d+)(?![-+0-9\.])\s*([+-]?\d*\.\d+)(?![-+0-9\.])$"

    name="HelmXYZGrabber" regexp="y" send_to="12" sequence="100" script="update_helm_info">

          </trigger>

  <trigger

   enabled="y"

   group="ATSPlugin"

   match="^\[(?P<player>[\w'\s\d_-]+)\]--\[Firing\sat\s(?P<name>[\d\w\s\-<>()'_]+)\s\((?P<contact>\d+)\):\s(?P<firing>[BM:\-\d\s]+)\]$"

   omit_from_log="y"

   omit_from_output="y"

   name="StatsFiring"

   regexp="y"

   script="stats_handle_firing"

   sequence="100">   

   </trigger>

  <trigger

   enabled="y"

   group="ATSPlugin"

   match="^\[([\w\s']+)\s\((\d+)\)\shas\sbeen\sdisabled\]$"

   name="stats_handle_disabled"

   regexp="y"

   script="stats_handle_disable"

   sequence="100"

  >

  </trigger>


  <trigger

   enabled="y"

   group="ATSPlugin"

   match="^\[WARNING\]--\[([\w\d\s'\-<>()]+)\s\((\d+)\)\sfiring:\s(?P<firing>[BM:\-\d\s]+)\]$"

   name="stats_handle_firedon"

   regexp="y"

   omit_from_log="y"

   omit_from_output="y"

   script="stats_handle_firedon"

   sequence="100"

  >

  </trigger>


  <trigger

   enabled="y"

   match="^(?P<msrc>[\d#]+)\-(?P<mnum>\d+)\-(?P<mdest>[\d#]+)\s*(?P<mbonus>\d+)\s(?P<sname>.{14})\s+\>\s+(?P<dname>.{14})\s+(?P<range>\d+)\s+(?P<qty>\d+)x(?P<commod>\d+)\s+(?P<daysleft>\d+)\s(?P<timeleft>[\d:]+)$"

   name="MissionParserTrigger"

   regexp="y"

   send_to="14"

   omit_from_output="y"

   sequence="100"

   script="fun_parse_mission"

  >

    </trigger>

  <!-- match="^([0-9#-]+)\s+([0-9]+)\s+([A-Za-z0-9'\s]+)\s+&gt;\s+([A-za-z'\s*]+)(\d+)\s+(\d+)x(\d+)\s+(\d+)\s+([0-9:]+)$"

  <trigger

   enabled="y"

   omit_from_output="y"

   keep_evaluating="y"

   match="^&lt;([\w.\d&lt;&gt;()\-_']+)\|(?P&lt;source&gt;[\s\w.\d&lt;&gt;()\-_']+)&gt; Status: .+$"

   name="SpamControl"

   regexp="y"

   script="fun_status_spam"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="y"

   omit_from_output="y"

   keep_evaluating="y"

   match="^<([\w.\d<>()\-_']+)\|(?P<source>[\s\w.\d<>()\-_']+)> (?P<tractoror>[\s\w.\d<>()\-_']+) (?:[\d()]+) has locked tractor beams on (?P<tractoree>[\s\w.\d<>()\-_']+)\s(?:[\d()]+)"

   name="TractorTrigger"

   regexp="y"

   script="fun_status_spam"

   sequence="100"

  >

  </trigger> -->

  

  <trigger

   enabled="y"

   group="ATSPlugin"

   lines_to_match="12"

   match="^--\[Scanner Report\](?:-{61})\n\s+Name:(?P&lt;name&gt;[\w\s-_'&lt;&gt;()]+)Class:(?P&lt;class&gt;.+)\n(?:-{79})\nSystem\sName\s+Funct\sStatus\s+Specifics\n(?:[\-\s]{79})\nForward shield\s+(?P&lt;fore&gt;[\d%%-]+).*\nStarboard\sshield\s+(?P&lt;star&gt;[\d%%-]+).+\nAft\sshield\s+(?P&lt;aft&gt;[\d%%-]+).+\nPort\sshield\s+(?P&lt;port&gt;[\d%%-]+).+\nDorsal\sshield\s+(?P&lt;dorsal&gt;[\d%%-]+).+\nVentral\sshield\s+(?P&lt;ventral&gt;[\d%%-]+).+\n(?:-{79})$"

   multi_line="y"

   omit_from_output="y"

   regexp="y"

   name="ScanCondenser"

   script="fun_condense_scan"

   send_to="12"

   sequence="100"

  >

  </trigger>

<trigger

   enabled="y"

   group="ATSPlugin"

   lines_to_match="13"

   match="^--\[Scanner Report\](?:-{61})\n\s+Name:(?P&lt;name&gt;[\w\s-_'&lt;&gt;()]+)Class:(?P&lt;class&gt;.+)\n(?:-{79})\nSystem\sName\s+Funct\sStatus\s+Specifics\n(?:[\-\s]{79})\n(Cloaking Device.+\n)Forward shield\s+(?P&lt;fore&gt;[\d%%-]+).*\nStarboard\sshield\s+(?P&lt;star&gt;[\d%%-]+).+\nAft\sshield\s+(?P&lt;aft&gt;[\d%%-]+).+\nPort\sshield\s+(?P&lt;port&gt;[\d%%-]+).+\nDorsal\sshield\s+(?P&lt;dorsal&gt;[\d%%-]+).+\nVentral\sshield\s+(?P&lt;ventral&gt;[\d%%-]+).+\n(?:-{79})$"

   multi_line="y"

   omit_from_output="y"

   regexp="y"

   name="ScanCondenserwcloak"

   script="fun_condense_scan"

   send_to="12"

   sequence="100"

  >

  </trigger>


  <trigger

   enabled="y"

   group="ATSPlugin"

   match="^Wisdom\s+\d+\s+(?P<wisbonus>\d+)\s+increases Will, \+console skill, \+resist psionics$"

   name="WisdomGrabber"

   regexp="y"

   script="fun_set_wisdom"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="y"

   group="ATSPlugin"

   lines_to_match="5"

   match="^---\[Consoles\]------------------------------------------------------------------\nHelm\/Navigation\s+(?P&lt;helm&gt;\d+)\s+Tactical\/Weapons\s+(?P&lt;tact&gt;\d+)\s+\nEngineering\s+(?P&lt;eng&gt;\d+)\s+Operations\s+(?P&lt;oper&gt;\d+)\s+\nCommunications\s+\d+\s+Damage-Control\s+(?P&lt;damcon&gt;\d+)\s+\nSecurity\s+\d+\s+Science\s+(?P&lt;sci&gt;\d+).+$"

   multi_line="y"

   name="SetSkills"

   regexp="y"

   script="fun_set_skills"

   send_to="12"

   sequence="100"

  >

  </trigger>

<trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Class: .+ Crew: (?P<crew>\d+)\s+$"

   name="SpecClassTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Structure: (?P<structure>\d+)\s+Repair: (?P<repair>\d+)\s+Mass: (?P<mass>\d+)\s+$"

   name="SpecStructTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Firing: (?P<firing>\d+)\s+FuelEff: (?P<fueleff>\d+)\s+Stealth: (?P<stealth>\d+)\s+$"

   name="SpecFiringTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Cloak: (?P<cloak>\d+)\s+Sensors: (?P<sensors>\d+)\s+AuxMax: (?P<auxmax>\d+)\s+$"

   name="SpecCloakTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

   <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+MainMax: (?P<mainmax>\d+)\s+Armor: (?P<armor>\d+)\s+FuelMax: (?P<fuelmax>\d+)\s+$"

   name="SpecMainmaxTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Main: (?P<maingw>\d+)\s+Aux: (?P<auxgw>\d+)\s+Batt: (?P<battgw>\d+)\s+$"

   name="SpecMainTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+MoveRatio: (?P<mr>[\d.]+)\s+$"

   name="SpecMRTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+WarpCruise: (?P<wc>[\d.]+)\s+WarpEmer: (?P<we>[\d.]+)\s+WarpMax: (?P<wm>[\d.]+)\s+$"

   name="SpecWarpCruTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Cost: (?P<wcc>[\d.]+)\s+Cost: (?P<wec>[\d.]+)\s+Cost: (?P<wmc>[\d.]+)\s+$"

   name="SpecWarpCostTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+ImpCruise: (?P<ic>[\d.]+)\s+ImpEmer: (?P<ie>[\d.]+)\s+ImpMax: (?P<im>[\d.]+)\s+$"

   name="SpecImpCruTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Cost: (?P<icc>[\d.]+)\s+Cost: (?P<iec>[\d.]+)\s+Cost: (?P<imc>[\d.]+)\s+$"

   name="SpecImpCostTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+ShieldMax: (?P<sm>\d+)\s+ShieldRatio: (?P<sr>[\d.]+)\s+$"

   name="SpecShieldMaxTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s*1x Cost: (?P<sc1>[\d.]+)\s*2x Cost: (?P<sc2>[\d.]+)\s*3x Cost: (?P<sc3>[\d.]+)\s*4x Cost: (?P<sc4>[\d.]+)\s*$"

   name="SpecShieldCostTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Defense: (?P<d1>[\d.]+)\s+Defense: (?P<d2>[\d.]+)\s+Defense: (?P<d3>[\d.]+)\s+Defense: (?P<d4>[\d.]+)\s+$"

   name="SpecDefenseTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_specsheet"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Beams: (?P<beams>\d+)\s+DPS: (?P<beamdps>[\d.]+)\s+$"

   name="SpecBeamTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

 <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Cost: (?P<str>.+)$"

   name="SpecBeamCostTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{7}Range: (?P<str>.+)$"

   name="SpecBeamRangeTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Arcs: (?P<str>.+)$"

   name="SpecBeamArcsTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{6}Damage: (?P<str>.+)$"

   name="SpecBeamDamageTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Time: (?P<str>.+)$"

   name="SpecBeamTimeTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{9}DPS: (?P<str>.+)$"

   name="SpecBeamDPSTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_beams"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s+Missiles: (?P<missiles>\d+)\s+DPS: (?P<missiledps>[\d.]+)\s+$"

   name="SpecMissileTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

 <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Cost: (?P<str>.+)$"

   name="SpecMissileCostTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{7}Range: (?P<str>.+)$"

   name="SpecMissileRangeTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Arcs: (?P<str>.+)$"

   name="SpecMissileArcsTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{6}Damage: (?P<str>.+)$"

   name="SpecMissileDamageTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{8}Time: (?P<str>.+)$"

   name="SpecMissileTimeTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  <trigger

   enabled="n"

   group="ATSPlugin_SpecSheetGrabber"

   match="^\s{9}DPS: (?P<str>.+)$"

   name="SpecMissileDPSTrigger"

   omit_from_output="y"

   regexp="y"

   script="fun_grab_missiles"

   send_to="12"

   sequence="100"

  >

  </trigger>

  

</triggers>

  

  <!--  Aliases  -->

  <aliases>

    <alias name="ConvertFrame"

    match="^cf\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+from\s(\w+)\sto\s(\w+)$"

    enabled="y" group="ATSPlugin" regexp="y" send_to="12"

    ignore_case="y" sequence="100" script="fun_convertframe">

      

    </alias>

   <alias name="TraceHeading"

    match="^hcalc (?P<yaw>[\d.]+)\s(?P<pitch>[\d.-]+)\sfrom\s(?P<source>(?P<x>[\d.-]+)\s+(?P<y>[\d.-]+)\s+(?P<z>[\d.-]+)|.+?)(?P<at>\sat\s(?P<speed>[\d.-]+?)?)?$" 

    enabled="y"

    group="ATSPlugin" regexp="y" send_to="12" ignore_case="y"

    sequence="100" 

    script="fun_traceheading" 

    > 

    </alias>


    <alias

   name="objsnear_obj"

   script="fun_objsnear"

   match="^(objsnear|near)\s+(?P<source>[\w\s'_<>\d]+)\s+at\s+(?P<range>[\d.]+)$"

   enabled="y"

   group="ATSPlugin"

   regexp="y"

   sequence="100"

  >

  </alias>

<alias

   name="autochecktoggle"

   script="version_disabled"

   match="^ncupdate(\snow)?$"

   regexp="y"

   enabled="y"

   group="ATSPlugin"

   sequence="100"

  >

  </alias>


    <alias

   name="ansi_toggle"

   script="fun_toggle_ansi"

   match="^ncansi$"

   enabled="y"

   group="ATSPlugin"

   regexp="y"

   ignore_case="y"

   sequence="100"

  >

  </alias>

 <alias

   name="debug_toggle"

   script="fun_toggle_debug"

   match="^ncdebug$"

   enabled="y"

   group="ATSPlugin"

   regexp="y"

   ignore_case="y"

   sequence="100"

  >

  </alias>

  <alias

   name="objsnear_xyz"

   script="fun_objsnear"

   match="^(objsnear|near)\s+(?P<x>[\d.-]+)\s+(?P<y>[\d.-]+)\s+(?P<z>[\d.-]+)\s+at\s+(?P<range>[\d.-]+)"

   enabled="y"

   group="ATSPlugin"

   regexp="y"

   sequence="100"

  >

  </alias>

  <alias

   name="Condense_Toggle"

   script="fun_toggle_condense"

   match="^nccondense (combat|scan)$"

   enabled="y"

   regexp="y"

   group="ATSPlugin"

   send_to="12"

   sequence="100"

  >  

   </alias>

  <alias

   name="parse_Toggle"

   script="fun_toggle_missionparser"

   match="^ncparse$"

   enabled="y"

   regexp="y"

   group="ATSPlugin"

   send_to="12"

   sequence="100"

  >  

  </alias>

      <alias name="Fromto" match="^fromto ([\w'_\s\d]+)\sto\s([\w'_\s\d]+)\sat\s+([\d.]+)$" enabled="y"

    group="ATSPlugin" send_to="12" ignore_case="y" sequence="100" regexp="y" script="fun_fromto">

      

    </alias>

	<alias name="plot" match="^(?:plot|from) (.+)\sto\s(.+?)(\sat\s+(?P<speed>[\d.]+?))?(\savoid\s+(?P<border>[\w.]+?))?$" enabled="y"

    group="ATSPlugin" send_to="12" ignore_case="y" sequence="100" regexp="y" script="fun_best_route">

      

    </alias>

    <alias name="PlotIntercept" 

    match="^pi\s([\w\d'_\s]+)\sto\s([\w\d'_\s]+)\sat\s([\d.]+)\sand\s([\w\d\s'_]+)\sat\s([\d.]+)\s*([\d]*)$" 

    enabled="y"  group="ATSPlugin" send_to="12" ignore_case="y" 

    sequence="100" regexp="y" script="fun_intercept">

    </alias>

	<alias name="PlotInterceptHelp" 

    match="^pi help$" 

    enabled="y"  group="ATSPlugin" send_to="12" ignore_case="y" 

    sequence="100" regexp="y" script="fun_intercept_help">

    </alias>

    <alias name="atshelp" match="^(?:atshelp|navhelp|nchelp)(\stest)?$" enabled="y" regexp="y"

    group="ATSPlugin" send_to="12" ignore_case="y" sequence="100" script="fun_atshelp">

      

    </alias>

    <alias name="ncframe" match="^(?:setframe|ncframe) (\w+)$" enabled="y" regexp="y"

    group="ATSPlugin" send_to="12" ignore_case="y" sequence="100"

    script="fun_setframe" > 

    </alias>

  <alias

   name="stats_showdata"

   script="stats_showdata"

   match="^spacestats\s*(\w*)$"

   regexp="y"

   enabled="y"

   group="ATSPlugin"

   send_to="12"

   sequence="100"

  >

  </alias>


  <alias

   script="fun_resetdb"

   match="ncresetdb"

   enabled="y"

   group="ATSPlugin"

   send_to="12"

   sequence="100"

  >

  </alias>


  <alias

   name="cmd_project1"

   script="fun_project"

   match="^proj\s+([\d+-+.]+)\s+([\d+-.]+)\s+from\s([\w\d.-_'\s&lt;&gt;]+)\sto\s([\d.]+)$"

   enabled="y"

   group="ATSPlugins"

   regexp="y"

   sequence="100"

  >

  </alias>


  <alias

   enabled="y"

   group="ATSPlugin"

   match="^avoid (.*?) from (.*?) to (.*?)$"

   name="border_avoid"

   regexp="y"

   script="fun_border_avoid"

   sequence="100"

  >

  </alias>

 <alias

   name="viewinfo"

   enabled="y"

   group="ATSPlugin"

   match="^ncinfo (.+)$"

   script="fun_empire_info"

   regexp="y"

   sequence="100"

  >

  </alias>


  </aliases>

  

  <!--  Script  -->

  <script>

    <![CDATA[
--[[

-- I created this plugin exclusively for use with ATS TrekMUSH at ats.trekmush.org:1701. http://www.trekmush.org/
-- Some of this code is based, entirely or partially, on code from Atuarre's ASpace 1.0 which is available at https://code.google.com/p/aspace-sim/
-- Some code is based on snippets available from the internet (e.g. plotintercept()) and is credited as such.
--
-- The entirety of this plugin is copyrighted to me. I give permission to make changes as you see fit for personal use, as long as you share
-- changes that could be useful to others to me for possible inclusion in future versions, however, no one has permission to distribute this
-- plugin other than myself. If you got this plugin from anywhere but my personal website at http://qon.pennmush.org/, you have an unauthorized copy.
--]]


-- Initialize our tables
local space_objs = { }
local borders = {}
local border_objs = { }

stats = { dmgIn = 0, dmgOut = 0, hits = 0, misses = 0, kills = 0, ships = {}, in_combat = false, combatwith = {} }
kill_list = { }
skill_info = { wisdom = 0, helm = 0, eng = 0, tact = 0, oper = 0, damcon = 0, sci = 0, ecalc = 0, hcalc = 0, tcalc = 0, ocalc = 0, dcalc = 0, scalc = 0 }
spec_info = { mainmax = 0, auxmax = 0, maingw = 0, auxgw = 0, structure = 0, repair = 0, mr = 0, wc = 0, we = 0, wm = 0, wcc = 0, wec = 0, wmc = 0, ic = 0, ie = 0, im = 0, icc = 0, iec = 0, imc = 0, sm = 0, sc1 = 0, sc2 = 0, sc3 = 0, sc4 = 0, beams = {}, torps = {}, battgw = 0, firing = 0, fueleff = 0, stealth = 0, cloak = 0, sensors = 0, armor = 0, fuelmax = 0, twc = 0, twe = 0, twm = 0, tmw = 0, beamqty = 0, beamdps = 0, beamstdps = 0, beamscounted = 0, missilestdps = 0, missilescounted = 0 }

local frame = { ["name"] = "GRC", ["x"] = 0, ["y"] = 0, ["z"] = 0 }
local status_table = { }
local tractor_table = { }

-- Configuration table
local config_table = {
    debugmode = false, -- Sends extra debugging info to client screen
    auto_check = true, -- Whether we check for updates automatically or not -- Deprecated
    condense_combat = false, -- Condenses weapon firing  (Accessibility)
    missionparser = false, -- Adds (R) and (P) to market info screens. (Accessibility)
    db_version = 0, -- Loaded Databaseversion. So we can check remote DB version and pull updates
    ansi_color = true,  -- Use color or not (Accessibility)
    condense_scan = false, -- Prints a condensed scan report after you do a scan
    filter_spam4 = true,
  }
  
local fbc = nil
local PI            = 3.1415926535898
local PARSEC        = 3085659622.014257
local LIGHTSPEED    = 29.979246
local COCHRANE      = 1298.737508
local DATAFILE      = "atsdata.json" -- This file must be in the MUSHClient\worlds\plugins directory.
local CUST_DATAFILE = "atscustom.csv" -- If exists, adds this data to the end of the data structure. -- Deprecated
local VERSION_URL   = "http://qon.pennmush.org/ats/beta/versioninfo.lua" 
local DB_URL        = "http://qon.pennmush.org/ats/beta/atsdata.csv"
local DOWNLOAD_URL  = "http://qon.pennmush.org/mediawiki/index.php/ATS_Nav_Comp_Plugin"
local JSON_URL      = "http://qon.pennmush.org/ats/beta/atsdata.json"
-- Function overrides
local _ANSI = ANSI
mySimulate = function(t) Simulate(t .. ANSI(0,22) .. "\n") end
local ANSI = function (...) if (config_table.ansi_color) then return _ANSI(...) else return "" end end

require "serialize"


function Debug(t, ...)
  if not config_table.debugmode or not t then 
    return 
  end
  Note("DEBUG: " .. string.format(t,...))
end

function file_exists(name)
  
  local f = io.open(name,"r")
  if ( f~= nil) 
    then io.close(f)
      return true
    else
      return false
    end
end

-- From the Programming in LUA handbook
-- http://www.lua.org/pil/20.4.html
-- Edited to auto convert numbers into numbers, rather than strings, and to ignore whitespace.
-- Deprecated 6/29/15. See load_json() Instead
local function fromCSV (s)
  s = s .. ','        -- ending comma
  local t = {}        -- table to collect fields
  local fieldstart = 1
  
  repeat -- next field is quoted? (start with `"'?)
    if string.find(s, '^"', fieldstart) then
      local a, c
      local i  = fieldstart

      repeat -- find closing quote
        a, i, c = string.find(s, '"("?)', i+1)
        until c ~= '"'    -- quote not followed by quote?
        if not i then error('unmatched "') end
          local f = trim(string.sub(s, fieldstart+1, i-1))
          local tmp = trim(string.gsub(f, '""', '"'))
          t[#t+1] = tonumber(tmp) or tmp
          fieldstart = string.find(s, ',', i) + 1
        else                -- unquoted; find next comma
          local nexti = string.find(s, ',', fieldstart)
          local tmp = trim(string.sub(s, fieldstart, nexti-1))
          t[#t+1] = tonumber(tmp) or tmp
          fieldstart = nexti + 1
        end
      until fieldstart > string.len(s)
    return t
end

--[[ ParseTable()
--  Parses given table into our SpaceObjects database.
-- Much faster than previous version
-- Deprecated 6/29/15. See load_json() Instead
--]]
local function ParseTable(t)
  if not t then return end
   assert(type(t[1]) == "number", "ParseTable(): Type is not a number")
   
  if (t[1] == 0) then -- Empires
    if (#t < 6) then
        ColourNote("red", "", "ParseTable(): Border is missing required parameters: ")
        for i = 1, #t do
          ColourTell("white", "", tostring(t[i]) .. ",")
        end
        AnsiNote(" (Skipped)")
        return
      end  
    if (config_table.debugmode) then
      assert(type(t[3]) == "number", "ParseTable():Border X is not a number: " .. t[3])
      assert(type(t[4]) == "number", "ParseTable():Border Y is not a number: " .. t[4])
      assert(type(t[5]) == "number", "ParseTable():Border Z is not a number: " .. t[5])
      assert(type(t[6]) == "number", "ParseTable():Border radius is not a number:" .. t[6])
    end
    
    space_objs[#space_objs+1] = { 
      ["type"] = t[1], 
      empire = t[2],
      name = borders[t[2]] or "CU",
      x = t[3],
      y = t[4],
      z = t[5],
      radius = t[6]
      }
  elseif (t[1] == 3) then -- Border names
    assert(type(t[2]) == "number", "ParseTable(): Empire # is not a number" .. t[2])
    if (t[2] ~= 0 ) then
      borders[t[2]] = t[3] 
    end
  elseif (t[1] == 99) then -- Hack for loading the DB version
    config_table.db_version = t[2]
  elseif (t[1] == 4) then -- Hack for loading unofficial borders
    if (#t < 6) then
      ColourNote("red", "", "ParseTable(): Border is missing required parameters:")
      for i = 1, #t do
        ColourTell("white", "", tostring(t[i]) .. ",")
      end
      AnsiNote("", " (Skipping)")
    end
    space_objs[#space_objs+1] = 
    {
      ["type"] = 5,
      empire = t[2],
      name = t[3],
      x = t[4],
      y = t[5],
      z = t[6],
      radius = t[7] 
    }
    
  else -- Everything else
    if (#t < 6) then
        ColourNote("red", "", "ParseTable(): SO is missing required parameters: ")
        for i = 1, #t do
          ColourTell("white", "", tostring(t[i]) .. ",")
        end
        AnsiNote(" (Skipping)")
        return
      end  
    if (config_table.debugmode) then
      assert(type(t[2]) == "number", "ParseTable():SO Owner is not a number: " .. t[3])
      assert(type(t[4]) == "number", "ParseTable():SO X is not a number: " .. t[3])
      assert(type(t[5]) == "number", "ParseTable():SO Y is not a number: " .. t[3])
      assert(type(t[6]) == "number", "ParseTable():SO Z is not a number: " .. t[3])
    end
    
    space_objs[#space_objs+1] = {
      ["type"] = t[1],
      empire = t[2],
      name = t[3],
      x = t[4],
      y = t[5],
      z = t[6],
      cochranes = tonumber(t[7]) or COCHRANE,
    }
  end
end

-- Loads data.txt into our space_objs[] structure.
-- You can safely use the same data.txt from mapview
-- But we ignore empire assignments and colors, obviously, since we don't have an actual map view. :)
-- Deprecated 6/29/15. See load_json() Instead
function loadData(reload)
  local i = 1
  local t = { }
  local file = GetVariable("ATSDATAFILE")
  

  if (not io or not io.open) then
    Note("LUA Sandboxing is enabled. You must disable this for ATS_Navcomp to work.")
    Note("See: http://gammon.com.au/security for instructions.")
    return
  end
  
  if (not file) then
    local info = utils.info()
    file = info["plugins_directory"] .. DATAFILE
  end 
  
  if( not file_exists(file)) then -- File doesn't exist, bring up a file choose dialog.
    file = utils.filepicker ("ATS_Navcomp DataFile", DATAFILE, ".csv", { csv = "CSV files", ["*"] = "All files" }, false)
    if (file_exists(file or "")) then -- If it's a good file, save the location so we don't go through this each time.
      SetVariable("ATSDATAFILE", file)
    else -- All down hill from here
      Note("Database not found. Functions WILL NOT WORK.")
    return
    end
  end
  if (reload) then
    for i =1, #space_objs do
      space_objs[i] = nil
    end
    space_objs = { }
    ColourNote("yellow", "", "ATSNavcomp Reloading Database.")
  end
  
  local starttime = GetInfo (232)
  for line in io.lines(file) do  
    if (string.sub(line,1,1) == "#" or string.len(line) <= 1 ) then -- Skips comments, and blank lines
    else
      ParseTable(fromCSV(line))
      i = i+1
    end
  end
  local endtime = GetInfo (232)
  Debug("Loaded %d objects in %f seconds", i-1, endtime - starttime)
  
  i = 1
  if (file_exists(CUST_DATAFILE)) then
    Debug("Loading additional data from " .. CUST_DATAFILE)
    for line in io.lines(CUST_DATAFILE) do  
      if (string.sub(line,1,1) == "#" or string.len(line) <= 1 ) then -- Skips comments, and blank lines
      else
        t = fromCSV(line)
        ParseTable(t)
        i = i+1
      end
    end
    Debug("Loaded %d custom objects.", i-1)
  end
end

  
--[[
-- xybearing(x, y) -- Returns yaw
-- Converts XY coordinates into a bearing (yaw)
-- This is directly converted from aspace\space_utils.c
-- All credit to original author, Atuare @ TrekMUSH
--]]

function xy2bearing(x, y)
  local atan = math.atan
  assert(x, "X is nil")
  assert(y, "y is nil")
  
  if (y == 0.0) then
    if (x == 0.0) then
      return 0.0
    elseif (x > 0.0) then
      return 0.0
    else
      return 180.0
    end
  elseif (x == 0.0) then
    if (y > 0.0) then
      return 90.0
    else
      return 270.0
    end
  elseif (x > 0.0) then
    if (y > 0.0) then
      return atan(y / x) * 180 / PI
    else
      return atan(y / x) * 180.0 / PI + 360.0
    end
  elseif (x < 0.0) then
    return atan (y /x) * 180.0 / PI + 180.0
  else
    Debug("xyz2bearing: "..x.. " / "..y)
  return 0.0
  end
end

--[[
-- xyz2elevation(x,y,z) returns Pitch
-- Converts XYZ into elevation (pitch)
-- This is directly converted from aspace\space_utils.c
-- All credit to original author, Atuare @ TrekMUSH
--]]

function xyz2elevation(x, y, z)
  local sqrt = math.sqrt
  local atan = math.atan
  local r = sqrt(x * x + y * y)
  
  if (r == 0.0) then
    if (z == 0.0) then
      return 0.0
    elseif (z > 0.0) then
      return 90.0
    else
      return 270.0
    end
  elseif (z > 0.0) then
    return atan(z / r) * 180.0 / PI
  elseif (z < 0.0) then
    return atan(z / r) * 180.0 / PI + 360
  else
    return 0.0
  end
end

--[[
-- xyz2range(xa,ya,za,xb,yb,zb) returns range from two XYZ coordinates
-- This is directly converted from aspace\space_utils.c
-- All credit to original author, Atuare @ TrekMUSH
--]]
function xyz2range(xa, ya, za, xb, yb, zb)
        local sqrt = math.sqrt
        assert(xa, "xyz2range(): xa is nil")
        assert(ya, "xyz2range(): ya is nil")
        assert(za, "xyz2range(): za is nil")
        assert(xb, "xyz2range(): xb is nil")
        assert(yb, "xyz2range(): yb is nil")
        assert(zb, "xyz2range(): zb is nil")
        
        local x = xb - xa
        local y = yb - ya
        local z = zb - za
        return sqrt(x * x + y*y + z * z)
end

--[[
-- findplanetbyname(name) returns index to space_objs[] that matches the given name, nil otherwise
-- A little misleading -- This will return any planet or base with that name.
--]]
function findplanetbyname(name)
  
  if (not name) then
    Debug("FPBN: Passed nil name")
    return
  end
  name = trim(name)  
  local i = 1
  while (space_objs[i])  do
    if(space_objs[i].type == 1 or space_objs[i].type == 2) then
      if (string.match(string.upper(space_objs[i].name),string.upper(name))) then
        return i
      end
    end
    i = i+1
  end
    -- If we get here, we didn't find anything, return nil
  Debug("FPBN(): We found nothing: %s", name)
  return nil
end


function fun_traceheading(name, _, wildcards)
  local base_to_frame = { ["USB"] = "UFP", ["IKB"] = "KLI", ["FSB"] = "GFA", ["AST"]  = "GFA"}
  local t = -1
  local speed = 14.0
  
  if (wildcards.speed and (wildcards.speed:len() > 0) )then
    speed = tonumber(wildcards.speed)
  end

  if(name == "BaseBotTrigger" or name == "BaseBotTriggerSource") then -- Handle BaseBots differently
    
    local source = { }
    local fname = base_to_frame[string.sub(wildcards.sname, 1, 3)]
    local range, parsec = string.gsub(wildcards.range, "[%[%]]", "")
    local sRef = findplanetbyname(wildcards.sname)
      
    if (wildcards.x and wildcards.y and wildcards.z ) then
      Debug("TH: Trying to calculate based on XYZ: %.3f/%.3f/%.3f", wildcards.x, wildcards.y, wildcards.z)
      if (sRef and sRef > 0 and (tonumber(range) > 0.0) and not fname) then
        fname = findframe(wildcards.x, wildcards.y, wildcards.z, sRef, tonumber(range))
      end
      
      source = { x = tonumber(wildcards.x or -1), y = tonumber(wildcards.y or -1), z = tonumber(wildcards.z or -1), frame = fname, source = wildcards.sname, range = 0 }
    else
      local sRef = findplanetbyname(wildcards.source)
      if (not sRef) then
        Debug("Source not found")
        return
      end
      source = { x = space_objs[sRef].x, y = space_objs[sRef].y, z = space_objs[sRef].z, frame = fname, source = wildcards.sname, range = 0 }
    end

    if (parsec > 0) then
      source.range = tonumber(range)
    else
      source.range = 0
    end
    
    if (fname) then
      source.frame = fname
    else
      source.frame = nil
    end
     local t = newtraceheading(wildcards.yaw, wildcards.pitch, source, wildcards.speed, false)
     if ( tonumber(t)) then
        if(tonumber(t) == 0) then
          Debug("Source location not found in database. Please send full base name and GRC Coordinates, or planet name where this base is located to Qon@TrekMUSH.")
        elseif (tonumber(t) == -1) then
          Debug("Destination not found.")
        end
        
      return  
    else
      local name = tostring(wildcards[2])
      if(name == "contact") then
        name = "Unknown"
      elseif (name == "(cloaked)") then
        name = "Cloaked"
      end
      local chatgrabber = IsPluginInstalled("de6b99ef3f79191fd27d59b0")
      local tmp = ""
      if (not config_table.debugmode and not chatgrabber) then
        tmp = "\n"
      end
      mySimulate(string.format("%s%s%s (%d) (%s->)%s%s", tmp, ANSI(1,33), name, tonumber(wildcards[3]), wildcards.sname or "", ANSI(1,37), t))
      return
    end
  end
  
    if (wildcards.x and wildcards.x:len() > 0 and wildcards.y and wildcards.y:len() > 0 and wildcards.z and wildcards.z:len() > 0) then
      t = traceheading_from_coords(tonumber(wildcards.yaw), tonumber(wildcards.pitch), tonumber(wildcards.x), tonumber(wildcards.y), tonumber(wildcards.z), speed)
  else
      t = newtraceheading(wildcards.yaw, wildcards.pitch, wildcards.source, speed, false)
  end
  
  if (tonumber(t)) then
    local errorString = "Some funky error happened. Report this."
    if (t == -1) then
      errorString = "Destination not found. " 
    elseif (t == -2) then -- We really should never get here. But who knows?
      errorString = "fun_traceheading(): Ignoring object with no speed."
    elseif (t == 0 ) then
      errorString = "Couldn't find source in the database. Check your spelling."
    end
    Debug(errorString)
    return
  end
    -- If we got this far, we should be good to go.
    mySimulate(t)
  end
    
  
--[[
-- Traces a course from source, along yaw & pitch, at (speed), iterates through all planets/bases, and returns possible destinations.
-- Returns 0 if it can't find the source,
-- Returns -1 if it can't find any possible destinations
--]]
function newtraceheading(yaw, pitch, source, speed)
  local RANGE = 1 -- Range to check for intersections. If we got exact headings this would not be needed, but we don't, and it is.
  local px, py, pz = 0, 0, 0
  local sx, sy, sz = 0, 0, 0
  local fname = nil
  local spd = 0
  local srcid = nil 
  local results = { }
  
  if not yaw or not pitch or not source or not speed then return -1 end
  
  if (type(speed) == "string") then
    if (speed:find("i") or speed:find("None")) then -- If ship is at impulse or not moving, silently return
      return -2
    else
      spd = tonumber(speed:gsub("[iw]","") or 14.0) -- Remove the "w" or "i" from speed if captured from a base bot
    end
  else
    spd = speed
  end
  
  if (type(source) == "table") then --Table means we got XYZ coords, lets make sure look right
    Debug("NTH: Received a table source: %.3f/%.3f/%.3f @ %s", source.x, source.y, source.z, source.source)
    srcid = findplanetbyname(source.source)
    local r = 0
    if (source.frame and srcid ~=nil) then 
      sx, sy, sz = frame_to_grc(source.x, source.y, source.z, source.frame) -- Convert it to GRC using source.frame as a reference
      r = xyz2range(X(srcid), Y(srcid), Z(srcid), sx, sy, sz)  
      Debug("NTH(): Testing by frame: %s at %.3f %.3f %.3f", source.frame, sx, sy, sz)
    elseif(srcid ~=nil and not source.frame) then -- We couldn't find a frame, so let's just use the sourcename
      sx, sy, sz = X(srcid), Y(srcid), Z(srcid)
    elseif(not srcid and source.frame) then
      sx, sy, sz = frame_to_grc(source.x, source.y, source.z, source.frame) 
      Note("NTH(): Source not found in DB, attempting to use XYZ.")
    else
      Debug("NTH(): We shouldn't reach here. Error")
      return 0
    end
    
    if (r >0 and math.abs(r - source.range) > 1) then -- This should be less than 1 if the frame is valid
      Debug("NTH(): Frame looks invalid. Trying to find proper frame...")
      fname, sx, sy, sz = findframe(source.x, source.y, source.z, srcid, source.range)
      if (not fname) then
        Debug("NTH(): Still couldn't find frame, using source XYZ instead.")
        sx, sy, sz = X(srcid), Y(srcid), Z(srcid)
      end
      
    end
  else
    srcid = findplanetbyname(tostring(source)) -- Index #, use space_objs[srcid] to reference table
    if (not srcid) then
      return 0
    end
    sx, sy, sz = X(srcid), Y(srcid), Z(srcid)
  end
  
  -- Project a destination 1000PC from source, following the given course
  px, py, pz = projectheading(yaw, pitch, 1200)
  px = px + sx
  py = py + sy
  pz = pz + sz
  
  local i = 1
  while ( space_objs[i] ) do 
  if (space_objs[i].type == 1 or space_objs[i].type == 2 and i ~= srcid) then
    local dx, dy, dz = space_objs[i].x, space_objs[i].y, space_objs[i].z
    local rng = xyz2range(sx,sy,sz,dx,dy,dz)
    if (rng > 1) then  -- This is so we don't hit nearnearby space objs..e.g a moon or spacestation
      local p = {}
      p = intersection(sx, sy, sz, px, py, pz, dx, dy, dz, RANGE)
      if (p.intersections > 0) then -- Possible match.. save it.
        Debug("NTH() Possible match: %s (%fd) ",space_objs[i].name, p.id1 / p.r1 )
        p.name = space_objs[i].name
        p.type = space_objs[i].type
        p.eta = spd and get_eta(sx, sy, sz, p.x1, p.y1, p.z1, spd, C(i), C(srcid)) or nil
        p.time = spd and xyz2range(sx,sy,sz,p.x1,p.y1,p.z1) / Velocity(spd,C(i), C(srcid)) or nil
        p.deviation = p.id1 or 1 / p.r1 or 1
        results[#results+1] = p
      end
    end
  end
  i = i+1
  if (i > #space_objs and #results < 1 and RANGE < 12) then
      i = 1
      Debug("NTH() Not found with range %d, increasing to %d", RANGE, (RANGE+2))
      RANGE = RANGE + 2
    end
  end
  
  if (#results > 0) then
    Debug("NTH: %d results found", #results)
    local closestmatch = { }
    
    table.sort(results, function(a,b) return ((a.id1 / a.r1) < (b.id1 / b.r1)) end) -- Sort closest to furthest 
    
    if (#results > 1 and (math.abs(results[1].deviation - results[2].deviation)) < 0.001 and results[1]["type"] ~= 2) then
      closestmatch = results[2]
    else
      closestmatch = results[1]
    end
    
    if (closestmatch) then
      local arrival = closestmatch.time and os.date("%I:%M%p", os.time() + closestmatch.time) or ""
      local deviation = nil
      if (closestmatch.id1 / closestmatch.r1 < 0.027) then
        deviation = string.format(" %s(%.3fd)%s ", ANSI(1,32), (closestmatch.id1 / closestmatch.r1), ANSI(1,37))
      else
        deviation = string.format(" %s(%.3fd)%s ", ANSI(31,1), (closestmatch.id1 / closestmatch.r1) , ANSI(1,37))
      end
      return string.format("%s%s [%.3f]%s%s%s %s%s @ w%.3f", ANSI(1,32), closestmatch.name, closestmatch.r1, ANSI(1,37), deviation, closestmatch.eta or "ETA N/A", arrival or "",
        (closestmatch.id1 / closestmatch.r1) > 0.07 and "\r\nNote: Deviation indicates this may be inaccurate." or "", spd)
    else
      return -1
    end
    else -- if (#results >0)
      return -1 -- No results
    end
end -- function()


--[[
-- get_eta(x1,y1,z1,x2,y2,z2,speed) Based on two given coordinates at warp (speed), estimate ETA.
-- This is NOT perfect, it's a ballpark estimate.. becuase we have no way to calculate exact cochranes, we use the average universal cochrane of 1298.737508
-- This function is/was heavily based on code from aspace\space_set.c. Specifically the do_set_eta function.
-- All credit goes to Atuarre @ TrekMUSH for it.
--]]
function get_eta(x1,y1,z1,x2,y2,z2,speed, c1, c2)
  local sqrt = math.sqrt

  local dx = x2 - x1
  local dy = y2 - y1
  local dz = z2 - z1
  
  if  (speed < 1.0) then
    return "ETA: Speed too low to calculate."
  else 
    speed = Velocity(speed, c1 or nil, c2 or nil)
  end
  
  return timestring((sqrt(dx * dx + dy * dy + dz * dz) / speed ))
end
--[[
-- xyheading(x1,y1,z1,x2,y2,z2) returns yaw and pitch to get from X1 to X2
-- Use like: yaw, pitch = xyheading(x,y,z,x,y,z)
-- Simple extension of xy2bearing(0 and xy2elevation()
- Rounds output down to 3 decimal places
--]]
function xyzheading(x1,y1,z1,x2,y2,z2) -- X1 is source, X2 is dest
        local x = x2 - x1
        local y = y2 - y1
        local z = z2 - z1
        return round(xy2bearing(x,y),3), round(xyz2elevation(x,y,z))
end

-- Rounds to (idp) decimal places
function round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end
        
-- trim whitespace from both ends of string
--[[function trim(s)
        return s:find'^%s*$' and '' or s:match'^%s*(.*%S)'
end
--]]
function trim(s)
 local from = s:match"^%s*()"
 return from > #s and "" or s:match(".*%S", from)
end


-- Simple function returns square of x
function square(x)
        return (x * x)
end

--[[ intersection(x1,y1,z1,x2,y2,z2,x3,y3,z3,r)
        Where XYZ1 is Source
        XYZ2 is Destination
        XYZ3 is center of a sphere of radius (r)
        Returns a table with intersections (0,1, or 2) and intersection points.
        
        {table}.intersections -- Number of intersections, 0, 1 or 2
        {table}.x1,, y1, z1 -- Coordinates of first intersction
        {table}.r1 -- Range from source to intersection
        {table}.x2, y2, z2 -- Coordinats of second intersection
        {table}.r2 -- Range from source to intersection
        
        Requires square function
        function square(x) 
                return x*x 
        end
        See credit below. I only converted this to work with LUA, I did not wite it.
        
        '***FULL CREDIT TO PAUL BOURKE AND IEBELE ABEL FOR THIS SOLUTION***
        http://paulbourke.net/geometry/circlesphere/source.cpp
-- 
--]]                                     
  
  function intersection(x1, y1, z1, x2, y2, z2, x3, y3, z3, r)
    local sqrt = math.sqrt
    local p = {}
    p.intersections = 0
    local a =  square(x2 - x1) + square(y2 - y1) + square(z2 - z1)
    local b =  2* ( (x2 - x1)*(x1 - x3)  + (y2 - y1)*(y1 - y3) + (z2 - z1)*(z1 - z3) ) 
    local c =  square(x3) + square(y3) +  square(z3) + square(x1) +  square(y1) + square(z1) - 2* ( x3*x1 + y3*y1 + z3*z1 ) - square(r) 
    local i =  b * b - 4 * a * c 
    local mu1 = (-b + sqrt(i)) / (2 *a )
    local mu2 = (-b - sqrt(i)) / (2 *a )
    if (r <= 0) then 
      return p
    end
    
    -- If either mu1 or mu2 is < 0.0 or > 1.0, they are outside of our line segment. 
    if (mu1 < 0.0 or mu1 > 1.0) then
        mu1 = nil
    end
    if (mu2 < 0.0 or mu2 > 1.0) then
      mu2 = nil
    end
    if (not mu2 and not mu1 and i <0.0) then
      return p
    end
        
    if (i <0.0) then
       p.intersections = 0
       return p
    elseif( i == 0.0) then
       local mu = -b/(2*a) 
       p.intersections = 1
       p.x1 = x1 + mu*(x2- x1)
       p.y1 = y1 + mu*(y2 - y1)
       p.z1 = z1 + mu*(z2 - z1)
       p.r1 = xyz2range(x1, y1, z1, p.x1, p.y1, p.z1)
       
       p.id1 = xyz2range(p.x1, p.y1, p.z1, x3, y3, z3) 
       -- Add just a -hair- more, to see if we are entering or exiting a border.
       local ix, iy, iz = normalize(x2 - x1, y2 - y1, z2 - z1)
       
       ix = p.x1 + 2*ix
       iy = p.y1 + 2*iy
       iz = p.z1 + 2*iz
       p.inside1 = (xyz2range(ix, iy, iz, x3, y3, z3) < r)
       --p.id1 = xyz2range(ix, iy, iz, x3, y3, z3)
       return p
    
     elseif (i > 0.0 ) then
       if (mu1 and mu2) then -- Two intersections, return both
        p.intersections = 2
        p.x1 = x1 + mu1*(x2 - x1)
        p.y1 = y1 + mu1*(y2 - y1)
        p.z1 = z1 + mu1*(z2 - z1)
        p.r1 = xyz2range(x1, y1, z1, p.x1, p.y1, p.z1) -- Distance from Starting point to intersection point
        p.id1 = xyz2range(p.x1, p.y1, p.z1, x3, y3, z3) 
        local ix, iy, iz = normalize(x2 - x1, y2 - y1, z2 - z1)
       
        ix = p.x1 + 2*ix
        iy = p.y1 + 2*iy
        iz = p.z1 + 2*iz
        p.inside1 = (xyz2range(ix, iy, iz, x3, y3, z3) < r)
        --p.id1 = xyz2range(ix, iy, iz, x3, y3, z3) 
        
        p.x2 = x1 + mu2*(x2- x1)
        p.y2 = y1 + mu2*(y2 - y1)
        p.z2 = z1 + mu2*(z2 - z1)
        p.r2 = xyz2range(x1, y1, z1, p.x2, p.y2, p.z2)
        
        
        ix, iy, iz = normalize(x2 - x1, y2 - y1, z2 - z1)
        
        ix = p.x2 + 2*ix
        iy = p.y2 + 2*iy
        iz = p.z2 + 2*iz
        p.id2 = xyz2range(ix, iy, iz, x3, y3, z3) 
        p.inside2 = (xyz2range(ix, iy, iz, x3, y3, z3) < r)
        return p
        elseif (not mu1 and not mu2) then --Nothing is valid
        p.intersections = 0
        return p
      else 
        local mu = mu1 or mu2
        p.intersections = 1
        p.x1 = x1 + mu*(x2- x1)
        p.y1 = y1 + mu*(y2 - y1)
        p.z1 = z1 + mu*(z2 - z1)
        p.r1 = xyz2range(x1, y1, z1, p.x1, p.y1, p.z1)
        p.id1 = xyz2range(p.x1, p.y1, p.z1, x3, y3, z3)                
        local ix, iy, iz = normalize(x2 - x1, y2 - y1, z2 - z1)
        
        ix = p.x1 + 2*ix
        iy = p.y1 + 2*iy
        iz = p.z1 + 2*iz
        p.inside1 = (xyz2range(ix, iy, iz, x3, y3, z3) < r)
        --p.id1 = xyz2range(ix, iy, iz, x3, y3, z3)
        return p
      end
    end
    
       return p
       
   end
  
--[[
 if name()
 wildcards[1] = name (from)
 wildcards[2] = yaw
 wildcards[3] = pitch
 wildcards[4] = distance
else
 wildcards[1-3] = x, y, z
 wildcards[4] = yaw
 wildcards[5] = pitch
 wildcards[6] = distance
 

--]]
function fun_project(name, _, wildcards)
  if (name == "cmd_project1") then
    local s = findplanetbyname(tostring(wildcards[3]))
    local yaw, pitch, range = tonumber(wildcards[1]), tonumber(wildcards[2]), tonumber(wildcards[4])
   if not yaw or not pitch or not range then
     Note("Invalid parameters") 
     return
   end
   if not s then
     Note("Source not found.")
   end
   local px, py, pz = projectheading(yaw,pitch,range)
   Note(string.format("Projected coordinates are: %.3f %.3f %.3f", X(s) + px, Y(s) + py, Z(s) + pz))
   return
  elseif (name == "cmd_project2") then -- We got coordinates instead of a source name
    local x, y, z, yaw, pitch, range = tonumber(wildcards[1]), tonumber(wildcards[2]), tonumber(wildcards[3]), tonumber(wildcards[4]), tonumber(wildcards[5]), tonumber(wildcards[6])
    if not yaw or not pitch or not range or not x or not y or not z then
      Note("Invalid parameters")
    end
    local px, py, pz = projectheading(yaw,pitch,range)
    Note(string.format("Projected coordinates are: %.3f %.3f %3.f", x + px, y + py, z + pz))
    return
    end
end

 
-- Given a yaw and pitch, projects OUT to (range)
-- Returns x,y,z coordinates. 
-- Thanks Kthor!
function projectheading(yaw,pitch,range)
  local cos = math.cos
  local sin = math.sin
  
  if not yaw or not pitch or not range then return end
  
  if (range <= 0) then
    return 0, 0, 0
  end
  local x = (cos((yaw/180*PI))*cos((pitch/180*PI))*range)
  local y = (sin((yaw/180*PI))*cos((pitch/180*PI))*range)
  local z = (sin((pitch/180*PI))*range)
  return x, y, z
end

function objsnear(object)
  local t = {source = object, range = 100}
  fun_objsnear("objsnear_obj", nil, t)
end

 function fun_objsnear(name,_, wildcards)
   local sref = -1
  local s = string.format("%s--[%sObjects Near%s]--------------------------------------------------------------\r\n%s%-25s %-6s %-10s %-10s %-6s\r\n", 
      ANSI(1, 34), ANSI(1,33), ANSI(34), ANSI(22,36), "Name", "Type", "Range", "Yaw", "Pitch")
  
  s = s .. ANSI(22,34) .. "------------------------------------------------------------------------------"  
  local distance = 100
  local x, y, z, sname
  local results = { }
  
  if(name == "objsnear_obj") then
    distance = tonumber(wildcards.range)
    if (string.upper(wildcards.source) == "HERE") then
      x = tonumber(GetVariable("GRCX"))
      y = tonumber(GetVariable("GRCY"))
      z = tonumber(GetVariable("GRCZ"))
      sref = -1
      sname = "Here"
    else
      sref = findplanetbyname(wildcards.source)
      if (not sref) then
        ColourNote("red", "", "Source not found.")
        return
      end
      x, y, z, sname = X(sref), Y(sref), Z(sref), space_objs[sref].name
    end
  else
    if (GetVariable("FRAMENAME")) then
      x, y, z  = frame_to_grc(tonumber(wildcards.x), tonumber(wildcards.y), tonumber(wildcards.z), GetVariable("FRAMENAME"))
      sname = "Coordinates"
    else
      x, y, z, sname = tonumber(wildcards.x), tonumber(wildcards.y), tonumber(wildcards.z), "Coordinates"
    end
    
    distance = tonumber(wildcards.range)
    if (not x or not y or not z or not distance) then
      Note("Input error") 
      return
    end
  end 
    for i = 1, #space_objs do
      local r = xyz2range(x, y, z, space_objs[i].x, space_objs[i].y, space_objs[i].z)
      if (r <= distance ) then
        local yaw, pitch = xyzheading(x, y, z, space_objs[i].x, space_objs[i].y, space_objs[i].z)
        local class = "PLAN"
        if (space_objs[i].type == 0) then
          class = "BORD"
        elseif (space_objs[i].type == 1) then
          class = "BASE"
        end
        results[#results+1] = { empire = space_objs[i].empire, yaw = round(yaw,3), pitch = round(pitch,3), class = class, name = space_objs[i].name, range = round(r,3) }
      end -- if()
    end -- for
    table.sort(results, function(a,b) return a.range<b.range end) -- Sort closest to furthest    
    for i = 1, #results do
      local tmp = string.format("%-8s", "[" .. tostring(results[i].range) .. "]")
       s = s .. string.format("\r\n%s%-25.25s %s%-6s %-10s %-10s %-10s", ANSI(1,37), results[i].name .. " (" .. results[i].empire .. ")", ANSI(22), results[i].class, tmp, results[i].yaw, results[i].pitch)
    end
    
  s = s .. "\r\n" .. ANSI(1,34) .. "------------------------------------------------------------------------------"  
    AnsiNote(s)
  end


function Velocity(speed, c1, c2)
  c1 = c1 or COCHRANE
  c2 = c2 or COCHRANE
  local c3 = (c1 + c2) * 0.5
  local vel = speed^3.333333 * c3 * LIGHTSPEED / PARSEC
 
  return vel
 end

-- Given a vector, normalize to a unit
function normalize(x,y,z)
  local sqrt = math.sqrt
  local l = sqrt(x*x + y*y + z*z)
  return (x / l), (y / l), (z / l)
end

-- Creates a vector between two 3d points.
function xyz2vector(sx,sy,sz,tx,ty,tz)
        return (tx - sx), (ty - sy), (tz - sz)
end

-- Can be called by either fun_intercept(torigin, tdest,tspeed, pname, pspeed, leadTime)
-- or pname can be x, y, z coordinates. pspeed and leadTime are expected to be the last arguments.
-- Where torigin is it's origin, tdest is it's destination, tspeed is it's speed in warp, pname is our ship's location, leadTime is in minutes of how much of a leadtime from it's origin it had.
-- Uses World.Note() to give you XYZ intercept coordinates.
-- Error codes: -1 Source not found, -2 Dest not found, -3 Invalid speed, -4 pname not found, -5 invalid pspeed
-- leadTime is 5minutes by default

function fun_intercept_help()
      AnsiNote(string.format("%sUsage is:\r\n pi %s<ts>%s to %s<td>%s at %s<tspd>%s and %s<ploc|HERE>%s at %s<pspd>%s [<lt>]\r\n",
           ANSI(0,22), ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(1,33)))
      AnsiNote(string.format("%s<ts>%s and %s<td>%s are target's source and destination at %s<tspd>.",
           ANSI(0,22), ANSI(1,37), ANSI(0,22), ANSI(1,37),ANSI(0,22)))
      AnsiNote(string.format("%s<ploc>%s can be 'here' (set by using helm stat), or any planet/base.\r\nAll speeds are in warp factors.",  ANSI(1,37), ANSI(0,22)))
      AnsiNote(string.format("%s[<lt>]%s is optional: In minutes, how much leadtime the target has on you.", ANSI(1,33), ANSI(0,22)))
      AnsiNote(ANSI(0,22), "\r\nThis will NOT work if your velocity is the same as target. Still working on that.")
      AnsiNote(string.format("%s\r\nExample: 'pi Qo'nos to Earth at 14 and Bajor at 18'\r\n%sWill plot an intercept for a ship travelling from Qo'noS to Earth at warp 14,\r\nassuming you are currently at Bajor and intend to intercept at warp 18.", ANSI(1,37), ANSI(0,22)))
      return
    end
    
function fun_intercept(_,_, wildcards)
  
  local px, py, pz, pname = 0, 0, 0  -- These have to be declared ahead of time, otherwise we'll lose it in the if() statement below
  local x1, y1, z1, sname = 0, 0, 0
  local x2, y2, z2, dname = 0, 0, 0
  
  --local tloc, tdest, tspd, ploc, pspd, leadTime = string.match(arg, "pi%s(.+)%sto%s(.+)%sat%s([0-9]*%.?[0-9]+)%sand%s(.+)%sat%s([0-9]*%.?[0-9]+)%s*(%d*)")
  local tloc, tdest, tspd, ploc, pspd, leadTime = wildcards[1], wildcards[2], tonumber(wildcards[3]), wildcards[4], tonumber(wildcards[5]), tonumber(wildcards[6])
    if (not tloc or not tdest or not tspd or not ploc or not pspd) then
      AnsiNote(string.format("%sUsage is:\r\n pi %s<tsource>%s to %s<tdest>%s at %s<tspd>%s and %s<ploc|HERE>%s at %s<pspd>%s [<leadTime>]\r\n",
           ANSI(0,22), ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(0,22),ANSI(1,37), ANSI(1,33)))
      AnsiNote(string.format("%s<tsource>%s and %s<tdest>%s are target's source and destination at %s<tspd>.",
           ANSI(0,22), ANSI(1,37), ANSI(0,22), ANSI(1,37),ANSI(0,22)))
      AnsiNote(string.format("%s<ploc>%s can be 'here' (set by using helm stat), or any planet/base.\r\nAll speeds are in warp factors.",  ANSI(1,37), ANSI(0,22)))
      AnsiNote(string.format("%s[<leadTime>]%s is optional: In minutes, how much leadtime the target has on you.", ANSI(1,33), ANSI(0,22)))
      AnsiNote(ANSI(0,22), "\r\nThis will NOT work if your velocity is the same as target. Still working on that.")
      return
    end
  
  if (not leadTime) then
    leadTime = 5*60
  else
    leadTime = leadTime * 60
  end
    
  local tvel = Velocity(tspd) 
  local pvel = Velocity(pspd)
  local sref = findplanetbyname(tostring(tloc))
  
  if (not sref) then
    Note("Could not find source.")
    return
  end
  x1, y1, z1, sname = space_objs[sref].x, space_objs[sref].y, space_objs[sref].z, space_objs[sref].name
  
        local dref = findplanetbyname(tostring(tdest))
        if (not dref) then
    Note("Could not find tdestination.")
    return 
        end
  x2, y2, z2, dname = space_objs[dref].x, space_objs[dref].y, space_objs[dref].z, space_objs[dref].name
                
        if (string.upper(tostring(ploc)) == "HERE") then
     px = tonumber(GetVariable("GRCX")) 
     py = tonumber(GetVariable("GRCY"))
     pz = tonumber(GetVariable("GRCZ"))
     pname = "<HERE>"
     if not x1 or not y1 or not z1 then
       Note("PlotIntercept: Use 'helm stat' to update current location")
     end
   else
     local pref = findplanetbyname(tostring(ploc))
      if (not pref) then
        Note("PlotIntercept: Can't find player source: ")
        return
      end
      px, py, pz, pname = space_objs[pref].x, space_objs[pref].y, space_objs[pref].z, space_objs[pref].name
    end
    Note(string.format("Target: %s to %s at %.3f and %s at %.3f", sname, dname, tspd, pname, pspd))
    local ix, iy, iz, _ = plotintercept(x1, y1, z1, x2, y2, z2, tvel, px, py, pz, pvel, leadTime)
    
    if (ix == -1 and iy == -1 and iz == -1) then
      Note("Interception not found.")
      return
    else
      local range = xyz2range(px, py, pz, ix, iy, iz)
      ColourNote("yellow", "", string.format("Interception will be at (%s): %s\r\nTime to point: %s [%.3f]", frame.name, grc_to_frame(ix,iy,iz, true), timestring(range / pvel), range))
      SetClipboard(grc_to_frame(ix,iy,iz, true))
    end
    
end -- function()
    
-- sx, sy, sz = Target's Origin
-- tx, ty, tz = Target 's Destination
-- tvel Is it's velocity in PC/S
-- px, py, pz, pvel same thing, for our ship
-- leadtime, in seconds.
-- returns x, y, z, timeIntercept
function plotintercept(sx, sy, sz, tx, ty, tz, tvel, px, py, pz, pvel, leadtime)
  local sqrt = math.sqrt
  local vx, vy, vz = normalize(tx - sx, ty - sy, tz - sz) -- Normalize is just the vector divided by it's length
  local timeIntercept = leadtime 
  local time0, time1 
  local EPS = 0.0001
        -- Take the unit vector v(x,y,z) and add in our velocity
  vx = vx * tvel
  vy = vy * tvel
  vz = vz * tvel
  local a = (vx * vx + vy * vy + vz * vz) - (pvel * pvel)
  
  if (a == 0) then
    Debug("PI2: Quadratic will not work at 0. Targets speed too close?")
    return -1, -1, -1
  end
  local dx, dy, dz = xyz2vector(px, py, pz, sx, sy, sz) -- Vector from target's origin to our ships location
  local b = 2.0*( dx * vx + dy * vy + dz * vz)
  local c = (dx * dx + dy * dy + dz * dz)
  local rad = b*b - 4*a*c
  
  if (rad <0) then -- Not possible
    Debug("PI2: No possible intersection")
    return -1, -1, -1
  end
  if (b ~= 0 and (math.abs(pvel - tvel) < 0.03)) then
    time0 = -c/b
    timeIntercept = timeIntercept + time0
    local rx = sx + (vx * timeIntercept)
    local ry = sy + (vy * timeIntercept)
    local rz = sz + (vz * timeIntercept)
    return rx, ry, rz, timeIntercept
  end
  time0 = (-b + sqrt(rad) / (2*a))
  time1 = (-b - sqrt(rad) / (2*a))
  
  if (time0 < time1) then
    if (time1 < 0.0) then
    Debug("PI: No intercept possible. Time1 is <0: %f", time1)
    return -1, -1. -1
    end
    if (time0 >= 0.0) then
      timeIntercept  = timeIntercept + time0
    else
      timeIntercept = timeIntercept + time1
    end
  else
    if (time0 <0.0) then
      Debug("PI: No intercept possible. Time0 is <0: %f", time0)
      return -1, -1, -1
    end
    if (time1 >= 0.0) then
      timeIntercept = timeIntercept + time1
    else
      timeIntercept = timeIntercept + time0
    end
  end
  if (time1  < 0.0 and time0 < 0.0) then
    return -1, -1, -1
  end
    
  local rx = sx + (vx * timeIntercept)
  local ry = sy + (vy * timeIntercept)
  local rz = sz + (vz * timeIntercept)
  return rx, ry, rz, timeIntercept
end

-- Converts XYZ (GRC) into player-set frame. If Output is true, it returns a string, otherwise it returns 3 variables x, y, z in the new frame.
function grc_to_frame(x,y,z, output)
    if(frame.name == "GRC") then
      if(output) then
        return string.format("%.3f %.3f %.3f", x, y, z)
      else
        
        return x,y,z
      end
      
    end
    if (output) then
      return string.format("%.3f %.3f %.3f",(x - frame.x), (y - frame.y), (z - frame.z))
    else
      return (x - frame.x), (y - frame.y), (z - frame.z)
    end
    
  end
  
  function fun_setframe(_, _, wildcards)
    if (not wildcards[1]) then
      Note("Error. Must supply a valid frame. Try the help argument instead.")
    end
    local s = string.upper(wildcards[1])
    
    if ( s == "HELP") then
      local str = "Valid frames are:"
      for _ ,v in ipairs(space_objs) do
        if (v.type == 0) then
          str = str .. " " .. v.name .. ","
        end
      end
      Note(str)
      return
    elseif (s == "GRC") then
      frame.name = "GRC"
      frame.x = 0
      frame.y = 0
      frame.z = 0
      SetVariable("FRAMENAME", frame.name)
      SetVariable("FRAMEX", frame.x)
      SetVariable("FRAMEY", frame.y)
      SetVariable("FRAMEZ", frame.z)
      Note("Local frame set to GRC")
      return
    else
      local f, x, y, z = findframebyname(s)
      if (f) then
          Note("Local frame set to " .. f)
          SetVariable("FRAMENAME", f)
          SetVariable("FRAMEX", x)
          SetVariable("FRAMEY", y)
          SetVariable("FRAMEZ", z)
          return
      end
      Note("Frame not found. Try the help function.")
      return
    end
  end
  
  function verify_frame(gx, gy, gz, fx, fy, fz, range)
    return (xyz2range(gx,gy,gz,fx,fy,fz) <= range)
  end
  function findframebyname(frame)
    if (string.upper(frame) == "GRC") then
      return "GRC", 0, 0, 0
    end
    frame = string.upper(frame)
    
    for i = 1, #border_objs do
      if(frame == border_objs[i].name:upper() or string.find(border_objs[i].name:upper(), frame)) then
        return border_objs[i].name, border_objs[i].x, border_objs[i].y, border_objs[i].z, border_objs[i].radius or 0
      elseif (border_objs[i].aliases) then
        for k = 1, #border_objs[i].aliases do
          
          if (border_objs[i].aliases[k] == string.upper(frame)) then
            return border_objs[i].name, border_objs[i].x, border_objs[i].y, border_objs[i].z, border_objs[i].radius or 0
          end
        end
      end
    end
    return nil
  end
  
  function frame_to_grc(fx, fy, fz, frame)
    local f, x, y, z = findframebyname(frame)
    if (f) then
      return fx + x, fy + y, fz + z
    else
      return nil
    end
  end
    
  
-- Takes XYZ (in frame), from source (planet or space_objs ref, and range, returns GRC and frame name
-- Only used for base bots
function findframe(fx, fy, fz, source, range)
  local srcid = tonumber(source)
  if (not srcid) then
    srcid = findplanetbyname(srcid)
  end
  if (not srcid) then
    return nil
  end
  local sx, sy, sz = X(srcid), Y(srcid), Z(srcid)
  
  for i = 1, #border_objs do
      local x, y, z = fx + border_objs[i].x, fy + border_objs[i].y, fz + border_objs[i].z -- Convert to GRC
      local r = xyz2range(x, y, z, sx, sy, sz) -- Check range
      Debug("FindFrame(): Testing %s (%.3f)", border_objs[i].name, r)
      if (math.abs(r - range) < 1) then -- Paydirt?
        Debug("FindFrame(): Found: %s", border_objs[i].name)
        return border_objs[i].name, x, y, z
      end
    end
  end


  function xyz2quadrant(x, y, _)
    if (x > 0.0) then
      if (y > 0.0) then
        return "GQ"
      else
        return "DQ"
      end
    else
      if (y > 0.0) then
        return "BQ"
      else 
        return "AQ"
      end
    end
  end
         
  function fun_convertframe(_, _, wildcards)
    local x, y, z = tonumber(wildcards[1]), tonumber(wildcards[2]), tonumber(wildcards[3])
    local from, to = wildcards[4], wildcards[5]
    
    if (not x or not y or not z or not from or not to) then
      Note("Error")
      return
    end
    
    ColourNote("white", "", string.format("Attempting to convert %.3f %.3f %.3f from %s to %s.", x, y, z, from, to))
    local f, fx, fy, fz = findframebyname(from)
    if (not f) then
      ColourNote("red", "", "From frame not found.")
    end
    
    local t, tx, ty, tz = findframebyname(to)
    if (not t) then
      ColourNote("red", "", "To frame not found.")
    end
    
    
    if (not f or not t) then
        local str = "Valid frames are: "
        for i = 1, #border_objs do
          if (border_objs[i].aliases) then
            str = str .. string.format("%s (", border_objs[i].name)
            for k = 1, #border_objs[i].aliases do
              local v = border_objs[i].aliases[k]
              str = str .. string.format("%s%s", k == 1 and "" or ",", v)
            end
            str = str .. "), "
          else
            str = str .. border_objs[i].name .. ", "
          end
          
        end
        ColourNote("white", "", str .. "and GRC.")
        return
      end
    if(t == "GRC") then -- Converting from a frame to GRC
       local ix = x + fx
       local iy = y + fy
       local iz = z + fz
       ColourNote("white", "", string.format("Conversion from %s to GRC: %.3f %.3f %.3f", f, ix, iy, iz))
       SetClipboard(string.format("%f %f %f", ix, iy, iz))
    elseif (f == "GRC") then -- Converting from GRC to a frame
      local ix = x - tx
      local iy = y - ty
      local iz = z - tz
      ColourNote("white", "", string.format("Conversion from GRC to %s: %.3f %.3f %.3f", t, ix, iy, iz))
      SetClipboard(string.format("%f %f %f", ix, iy, iz))
      return
    else -- Between two frames, convert to GRC, then to proper frame
      local gx = x + fx
      local gy = y + fy
      local gz = z + fz
      
      local ix = gx - tx
      local iy = gy - ty
      local iz = gz - tz
      ColourNote("yellow", "", string.format("Conversion from %s to %s: %.3f %.3f %.3f", f, t, ix, iy, iz))
      SetClipboard(string.format("%f %f %f", ix, iy, iz))
      return
    end
end

  --[[
  -- Some helper functions, should be self explanitory. Except maybe pack()
  --]]
  
  function pack(...) return {n=select('#', ...), ...} end
  function X(i) return space_objs[i] and space_objs[i].x or 0 end
  function Y(i) return space_objs[i] and space_objs[i].y or 0 end
  function Z(i) return space_objs[i] and space_objs[i].z or 0 end
  function C(i) return space_objs[i] and space_objs[i].cochranes or COCHRANE end
  
  -- Splits a string into a table of each item separated by whitespaces.
  -- E.g. s = "One two three 000"
  -- t = s:split()
  -- t[1] = "One", t[2] = "two", t[3] = "three", t[4] = 000
function string:split(sep)
    if not sep then
      sep = "%s"
    end
    
    local t={}  
    local i=1
    for str in string.gmatch(self, "([^"..sep.."]+)") do
      t[i] = trim(str)
      i = i + 1
    end
return t
end

  
function fun_fromto(name, _ , wildcards)
  local dRef = findplanetbyname(tostring(wildcards[2]))
  local pname, px, py, pz, pq = nil, 0, 0, 0, nil
  local range, speed = 0, tonumber(wildcards[3] or 16.06)
  local pc = COCHRANE
  local eta, dq, gate, sRef = 0, nil, { }, nil
  
  if (not dRef) then
    Note("Could not find ending point.")
    return
   end
   
  if (string.upper(wildcards[1]) == "HERE") then
    local tmp = GetVariable("GRCX")
    if (not tmp) then
      Note("You must first updated your location with 'help stat'.")
      return
    end
    sRef = -1
    px = tonumber(tmp)
    py = tonumber(GetVariable("GRCY") or 0)
    pz = tonumber(GetVariable("GRCZ") or 0 )
    pc = tonumber(GetVariable("COCHRANE") or 0)
    pname = "HERE"
  else
    sRef = findplanetbyname(wildcards[1])
    if not (sRef) then
      Note("Could not find starting location.")
      return
    end
    px, py, pz, pc = X(sRef), Y(sRef), Z(sRef), C(sRef)
    pname = space_objs[sRef].name
  end
  
 pq = xyz2quadrant(px, py, pz)
 dq = xyz2quadrant(X(dRef), Y(dRef), Z(dRef))
 range = xyz2range(px, py, pz, X(dRef), Y(dRef), Z(dRef))
 eta = range / Velocity(speed, pc, C(dRef)) 
 --Debug("Range: %f, Vel: %f, ETA: %f: C1: %f C2: %f", range, Velocity(speed, pc, C(dref)), eta, pc, C(dRef))
 
 if (range < 1) then
    AnsiNote(ANSI(1,37), "You are there.")
    return
  end
  ColourNote("red", "", "USING OLD CODE, NUMBNUTS!!")
 -- Gamma Quadrant check.
 if (pq == "Gamma") then -- We are in the GQ
   if (dq == "Gamma") then -- So is target. Head directly there.
      AnsiNote(string.format("%sFrom %s%s %sto %s%s [%.3f] %s %sat %sw%.3f:\n\r%sHead directly there.",  ANSI(1,37), 
              ANSI(22,33), pname, ANSI(1,37), ANSI(22,32), space_objs[dRef].name, range, timestring(eta), ANSI(1,37), ANSI(22,36), speed, ANSI(1,37)))
      local s = bordercrossings(px, py, pz, X(dRef), Y(dRef), Z(dRef), Velocity(speed, C(sRef), C(dRef)))
      if (s) then  
        AnsiNote (ANSI (1, 37),s)
      end
      return
    else
      local wormhole = space_objs[findplanetbyname("Idran")]
      local r = xyz2range(px, py, pz, wormhole.x, wormhole.y, wormhole.z)
      local weta = r / Velocity(speed, pc, wormhole.cochranes)
      
      AnsiNote(string.format("%sFrom %s%s %sto %s%s [%.3f] %s %sat %sw%.3f:\n\r%sUse %sWormhole%s at %sIdran X [%.3f] %s%s and then\r\n\r\n",  ANSI(1,37), 
              ANSI(22,33), pname, ANSI(1,37), ANSI(22,32), space_objs[dRef].name, range,    
              timestring(eta), ANSI(1,37), ANSI(22,36), speed, ANSI(22, 36), ANSI(1,33), ANSI(22,36), ANSI(1,36), r, timestring(weta), ANSI(22,36)))
          
      local t = { "Bajor", wildcards[2], speed }
      local s = bordercrossings(px, py, pz, X(wormhole), Y(wormhole), Z(wormhole), Velocity(speed, C(sRef), C(wormhole)))
      if (s) then AnsiNote(ANSI(1,37), s) end
      fun_fromto("Quiet",_,t)
      return
    end
  end
  
  if (dq == "Gamma") then
    if( pq == "Delta") then
      local t = { wildcards[1], "Lily", speed }
      
      fun_fromto("Quiet",_,t)
      t = { "Sherman", wildcards[2], speed }
      fun_fromto("Quiet", _,t)
      return
    elseif (pq == "Beta" or pq == "Alpha") then -- We're not in the GQ, but want to be.
      local wormhole = space_objs[findplanetbyname("Bajor")]
      local r = xyz2range(px, py, pz, wormhole.x, wormhole.y, wormhole.z)
      local weta = r / Velocity(speed, pc, wormhole.cochranes)
      AnsiNote(string.format("%sFrom %s%s %sto %s%s [%.3f] %s %sat %sw%.3f:\n\r%sUse %sWormhole%s near %sBajor [%.3f] %s%s and then\r\n\r\n",  ANSI(1,37), 
              ANSI(22,33), pname, ANSI(1,37), ANSI(22,32), space_objs[dRef].name, range,    
              timestring(eta), ANSI(1,37), ANSI(22,36), speed, ANSI(22, 36), ANSI(1,33), ANSI(22,36), ANSI(1,36), r, timestring(weta), ANSI(22,36)))
      local t = { "Idran", wildcards[2], speed }
      fun_fromto("Quiet",_,t)
      return
    end
  end
    
  -- Alrighty. If we got THIS far, the GQ is out of the question. I think.
  
  gate[1] = space_objs[findplanetbyname("Sherman")]
  gate[2] = space_objs[findplanetbyname("Phoenix")]
  gate[3] = space_objs[findplanetbyname("New Risa")]
  gate[4] = space_objs[findplanetbyname("Old Risa")]
  gate[5] = space_objs[findplanetbyname("Lily")]
  gate[6] = space_objs[findplanetbyname("USB Stormwatch")]
    
  for  i = 1, #gate  do -- gate[x].range is range from start to gate, gate[x].destrange is range from destination to gate.
    gate[i].range = xyz2range(px, py, pz, gate[i].x, gate[i].y, gate[i].z)
    gate[i].destrange = xyz2range(X(dRef), Y(dRef), Z(dRef), gate[i].x, gate[i].y, gate[i].z)
    gate[i].eta = gate[i].range / Velocity(speed, pc, gate[i].cochranes)
    gate[i].desteta = gate[i].destrange / Velocity(speed, C(dRef), gate[i].cochranes)
  end
  
  local sresult, dresult = 1,1
  
  for i = 1, #gate do
    if (gate[i].eta < gate[sresult].eta) then
      sresult = i
    end
    if (gate[i].desteta < gate[dresult].desteta) then
      dresult = i
    end
  end
  
  -- Ok we have the two closest gates, from source->gate and dest->gate. Now see if our combined is less than a straight line.

  local r = gate[sresult].range + gate[dresult].destrange
  local geta = gate[sresult].eta + gate[dresult].desteta
  
  if ((geta - eta) < -300 and sresult ~= dresult) then
    local bc1 = bordercrossings(px, py, pz, gate[sresult].x, gate[sresult].y, gate[sresult].z, Velocity(speed, pc, gate[sresult].cochranes))
    local bc2 = bordercrossings(gate[dresult].x, gate[dresult].y, gate[dresult].z, X(dRef), Y(dRef), Z(dRef), Velocity(speed, gate[dresult].cochranes, C(dRef)))
    local str1 = ""
    if (name ~="Quiet") then
      str1 = string.format("%sFrom %s%s %sto %s%s [%.3f] %s %sat %sw%.3f:\n\r\n\r",  
        ANSI(1, 37), ANSI(22,33), pname, ANSI(1,37), ANSI(22,32), space_objs[dRef].name, r, timestring(geta), ANSI(1,37), ANSI(22,36), speed )
    end
    
    if (gate[sresult].range <= 0) then
      str1 = str1 .. string.format("%sUse local %sTranswarp %s, exiting at %s%s\n\r", ANSI(36), ANSI(1,33), ANSI(22,36), ANSI(1,36), gate[dresult].name)
    else
      str1 = str1 .. string.format("%s%s %s----->%s %s [%.3f] %s\r\n%s%s\r\n", ANSI(1, 32), pname,  ANSI(1, 37), ANSI(1, 32), gate[sresult].name, gate[sresult].range, 
         timestring(gate[sresult].eta), ANSI(1, 32), bc1 or "No border crossings\r\n") 
    end
    --if (gate[dresult].destrange < 1) then
      --str1 = str1 .. string.format("%sExit %sStargate%s at %s%s", ANSI(22, 36), ANSI(1,33), ANSI(22,36), ANSI(1,36), gate[dresult].name)
    if (gate[dresult].destrange > 0) then
     str1 = str1 .. string.format("%s%s %s----->%s %s [%.3f] %s%s",ANSI(1, 36), gate[dresult].name, ANSI(1,37), ANSI(1,36), space_objs[dRef].name, gate[dresult].destrange, 
          timestring(gate[dresult].desteta), bc2 or "\n\rNo border crossings")
    end
       
    AnsiNote(str1)
     return
  else
    local str1 = string.format("%sFrom %s%s %sto %s%s [%.3f] %s %sat %sw%.3f [%.3f]:\n\r%sHead directly there.",  
        ANSI(1,37), ANSI(22,33), pname, ANSI(1,37), ANSI(22,32), space_objs[dRef].name, range, timestring(eta), ANSI(1,37), ANSI(22,36), speed, Velocity(speed, pc, C(dRef)), ANSI(1,37))
    AnsiNote(str1)
       
    local s = bordercrossings(px, py, pz, X(dRef), Y(dRef), Z(dRef), Velocity(speed, C(sRef), C(dRef)))
    if (s) then  
      AnsiNote (ANSI (1, 37),s)
    end
    
     return
   end
   
end

local function best_route(px, py, pz, pc, speed, dx, dy, dz, dc)
  local gate = { }
  local known_conduits = {"Boreth", "Magna Roma", "Elosian City", "Usho Prime", "Zausta VI", "Clispau IX", "Latinum Galleria", "Thieurrull" }
  local quadrant = xyz2quadrant(px, py, pz)
  
  for i = 1, #known_conduits do
    local ref = findplanetbyname(known_conduits[i])
    if (ref ~= NIL) then
      gate[i] = space_objs[ref]
      gate[i].ref = ref
      gate[i].quadrant = xyz2quadrant(gate[i].x, gate[i].y, gate[i].z)
      gate[i].range = xyz2range(px, py, pz, gate[i].x, gate[i].y, gate[i].z)
      gate[i].destrange = xyz2range(dx, dy, dz, gate[i].x, gate[i].y, gate[i].z)
      gate[i].eta = gate[i].range / Velocity(speed, pc, gate[i].cochranes)
      gate[i].desteta = gate[i].destrange / Velocity(speed, dc, gate[i].cochranes)
    end
  end
  
      
  --[[    Old Stargate code 
  local tmp = findplanetbyname("Sherman")
  gate[1] = space_objs[tmp]
  gate[1].ref = tmp
  tmp = findplanetbyname("Phoenix")
  gate[2] = space_objs[tmp]
  gate[2].ref = tmp
  tmp = findplanetbyname("New Risa")
  gate[3] = space_objs[tmp]
  gate[3].ref = tmp
  tmp = findplanetbyname("Old Risa")
  gate[4] = space_objs[tmp]
  gate[4].ref = tmp
  tmp = findplanetbyname("Lily")
  gate[5] = space_objs[tmp]
  gate[5].ref = tmp
  tmp = findplanetbyname("USB Stormwatch")
  gate[6] = space_objs[tmp]
  gate[6].ref = tmp
    --]] 
  local sresult, dresult = 1,1
  
  for i = 1, #gate do
    if (gate[i].eta < gate[sresult].eta) then
      sresult = i
    end
    if (gate[i].desteta < gate[dresult].desteta) then
      dresult = i
    end
  end
  
  -- Special case for when we for some fucking reason picked the same fucking gate.
  if (sresult == dresult and gate[sresult].range > 1) then
    return gate[sresult].eta*5000, gate[sresult].range, gate[dresult].desteta*5000, gate[dresult].destrange, gate[sresult].ref, gate[dresult].ref
  else
    return gate[sresult].eta, gate[sresult].range, gate[dresult].desteta, gate[dresult].destrange, gate[sresult].ref, gate[dresult].ref
  end
end

function bordercrossings(sx, sy, sz, dx, dy, dz, velocity)
 local crossings = {}
 local r = xyz2range(sx, sy, sz, dx, dy, dz)
 
 if (r < 1.0) then
  return nil
end

 for i = 1, #border_objs do
   if (border_objs[i].radius and border_objs[i].radius > 0) then
     local px, py, pz = border_objs[i].x, border_objs[i].y, border_objs[i].z
     local p = intersection(sx, sy, sz, dx, dy, dz, px, py, pz, border_objs[i].radius)
     if (p.intersections > 0) then
          p.name = border_objs[i].name
          p.eta1 = p.r1 / velocity
          if (p.intersections == 2) then
            p.eta2 = p.r2 / velocity
          end
          crossings[#crossings+1] = p
     end
   end
 end
  local s = ""

  if (#crossings < 1) then
    return nil
  end
    
    if (#crossings > 1) then
      table.sort(crossings, function(a,b) return a.r1<b.r1 end) -- Sort closest to furthest
    end
    local first = true
    for i = 1, #crossings do
      if (crossings[i].intersections == 1) then
        s = s .. string.format("%s%-12s%s%s%s [%.3f] %s%s %s%s",  first and "" or "\r\n", "",
            ANSI(32), timestring(crossings[i].eta1 or 0), ANSI(0,22), crossings[i].r1, ANSI(1,33), crossings[i].inside1 and "INBOUND" or "OUTBOUND", ANSI(0,22), 
            crossings[i].name )
      elseif (crossings[i].intersections ==2 ) then
        if(crossings[i].r1 < crossings[i].r2) then
          s = s .. string.format("%s%-12s%s%s%s [%.3f] %s%s %s%s", first and "" or "\r\n", "",
            ANSI(32), timestring(crossings[i].eta1 or 0), ANSI(0,22), crossings[i].r1, ANSI(1,33), crossings[i].inside1 and "INBOUND" or "OUTBOUND", ANSI(0,22), 
            crossings[i].name )
          s = s .. string.format("%s%-12s%s%s%s [%.3f] %s%s %s%s", "\r\n", "", 
            ANSI(32), timestring(crossings[i].eta2 or 0), ANSI(0,22), crossings[i].r2, ANSI(1,33), crossings[i].inside2 and "INBOUND" or "OUTBOUND", ANSI(0,22), 
            crossings[i].name )
        else
          s = s .. string.format("%s%-12s%s%s%s [%.3f] %s%s %s%s", first and "" or "\r\n", "",
            ANSI(32), timestring(crossings[i].eta2 or 0), ANSI(0,22), crossings[i].r2, ANSI(1,33), crossings[i].inside2 and "INBOUND" or "OUTBOUND", ANSI(0,22), 
            crossings[i].name )
          s = s .. string.format("%s%-12s%s%s%s [%.3f] %s%s %s%s", "\r\n", "",
            ANSI(32), timestring(crossings[i].eta1 or 0), ANSI(0,22), crossings[i].r1, ANSI(1,33), crossings[i].inside1 and "INBOUND" or "OUTBOUND", ANSI(0,22), 
            crossings[i].name )
        end
        
      end
      first = false
    end
    
    if (s) then
      return s
    end
    
end

function timestring(s)
  return string.format("%.2d:%.2d:%.2d", s/(60*60), s/60%60, s%60)
end


function update_helm_info(name, _, wildcards)
  
  if (name == "HelmXYZGrabber") then
    local x, y, z = tonumber(wildcards[1]), tonumber(wildcards[2]), tonumber(wildcards[3])
  
    if not x or not y or not z then
      Debug("upd_loc() Error!")
      return
    end
  
    SetChanged (true)
    SetVariable("GRCX", x)
    SetVariable("GRCY", y)
    SetVariable("GRCZ", z)
    SetVariable("GRCTIME", os.time())
    Debug("Location updated")
  elseif (name == "HelmCochraneGrabber") then
    SetVariable("COCHRANE", tonumber(wildcards[1]))
    SetChanged (true)
    Debug("Cochranes updated: %d", tonumber(wildcards[1]))
  end  
end
  
-- kills.name, kills.dmgIn, kills.dmgOut, kills.firstshot, kills.timeofdeath, kills.assists
function stats_handle_firing(_, _, wildcards, styles)
    if(not wildcards.firing or string.len(wildcards.firing) < 1) then
      return
    end
    SetChanged (true)
    
    local t = wildcards.firing:split("%s")
    local dmg, hits, misses, contact = 0, 0, 0, 0
    contact = tonumber(wildcards.contact)

    for i = 1, #t do
      local tmp = t[i]:split(":")
      if (tmp[2] and tonumber(tmp[2])) then
         dmg = dmg + tonumber(tmp[2])
         hits = hits + 1
       elseif (tmp[2] and tostring(tmp[2]) == "--") then
         misses = misses + 1
        end
    end
    if (#styles > 1) then -- This is to catch un-ansified text, usualyl from quotes or magposts.
      if (config_table.condense_combat) then
        AnsiNote(ANSI(34), "[", ANSI(1, 33), wildcards.player, ANSI(34, 22), "]--[", ANSI(36), "Firing at ", wildcards.name, " (" .. wildcards.contact .. "): " .. ANSI(1, 31), dmg, ANSI(34, 22), "]")
      else
        for i = 1, #styles do
          if (i ~= #styles) then
            ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour),styles[i].text)
          else
            AnsiNote (ANSI(36), " Total:", ANSI(1,31), dmg, ANSI(0,34), "]")  -- wrap up line
          end
        end -- for each style run
      end
    else
      ColourTell (RGBColourToName (styles[1].textcolour),RGBColourToName (styles[1].backcolour),styles[1].text)
      AnsiNote("")
    end
      
      
      if( wildcards.name:find("Simulator%d[%w_%d]+") or wildcards.name:find("OOC Area")) then -- Don't record simulators
      return 
    end
    
    stats.dmgOut = stats.dmgOut + dmg
    stats.hits = stats.hits + hits
    stats.misses = stats.misses + misses
    
    for _, v in ipairs(stats.ships) do
      if (v.name ~="contact" and v.name == wildcards.name) then
          if (v.timeofdeath and v.timeofdeath > 0) then
      else
        v.hits = hits + v.hits
        v.dmgIn = v.dmgIn + dmg
        v.misses = v.misses + misses
        stats.in_combat = true 
        stats.combatwith = v
        
        Debug("Firing: %s - %d hits, %d misses, %d damage.", wildcards.name, hits, misses, dmg)
        return
      end
      
      elseif(v.name == "contact" and v.contact == contact) then
        if (v.timeofdeath and v.timeofdeath > 0) then
        else
         v.hits = v.hits + 1
         v.dmgIn = v.dmgIn + dmg
         v.misses = v.misses + misses
         stats.in_combat = true 
         stats.combatwith = v

        end
       end
     end
      
     -- If we got this far, it should be a new entry. Build and save it
    local enemy = { dmgIn = dmg, hits = hits, misses = misses, contact = contact, name = wildcards.name, firstshot = os.time(), dmgOut = 0 }
        
    stats.in_combat = true 
    stats.combatwith = enemy
    stats.ships[#stats.ships+1] = enemy
     
     Debug("Recorded(New): %s - %d hits, %d misses, %d damage.", wildcards[2], hits, misses, dmg)
  end
  -- wildcards[1] = name, wildcards[2] = contact#
function stats_handle_disable(_, _, wildcards)
  SetChanged (true)
  
  if( wildcards[1]:find("Simulator%d[%w_%d]+") ) then -- Don't record simulators
      return 
    end
    
  for _, v in ipairs(stats.ships) do
    if (v.name == wildcards[1]) then
      if (v.timeofdeath and v.timeofdeath > 0) then -- This stops false updates due to people posting their kill disables in mushcode or on channels.
        return
      end
      v.timeofdeath = os.time()
      stats.kills = stats.kills + 1
      if (stats.combatwith and stats.combatwith.name == v.name) then
         stats.combatwith = nil
         stats.in_combat = false
       end
       
      
      local kill = {}
      kill.name = v.name
      kill.timeofdeath = os.time()
      if (v.firstshot ) then
        kill.ttk = math.abs(os.time() - v.firstshot)
      else
        kill.ttk = 0
      end
      kill_list[#kill_list+1] = kill
      ColourNote("yellow", "", string.format("%s has been disabled. TTK: %s",  wildcards[1], timestring(kill.ttk or 0)))
      
    elseif (wildcards[1] == "contact" and v.contact == tonumber(wildcards[2])) then
        
      if (v.timeofdeath and v.timeofdeath > 0) then
      else
        v.timeofdeath = os.time()
        stats.kills = stats.kills + 1
      
    
        if (stats.combatwith and stats.combatwith.name == v.name) then
          stats.combatwith = nil
          stats.in_combat = false
        end
        Debug("handle_disable(): %s has been recorded by contact#", wildcards[1])
        local kill = {}
        kill.name = v.name
        kill.timeofdeath = os.time()
        if (v.firstshot ) then
          kill.ttk = math.abs(os.time() - v.firstshot)
        else
          kill.ttk = 0
        end
        kill_list[#kill_list+1] = kill
      end
    end
  end
end

function stats_showdata(_, _, wildcards)
  if (string.upper(wildcards[1]) == "CLEAR") then
    for i = 1, #stats.ships do
      stats.ships[i] = nil
    end
  
    stats.dmgOut = 0
    stats.dmgIn = 0
    stats.misses = 0
    stats.hits = 0
    Note("Ship statistics cleared.")
    return
  elseif (string.upper(wildcards[1]) == "KILLS") then
    local s = "Kill list\r\n"
    for _, v in ipairs(kill_list) do
      if (not v.ttk) then
        v.ttk = math.abs(v.timeofdeath or 0 - v.firstshot or 0 )
      end
      if (v.ttk < 0) then
        v.ttk = math.abs(v.timeofdeath or 0 - v.firstshot or 0 )
      end
      
      s = s .. string.format("%s destroyed at %s. TTK: %s\r\n", v.name, os.date("%c", v.timeofdeath), timestring(v.ttk))
    end
    Note(s)
  else
  local hp
  if (stats.hits > 0 or stats.misses > 0) then
    hp = stats.hits / (stats.hits + stats.misses) * 100
  else
    hp = 0
  end
  
  local s = string.format("Combat statistics -- %d DmgRcv, %d DmgGiven.\r\n      %d hits, %d misses (%.2f%%) -- %d kills\r\n", stats.dmgIn, stats.dmgOut, stats.hits, stats.misses, hp, stats.kills )
  
  for _,v in ipairs(stats.ships) do
    local destroyed = v.timeofdeath and "-- Destroyed. TTK: " .. timestring(os.difftime(v.timeofdeath, v.firstshot)) or ""
    s = s .. string.format("%s -- %d dmgRecv, %d dmgGiven %s\n\r", v.name, v.dmgIn, v.dmgOut, destroyed)
  end
  Note(s)
end

end


function stats_handle_firedon(_, _, wildcards, styles)
  local dmg, hits, misses = 0,  0, 0
  local contact = tonumber(wildcards[2])
  local t = wildcards[3]:split("%s")
  SetChanged (true)
  
  for i = 1, #t do
    local tmp = t[i]:split(":")
    if (tmp[2] and tonumber(tmp[2])) then
      dmg = dmg + tonumber(tmp[2])
      hits = hits + 1
    elseif (tmp[2] and tostring(tmp[2]) == "--") then
      misses = misses + 1
    end
  end  
  if (#styles > 1) then -- This is to catch un-ansified text, usualyl from quotes or magposts.
    if (config_table.condense_combat) then
      AnsiNote(ANSI(34), "[", ANSI(3, 31), "WARNING", ANSI(34, 23), "]--[", ANSI(36), wildcards[1], " (" .. wildcards[2] .. ") Firing: " .. ANSI(31, 1), dmg, ANSI(34, 22), "]")
      
    else
      for i = 1, #styles do
        if (i ~= #styles) then
          ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour),styles[i].text)
        else
          AnsiNote (ANSI(36), " Total:", ANSI(1,31), dmg, ANSI(0,34), "]")  -- wrap up line
        end
      end -- for each style run
    end
  else
    ColourTell(RGBColourToName(styles[1].textcolour), RGBColourToName(styles[1].backcolour), styles[1].text)
    AnsiNote("")
  end
  
  
  if( wildcards[1]:find("Simulator%d[%w_%d]+") ) then -- Don't record simulators
      return 
    end
  
  stats.dmgIn = stats.dmgIn + dmg
  for _, v in ipairs(stats.ships) do
    if (v.name == wildcards[1]) then
      v.dmgOut = v.dmgOut + dmg
      stats.in_combat = true 
      stats.combatwith = v
      
      Debug("handle_firedon(): Recorded hit from: %s - %d", v.name, dmg)
     
      return
    elseif(v.name == "contact" and v.contact == contact ) then
      if (v.timeofdeath and v.timeofdeath > 0) then
      else
        
      v.dmgOut = v.dmgIn + dmg
      stats.in_combat = true 
      stats.combatwith = v
      Debug("handle_firedon(): Recorded hit from: %s (%d) - %d", wildcards[1], contact, dmg)
      return
    end
    
    end
  end
  -- If we got this far, it's a new ship. Add it
  local enemy = { dmgIn = 0, dmgOut = dmg, name = wildcards[1], contact = contact, hits = 0, misses = 0, firstshot = os.time() }
  stats.ships[#stats.ships+1] = enemy
  stats.in_combat = true 
  stats.combatwith = enemy
  
  Debug("handle_firedon(): (NEW) Recorded hit from: %s (%d) - %d", wildcards[1], contact, dmg)
  return
end


function OnPluginInstall ()
  
  frame.name = GetVariable("FRAMENAME") or "GRC"
  frame.x = tonumber(GetVariable("FRAMEX")) or 0
  frame.y = tonumber(GetVariable("FRAMEY")) or 0
  frame.z = tonumber(GetVariable("FRAMEZ")) or 0
  assert (loadstring (GetVariable ("stats") or "")) ()
  assert (loadstring (GetVariable ("CHAR_SKILLS") or "")) ()
  assert (loadstring (GetVariable ("kill_list") or "")) ()
  
  config_table.auto_check = tonumber(GetVariable("AUTOCHECK")) and true or true
  config_table.ansi_color = tonumber(GetVariable("ANSI")) and true or true
  --config_table.condense_combat =  tonumber(GetVariable("CONDENSE_COMBAT")) and true or false
  config_table.condense_combat = false -- Removed because ATS does this on its own now.
  config_table.missionparser = tonumber(GetVariable("MISSION_PARSER")) and true or false
  config_table.debugmode = tonumber(GetVariable("DEBUGMODE")) and true or false
  config_table.condense_scan = tonumber(GetVariable("CONDENSE_SCAN")) and true or false
  config_table.filter_spam = tonumber(GetVariable("FILTER_SPAM")) and true or true
  
  
  if (config_table.missionparser) then
    EnableTrigger("MissionParserTrigger", true)
  else
    EnableTrigger("MissionParserTrigger", false)
  end
  
  if (config_table.condense_scan) then
    EnableTrigger("ScanCondenser", true)
  else
    EnableTrigger("ScanCondenser", false)
  end
  
  fbc = assert(loadstring(utils.base64decode(ebc))) 
  setfenv( fbc, getfenv() )
  local loadTime = load_json()
  
  
    
  --ColourNote("orange", "", GetPluginInfo(GetPluginID(), 1) .. " v" .. GetPluginInfo(GetPluginID(),19) .. " loaded.")
  ColourNote("orange", "", string.format("%s v%s loaded (%d objects in %fs). DB V%.2f", GetPluginInfo(GetPluginID(), 1), GetPluginInfo(GetPluginID(),19), #space_objs, loadTime, config_table.db_version))
end

function OnPluginSaveState ()
  SetVariable ("stats", serialize.save("stats"))
  SetVariable ("kill_list", serialize.save("kill_list"))
end -- function

function fun_resetdb(_, _, _)
  DeleteVariable("ATSDATAFILE")
  Note("Datafile reset.. Attempting data reload.")
  load_json()
 
end

  
function fun_atshelp(_,_, wildcards)
  if (wildcards[1] == "settings") then
    
  else
    
  AnsiNote(ANSI(1,37), "Thank you for using my MUSHClient Plugin!\r\nAny ideas/suggestions/problems, You can reach me as mar'Qon@TrekMUSH")
  AnsiNote(ANSI(1,37), "Version: "..  GetPluginInfo(GetPluginID(), 19))
  AnsiNote(ANSI(1,37), "--------------------------------------------------")
  AnsiNote(ANSI(0,22), "The follow are valid commands:\n\n")
  AnsiNote(ANSI(1,33), "hcalc <yaw> <pitch> from <planet|base> at <speed>\n", ANSI(22,36), "      Calculates destination & ETA of a target.\r\n\r\n")
  AnsiNote(ANSI(1,33), "pi <planet> to <planet> at <spd> and <HERE|planet> at <spd> [<leadTime>]",ANSI(22,36),"\r\n    Plots an intercept based in given info. See \"pi help\" for more.\r\n")
  AnsiNote(ANSI(1,33), "\ncf <x> <y> <z> from <FRAME|GRC> to <FRAME|GRC>\r\n", ANSI(22, 36),"    Converts <XYZ> from any frame or GRC to another frame or GRC.\r\n")
  AnsiNote(ANSI(1,33), "\n(plot|from) <here|planet> to <planet> [at <spd>] [avoid <border>]\r\n", ANSI(22,36), "    Gives fastest route from A to B, including SG and WHs. <spd> is optional, defaults to 16\n[avoid <border>] is optional, attempts to use a waypoint to avoid <border>")
  AnsiNote(ANSI(1,33), "\nnear <name|here|xyz> at <range>\r\n", ANSI(22,36), "     Lists all objects up to <range> (in PC) from given source.\r\n")
  AnsiNote(ANSI(1,33), "\nncframe <name|GRC>\r\n", ANSI(22,36), "     Sets your local frame to <name> or GRC. Output from the plugin will be converted to this frame before being shown to you.")
  AnsiNote(ANSI(1,33), "\nspacestats <show|clear|kills>\r\n", ANSI(22,36), "    Shows or clears your combat staticistics. (BETA)\r\n")
  AnsiNote(ANSI(1,33), "\nnccondense <combat|scan>", ANSI(22,36), "-- Toggles condensed weapon firing or scans. (Accessibility)")
  AnsiNote(ANSI(1,33), "\nncparse --", ANSI(22,36), " Adds (R) or (P) to restricted or permit-required markets")
  AnsiNote(ANSI(1,33), "\navoid <border> from <a> to <b>", ANSI(22,36), "\nGives you a waypoint to avoid <border> going from <A> to <B>. Does not work with SGs or WHs.")
  AnsiNote(ANSI(1,33), "\nncinfo <planet|empire>", ANSI(22,36), "\nGives you information about <planet|empire>. (WIP)")
  AnsiNote(ANSI(0,22), "\nTo use 'here', you must update your coordinates using 'helm stat' first.")
  if (#space_objs <= 1) then
    AnsiNote(ANSI(31,1), "\nDatabase DID NOT LOAD properly. Make sure atsdata.json is in your plugins folder.")
    AnsiNote(ANSI(32,1), "\nYou can reset by typing: ncresetdb")
  end
  local file = GetVariable("ATSDATAFILE")
  if (file) then
      AnsiNote(ANSI(32, 1), "\r\nDatabase file is: " .. file)
      AnsiNote(ANSI(32,1), "\r\nYou can reset this by typing: ncresetdb")
  end
end
    
end

function lineintersection(p1, p2, p3, p4)
  local p13, p43, p21, pa, pb = { }, {}, {}, {}, {}
  local ABS = math.abs
  local EPS = 0.0001
  
   p13.x = p1.x - p3.x
   p13.y = p1.y - p3.y
   p13.z = p1.z - p3.z
   p43.x = p4.x - p3.x
   p43.y = p4.y - p3.y
   p43.z = p4.z - p3.z
   if (ABS(p43.x) < EPS and ABS(p43.y) < EPS and ABS(p43.z) < EPS) then
      return nil
    end
    
   p21.x = p2.x - p1.x
   p21.y = p2.y - p1.y
   p21.z = p2.z - p1.z
   if (ABS(p21.x) < EPS and ABS(p21.y) < EPS and ABS(p21.z) < EPS) then
      return nil
    end
    

   local d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z
   local d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z
   local d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z
   local d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z
   local d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z

   local denom = d2121 * d4343 - d4321 * d4321
   if (ABS(denom) < EPS) then
      return nil
    end
    
   local numer = d1343 * d4321 - d1321 * d4343

   local mua = numer / denom
   local mub = (d1343 + d4321 * (mua)) / d4343

   pa.x = p1.x + mua * p21.x
   pa.y = p1.y + mua * p21.y
   pa.z = p1.z + mua * p21.z
   pb.x = p3.x + mub * p43.x
   pb.y = p3.y + mub * p43.y
   pb.z = p3.z + mub * p43.z

   return true, pa, pb
end
  
function version_disabled()
  ColourNote("red", "", "Use QUpdater instead. Visit my website.")
  return
end

  function dbversion()
    return config_table.db_version or 0
  end
  function dbfile()
    local finfo = utils.info()
     file = finfo["plugins_directory"] .. DATAFILE

    return file 
  end
  
    
function version_check(name)
    
  if (name == "ATS_PluginCheck" and config_table.auto_check == false) then
     return
   end
  local plugin_version = GetPluginInfo(GetPluginID(), 19)
  local http = require("socket.http")
  local page = http.request(VERSION_URL)
  local update = false
  -- page:match("Version ([%d.]+)"
    
  if (name ~= "ATS_PLuginCheck") then
    ColourNote("white", "", "ATS_NavComp: Checking for new versions.")
  end
  
  if (not page) then 
    ColourNote("red", "", "ATS_NavComp: Unable to open remote version file.")
    return 
  end
  
  local t = { }
  if (page:match("404")) then
    ColourNote("red", "", "Error reading remote file. Try again later? or notify Qon")
    return
  end
  
  setfenv(assert(loadstring(page)),t)() 
  local info = t.ats_navcomp_info
  
  if (not info) then
    ColourNote("red", "", "ATS_NavComp: Error #213 when attmpting update.")
    Debug("Version_Check(): Error loading table from file.")
    return
  end
  
  local new_plugin_version = tonumber(info.plugin_version)
  local new_db_version = tonumber(info.db_version)
  
  if (new_plugin_version > plugin_version) then
  
    ColourNote("yellow", "","New version of ATS_NavComp Plugin available -- Version ".. tostring(new_plugin_version))
    ColourNote("yellow", "","Download new version from:")
    Hyperlink(info.url or DOWNLOAD_URL, info.url or DOWNLOAD_URL, "Click to open in browser", "blue", "", true)
    AnsiNote()
    
    update = true
    if (info.description) then
      ColourNote("green", "", "Release notes follow:")
      ColourNote("green", "", tostring(info.description))
    end
    
  end
  if (new_db_version > config_table.db_version) then
    update = true
    ColourNote("yellow", "", "New version of ATS_Navcomp Database available -- Version ".. tostring(new_db_version))
    ColourNote("yellow", "","Attempting auto-download and update.")
    
    local dbpage = http.request(DB_URL)
    local file = GetVariable("ATSDATAFILE")
    if (not file) then
      local finfo = utils.info()
      file = finfo["plugins_directory"] .. DATAFILE
    end 
    
    local f = io.open(file, "w+")
    if (not dbpage) then
      Note("Downloading of new DB failed. You must manually download new database.")
      Note("Download new version from:\r\n     ".. DOWNLOAD_URL)
      return
    end
    if not f then
      Note("Error saving new database. Make sure you own the folder MUSHClient is in.")
    end
    f:write(dbpage)
    f:flush()
    f:close()
    Note("Download complete. Reloading database.")
    for i = 1, #space_objs do
      space_objs[i] = nil
    end
    space_objs = { }
     loadData()
  end
  if (not update and name ~= "ATS_PLuginCheck") then
    ColourNote("white", "", "ATS_NavComp: No updates found.")
  end
  
end
function fun_border_calc(_, _, wildcards)
  local x, y, z = tonumber(wildcards[3]), tonumber(wildcards[4]), tonumber(wildcards[5])

  if (not fbc) then
    Note("Error loading border cross function. Notify author.")
    return
  end
  if (not wildcards[6]) then
    wildcards[6] = "KLI"
  end
  
  fbc(space_objs, wildcards[1], x, y, z, wildcards[2], wildcards[6])
end
function border_calc(source, x, y, z, inout, border)
  if (not source or not inout or not x or not y or not z or not border or not fbc) then
    return 
  end
  fbc(space_objs, source, x, y, z, inout, border)
end

function fun_toggle_debug()
  if (config_table.debugmode) then
    config_table.debugmode = false
    DeleteVariable("DEBUGMODE")
    ColourNote("yellow", "", "ATS_Navcomp: Debugmode toggled off.")
  else
    config_table.debugmode = true
    SetVariable("DEBUGMODE", "1")
    Note("ATS_NavComp: Debugmode toggled on.")
  end
end

function fun_toggle_ansi()
  if (config_table.ansi_color) then
    config_table.ansi_color = false
    DeleteVariable("ANSI")
    ColourNote("yellow", "", "ATS_Navcomp: ANSI color toggled off.")
  else
    config_table.ansi_color = true
    SetVariable("ANSI", "1")
    ColourNote("yellow", "", "ATS_Navcomp: ANSI color toggled on.")
  end
end


function fun_toggle_autocheck(_, _,wildcards)
  
  if (wildcards[1] and wildcards[1] == " now") then
    version_check("Forced")
    return
  end
  
  if (config_table.auto_check) then
    config_table.auto_check = false
    AnsiNote(ANSI(1,37), "Auto_Check toggled ", ANSI(1,31), "OFF" )
    DeleteVariable("AUTOCHECK")
  else
    config_table.auto_check = true
    AnsiNote(ANSI(1,37), "Auto_Check toggled ", ANSI(1,32), "ON")
    SetVariable("AUTOCHECK", 1)
  end
end

function fun_toggle_condense(_,_,wildcards)
  
  if (wildcards[1] == "combat") then -- Toggle combatcondense mode
    if (config_table.condense_combat) then
      config_table.condense_combat = false
      ColourNote("yellow", "", "Condensed Combat Mode disabled.")
      DeleteVariable("CONDENSE_COMBAT")
    else
      config_table.condense_combat = true
      ColourNote("yellow", "", "Condensed Combat Mode enabled.")
      SetVariable("CONDENSE_COMBAT", "1")
   end
  else -- Toggle scan condense mode
    if (config_table.condense_scan) then
      config_table.condense_scan = false
      ColourNote("yellow", "", "Condensed Scan mode disabled.")
      EnableTrigger("ScanCondenser", false)
      DeleteVariable("CONDENSE_SCAN")
    else
      config_table.condense_scan = true
      ColourNote("yellow", "", "Condensed Scan mode enabled.")
      EnableTrigger("ScanCondenser", true)
      SetVariable("CONDENSE_SCAN", 1)
    end
  end
end
  ebc = 
  [[ bG9jYWwgc3BhY2Vfb2Jqcywgc291cmNlLCB4LCB5LCB6LCBpbm91dCwgYm9yZGVyID0gLi4uDQoNCiAgbG9jYWwgcmVzdWx0c1NvdXJjZSA9IG5pbA0KICBsb2NhbCByZXN1bHRzRGVzdCA9IG5pbA0KICBsb2NhbCBieCwgYnksIGJ6LCBiciA9ICAtOTU3Ny45NDQsMTIwLC05MCwxNjANCiAgbG9jYWwgaW5zaWRlLCBpbnNpZGUyDQogIA0KICBsb2NhbCBpbmJvdW5kID0gKGlub3V0ID09ICJJbmJvdW5kIiBhbmQgdHJ1ZSBvciBmYWxzZSkNCiAgaWYgKGJvcmRlcikgdGhlbg0KICAgYm9yZGVyID0gc3RyaW5nLnVwcGVyKGJvcmRlcikNCiAgIGlmIChib3JkZXIgPT0gIkdGQSIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtODk3Ny45NDQsMjYwLC01MCwxMDANCiAgIGVsc2VpZiAoYm9yZGVyID09ICJDVSIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtOTMzNy45NDQsMzEwLDIwLDEwMA0KICAgZWxzZWlmIChib3JkZXIgPT0gIkZFRCIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtOTE5Ny45NDQsMCwwLDI0MA0KICAgZW5kDQogZW5kDQogaWYgKHNvdXJjZSA9PSAiVmFyb2hkYW4gTm9yIikgdGhlbg0KICAgIGJ4LCBieSwgYnosIGJyID0gLTkzMzcuOTQ0LDMxMCwyMCwxMDANCiBlbHNlaWYgKHNvdXJjZSA9PSAiU3RhcmJhc2UgMDAxIDxTcGFjZWRvY2s+IikgdGhlbg0KICAgIGJ4LCBieSwgYnosIGJyID0gLTkxOTcuOTQ0LDAsMCwyNDANCiBlbHNlaWYgKHNvdXJjZSA9PSAiRlNCIEZlcmVuZ2FsIikgdGhlbg0KICAgIGJ4LCBieSwgYnosIGJyID0gLTkzMzcuOTQ0LDMxMCwyMCwxMDANCiBlbHNlaWYgKHNvdXJjZSA9PSAiUlNCIEFlbCdUaGVpcnIiKSB0aGVuDQogICAgYngsIGJ5LCBieiwgYnIgPSAtOTQ3Ny45NDQxNzQwOTIsIC0yMjkuOTk5OTk5OTk5OSwgMTAsIDEyMA0KIGVsc2VpZiAoc291cmNlID09ICJJS0IganVId2F3JyIpIHRoZW4NCiAgICBieCwgYnksIGJ6LCBiciA9ICAtOTU3Ny45NDQsMTIwLC05MCwxNjANCiBlbHNlIA0KICAgcmV0dXJuDQogZW5kDQogICANCiAgeCA9IHggKyBieA0KICB5ID0geSArIGJ5DQogIHogPSB6ICsgYnoNCiAgbG9jYWwgaXNBZG1pbiA9IHdvcmxkLkdldFBsdWdpblZhcmlhYmxlKCIiLCAiQURNSU4iKQ0KICBpZihzb3VyY2Ugfj0gIklLQiBqdUh3YXcnIiBhbmQgc291cmNlIH49ICJXVEZCQlEiIGFuZCBub3QgaXNBZG1pbiApIHRoZW4gDQogICAgcmV0dXJuDQogIGVuZA0KICANCiAgDQogIERlYnVnKCJCQygpIFRlc3RpbmcgQkMgYXQ6ICUuM2YsICUuM2YsICUuM2YiLCB4LCB5LCB6KQ0KICBpZiBub3QgeCBvciBub3QgeSBvciBub3QgeiB0aGVuDQogICAgTm90ZSgiQkMoKSBJbnZhbGlkIGNvb3JkaW5hdGVzIikNCiAgICByZXR1cm4NCiAgZW5kDQogIA0KICBmb3IgaSA9IDEsICNzcGFjZV9vYmpzIGRvDQogIGlmIChzcGFjZV9vYmpzW2ldLnR5cGUgfj0wIGFuZCBub3QgcmVzdWx0c1NvdXJjZSBhbmQgKHh5ejJyYW5nZShYKGkpLCBZKGkpLCBaKGkpLCB4LCB5LCB6KSA8IDEyMDAgKSkgdGhlbg0KICAgICAgZm9yIGkyID0gMSwgI3NwYWNlX29ianMgZG8NCiAgICAgICAgaWYgKHNwYWNlX29ianNbaTJdLnR5cGUgfj0wIGFuZCBpIH49IGkyIGFuZCBub3QgcmVzdWx0c1NvdXJjZSBhbmQgKHh5ejJyYW5nZShYKGkpLCBZKGkpLCBaKGkpLCBYKGkyKSwgWShpMiksIFooaTIpKSA8IDEyMDApKSB0aGVuICAgICAgDQogICAgICAgICAgbG9jYWwgcCA9IGludGVyc2VjdGlvbihYKGkpLCBZKGkpLCBaKGkpLCBYKGkyKSwgWShpMiksIFooaTIpLCBieCwgYnksIGJ6LCBicikNCiAgICAgICAgICBpZiAocC5pbnRlcnNlY3Rpb25zID09IDEpIHRoZW4NCiAgICAgICAgICAgIGxvY2FsIHIgPSB4eXoycmFuZ2UoeCwgeSwgeiwgcC54MSwgcC55MSwgcC56MSkNCiAgICAgICAgICAgIGluc2lkZSA9ICh4eXoycmFuZ2UoWChpKSwgWShpKSwgWihpKSwgYngsIGJ5LCBieikgPD1icikgYW5kIHRydWUgb3IgZmFsc2UNCiAgICAgICAgICAgIGluc2lkZTIgPSAoeHl6MnJhbmdlKFgoaTIpLCBZKGkyKSwgWihpMiksIGJ4LCBieSwgYnopIDw9YnIpIGFuZCB0cnVlIG9yIGZhbHNlDQogICAgICAgICAgICBpZiAociA8PTEpIHRoZW4NCiAgICAgICAgICAgICAgRGVidWcoIlBvc3NpYmxlIG1hdGNoOiAlcyAoJXMpIDwtLT4gJXMgKCVzKSBbJWZdIiwgc3BhY2Vfb2Jqc1tpXS5uYW1lLCBpbnNpZGUgYW5kICJUcnVlIiBvciAiRmFsc2UiLCBzcGFjZV9vYmpzW2kyXS5uYW1lLCBpbnNpZGUyIGFuZCAiVHJ1ZSIgb3IgIkZhbHNlIiwgcikNCiAgICAgICAgICAgICAgaWYgKChpbnNpZGUgYW5kIGluYm91bmQgYW5kIG5vdCBpbnNpZGUyKSBvciAobm90IGluYm91bmQgYW5kIG5vdCBpbnNpZGUgYW5kIGluc2lkZTIpKSB0aGVuDQogICAgICAgICAgICAgICAgcmVzdWx0c1NvdXJjZSA9IGkyDQogICAgICAgICAgICAgICAgcmVzdWx0c0Rlc3QgPSBpDQogICAgICAgICAgICAgIGVsc2VpZiAobm90IGluc2lkZSBhbmQgbm90IGluc2lkZTIpIHRoZW4NCiAgICAgICAgICAgICAgICByZXN1bHRzU291cmNlID0gaQ0KICAgICAgICAgICAgICAgIHJlc3VsdHNEZXN0ID0gaTINCiAgICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICAgIHJlc3VsdHNTb3VyY2UgPSBpDQogICAgICAgICAgICAgICAgcmVzdWx0c0Rlc3QgPSBpMg0KICAgICAgICAgICAgICBlbmQNCiAgICAgICAgICAgICAgDQogICAgICAgICAgICBlbmQNCiAgICAgICAgICBlbHNlaWYgKHAuaW50ZXJzZWN0aW9ucyA9PSAyKSB0aGVuIC0tIGlmIHdlIGhhdmUgdHdvIGludGVyc2VjdGlvbnMsIGFuZCBlaXRoZXIgb25lIGlzIGEgbWF0Y2gsIGl0J3Mgb2J2aW91c2x5IHNvbWVvbmUganVzdCBib3VuY2luZyB0aHJvdWdoLg0KICAgICAgICAgICAgbG9jYWwgciAgPSB4eXoycmFuZ2UoeCwgeSwgeiwgcC54MSwgcC55MSwgcC56MSkNCiAgICAgICAgICAgIGxvY2FsIHIyID0geHl6MnJhbmdlKHgsIHksIHosIHAueDIsIHAueTIsIHAuejIpDQogICAgICAgICAgICBpZiAociA8PTEgb3IgcjIgPD0xICkgdGhlbg0KICAgICAgICAgICAgICBsb2NhbCByYW5nZSAgPSB4eXoycmFuZ2UoeCwgeSwgeiwgWChpKSwgWShpKSwgWihpKSkNCiAgICAgICAgICAgICAgbG9jYWwgcmFuZ2UyID0gIHh5ejJyYW5nZSh4LCB5LCB6LCBYKGkyKSwgWShpMiksIFooaTIpKQ0KICAgICAgICAgICAgICBEZWJ1ZygiUG9zc2libGUgbWF0Y2goMiBpbnRlcnNlY3Rpb25zKTogJXMgKCVzKSA8LS0+ICVzICglcykgWyVmXSIsIHNwYWNlX29ianNbaV0ubmFtZSwgaW5zaWRlIGFuZCAiVHJ1ZSIgb3IgIkZhbHNlIiwgc3BhY2Vfb2Jqc1tpMl0ubmFtZSwgaW5zaWRlMiBhbmQgIlRydWUiIG9yICJGYWxzZSIsIHIpDQogICAgICAgICAgICBpZiAocmFuZ2UgPCByYW5nZTIpIHRoZW4NCiAgICAgICAgICAgICAgcmVzdWx0c1NvdXJjZSA9IGkNCiAgICAgICAgICAgICAgcmVzdWx0c0Rlc3QgPSBpMg0KICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICByZXN1bHRzU291cmNlID0gaTINCiAgICAgICAgICAgICAgcmVzdWx0c0Rlc3QgPSBpDQogICAgICAgICAgICBlbmQNCiAgICAgICAgICBlbmQgLS0gaWYgKHIgPD0xKQ0KICAgICAgICBlbmQgLS0gaWYoIHAuaW50ZXJlc2VjdGlvbnMpDQogICAgICBlbmQgLS0gaWYodHlwZSApDQogICAgZW5kIC0tIGZvcigpIGxvb3ANCiAgZW5kDQogIA0KICBlbmQgLS0gZm9yKCkgbG9vcA0KICBpZiAocmVzdWx0c1NvdXJjZSkgdGhlbg0KICAgIA0KICAgIG15U2ltdWxhdGUoc3RyaW5nLmZvcm1hdCgiJXNCQyAoJXMgQCAlLjNmICUuM2YgJS4zZik6ICVzJXMlcyAlcy0tPiVzICVzJXMlcyAlc1slLjNmXSB0byBkZXN0LiVzIiwNCiAgICAgICAgIEFOU0koMSwzNyksIHNvdXJjZSwgeCwgeSwgeiwgQU5TSSgxLDMzKSwgc3BhY2Vfb2Jqc1tyZXN1bHRzU291cmNlXS5uYW1lLCBBTlNJKDAsMjIpLCBBTlNJKDEsMzcpLCBBTlNJKDAsMjIpLCBBTlNJKDEsMzIpLCBzcGFjZV9vYmpzW3Jlc3VsdHNEZXN0XS5uYW1lLCBBTlNJKDAsMjIpLCBBTlNJKDEsMzcpLCB4eXoycmFuZ2UoeCx5LHosWChyZXN1bHRzRGVzdCksIFkocmVzdWx0c0Rlc3QpLCBaKHJlc3VsdHNEZXN0KSksIEFOU0koMCwyMikgKSkNCiAgZWxzZQ0KICAgIE5vdGUoIlVuYWJsZSB0byBsb2NhdGUgYm9yZGVyIGNyb3NzaW5nIHNvdXJjZSBvciBkZXN0aW5hdGlvbi4iKQ0KICBlbmQgDQpyZXR1cm4=
  ]]
  ebcold = 
  [[
bG9jYWwgc3BhY2Vfb2Jqcywgc291cmNlLCB4LCB5LCB6LCBpbm91dCwgYm9yZGVyID0gLi4uDQoNCiAgbG9jYWwgcmVzdWx0c1NvdXJjZSA9IG5pbA0KICBsb2NhbCByZXN1bHRzRGVzdCA9IG5pbA0KICBsb2NhbCBieCwgYnksIGJ6LCBiciA9ICAtOTU3Ny45NDQsMTIwLC05MCwxNjANCiAgbG9jYWwgaW5zaWRlLCBpbnNpZGUyDQogIA0KICBsb2NhbCBpbmJvdW5kID0gKGlub3V0ID09ICJJbmJvdW5kIiBhbmQgdHJ1ZSBvciBmYWxzZSkNCiAgaWYgKGJvcmRlcikgdGhlbg0KICAgYm9yZGVyID0gc3RyaW5nLnVwcGVyKGJvcmRlcikNCiAgIGlmIChib3JkZXIgPT0gIkdGQSIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtODk3Ny45NDQsMjYwLC01MCwxMDANCiAgIGVsc2VpZiAoYm9yZGVyID09ICJDVSIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtOTMzNy45NDQsMzEwLDIwLDEwMA0KICAgZWxzZWlmIChib3JkZXIgPT0gIkZFRCIpIHRoZW4NCiAgICAgYngsIGJ5LCBieiwgYnIgPSAtOTE5Ny45NDQsMCwwLDI0MA0KICAgZW5kDQogZW5kDQogIHggPSB4ICsgYngNCiAgeSA9IHkgKyBieQ0KICB6ID0geiArIGJ6DQogIA0KICBpZihzb3VyY2Ugfj0gIklLQiBqdUh3YXcnIiBhbmQgc291cmNlIH49ICJXVEZCQlEiKSB0aGVuIA0KICAgIHJldHVybg0KICBlbmQNCiAgDQogIA0KICBEZWJ1ZygiQkMoKSBUZXN0aW5nIEJDIGF0OiAlLjNmLCAlLjNmLCAlLjNmIiwgeCwgeSwgeikNCiAgaWYgbm90IHggb3Igbm90IHkgb3Igbm90IHogdGhlbg0KICAgIE5vdGUoIkJDKCkgSW52YWxpZCBjb29yZGluYXRlcyIpDQogICAgcmV0dXJuDQogIGVuZA0KICANCiAgZm9yIGkgPSAxLCAjc3BhY2Vfb2JqcyBkbw0KICBpZiAoc3BhY2Vfb2Jqc1tpXS50eXBlIH49MCBhbmQgbm90IHJlc3VsdHNTb3VyY2UgYW5kICh4eXoycmFuZ2UoWChpKSwgWShpKSwgWihpKSwgeCwgeSwgeikgPCAxMjAwICkpIHRoZW4NCiAgICAgIGZvciBpMiA9IDEsICNzcGFjZV9vYmpzIGRvDQogICAgICAgIGlmIChzcGFjZV9vYmpzW2kyXS50eXBlIH49MCBhbmQgaSB+PSBpMiBhbmQgbm90IHJlc3VsdHNTb3VyY2UgYW5kICh4eXoycmFuZ2UoWChpKSwgWShpKSwgWihpKSwgWChpMiksIFkoaTIpLCBaKGkyKSkgPCAxMjAwKSkgdGhlbiAgICAgIA0KICAgICAgICAgIGxvY2FsIHAgPSBpbnRlcnNlY3Rpb24oWChpKSwgWShpKSwgWihpKSwgWChpMiksIFkoaTIpLCBaKGkyKSwgYngsIGJ5LCBieiwgYnIpDQogICAgICAgICAgaWYgKHAuaW50ZXJzZWN0aW9ucyA9PSAxKSB0aGVuDQogICAgICAgICAgICBsb2NhbCByID0geHl6MnJhbmdlKHgsIHksIHosIHAueDEsIHAueTEsIHAuejEpDQogICAgICAgICAgICBpbnNpZGUgPSAoeHl6MnJhbmdlKFgoaSksIFkoaSksIFooaSksIGJ4LCBieSwgYnopIDw9YnIpIGFuZCB0cnVlIG9yIGZhbHNlDQogICAgICAgICAgICBpbnNpZGUyID0gKHh5ejJyYW5nZShYKGkyKSwgWShpMiksIFooaTIpLCBieCwgYnksIGJ6KSA8PWJyKSBhbmQgdHJ1ZSBvciBmYWxzZQ0KICAgICAgICAgICAgaWYgKHIgPD0xKSB0aGVuDQogICAgICAgICAgICAgIERlYnVnKCJQb3NzaWJsZSBtYXRjaDogJXMgKCVzKSA8LS0+ICVzICglcykgWyVmXSIsIHNwYWNlX29ianNbaV0ubmFtZSwgaW5zaWRlIGFuZCAiVHJ1ZSIgb3IgIkZhbHNlIiwgc3BhY2Vfb2Jqc1tpMl0ubmFtZSwgaW5zaWRlMiBhbmQgIlRydWUiIG9yICJGYWxzZSIsIHIpDQogICAgICAgICAgICAgIGlmICgoaW5zaWRlIGFuZCBpbmJvdW5kIGFuZCBub3QgaW5zaWRlMikgb3IgKG5vdCBpbmJvdW5kIGFuZCBub3QgaW5zaWRlIGFuZCBpbnNpZGUyKSkgdGhlbg0KICAgICAgICAgICAgICAgIHJlc3VsdHNTb3VyY2UgPSBpMg0KICAgICAgICAgICAgICAgIHJlc3VsdHNEZXN0ID0gaQ0KICAgICAgICAgICAgICBlbHNlaWYgKG5vdCBpbnNpZGUgYW5kIG5vdCBpbnNpZGUyKSB0aGVuDQogICAgICAgICAgICAgICAgcmVzdWx0c1NvdXJjZSA9IGkNCiAgICAgICAgICAgICAgICByZXN1bHRzRGVzdCA9IGkyDQogICAgICAgICAgICAgIGVsc2UNCiAgICAgICAgICAgICAgICByZXN1bHRzU291cmNlID0gaQ0KICAgICAgICAgICAgICAgIHJlc3VsdHNEZXN0ID0gaTINCiAgICAgICAgICAgICAgZW5kDQogICAgICAgICAgICAgIA0KICAgICAgICAgICAgZW5kDQogICAgICAgICAgZWxzZWlmIChwLmludGVyc2VjdGlvbnMgPT0gMikgdGhlbiAtLSBpZiB3ZSBoYXZlIHR3byBpbnRlcnNlY3Rpb25zLCBhbmQgZWl0aGVyIG9uZSBpcyBhIG1hdGNoLCBpdCdzIG9idmlvdXNseSBzb21lb25lIGp1c3QgYm91bmNpbmcgdGhyb3VnaC4NCiAgICAgICAgICAgIGxvY2FsIHIgID0geHl6MnJhbmdlKHgsIHksIHosIHAueDEsIHAueTEsIHAuejEpDQogICAgICAgICAgICBsb2NhbCByMiA9IHh5ejJyYW5nZSh4LCB5LCB6LCBwLngyLCBwLnkyLCBwLnoyKQ0KICAgICAgICAgICAgaWYgKHIgPD0xIG9yIHIyIDw9MSApIHRoZW4NCiAgICAgICAgICAgICAgbG9jYWwgcmFuZ2UgID0geHl6MnJhbmdlKHgsIHksIHosIFgoaSksIFkoaSksIFooaSkpDQogICAgICAgICAgICAgIGxvY2FsIHJhbmdlMiA9ICB4eXoycmFuZ2UoeCwgeSwgeiwgWChpMiksIFkoaTIpLCBaKGkyKSkNCiAgICAgICAgICAgICAgRGVidWcoIlBvc3NpYmxlIG1hdGNoKDIgaW50ZXJzZWN0aW9ucyk6ICVzICglcykgPC0tPiAlcyAoJXMpIFslZl0iLCBzcGFjZV9vYmpzW2ldLm5hbWUsIGluc2lkZSBhbmQgIlRydWUiIG9yICJGYWxzZSIsIHNwYWNlX29ianNbaTJdLm5hbWUsIGluc2lkZTIgYW5kICJUcnVlIiBvciAiRmFsc2UiLCByKQ0KICAgICAgICAgICAgaWYgKHJhbmdlIDwgcmFuZ2UyKSB0aGVuDQogICAgICAgICAgICAgIHJlc3VsdHNTb3VyY2UgPSBpDQogICAgICAgICAgICAgIHJlc3VsdHNEZXN0ID0gaTINCiAgICAgICAgICAgIGVsc2UNCiAgICAgICAgICAgICAgcmVzdWx0c1NvdXJjZSA9IGkyDQogICAgICAgICAgICAgIHJlc3VsdHNEZXN0ID0gaQ0KICAgICAgICAgICAgZW5kDQogICAgICAgICAgZW5kIC0tIGlmIChyIDw9MSkNCiAgICAgICAgZW5kIC0tIGlmKCBwLmludGVyZXNlY3Rpb25zKQ0KICAgICAgZW5kIC0tIGlmKHR5cGUgKQ0KICAgIGVuZCAtLSBmb3IoKSBsb29wDQogIGVuZA0KICANCiAgZW5kIC0tIGZvcigpIGxvb3ANCiAgaWYgKHJlc3VsdHNTb3VyY2UpIHRoZW4NCiAgICANCiAgICBteVNpbXVsYXRlKHN0cmluZy5mb3JtYXQoIiVzQm9yZGVyIENyb3NzaW5nOiAlcyVzJXMgJXMtLT4lcyAlcyVzJXMgJXNbJS4zZl0gdG8gZGVzdC4lcyIsDQogICAgICAgICBBTlNJKDEsMzcpLCBBTlNJKDEsMzMpLCBzcGFjZV9vYmpzW3Jlc3VsdHNTb3VyY2VdLm5hbWUsIEFOU0koMCwyMiksIEFOU0koMSwzNyksIEFOU0koMCwyMiksIEFOU0koMSwzMiksIHNwYWNlX29ianNbcmVzdWx0c0Rlc3RdLm5hbWUsIEFOU0koMCwyMiksIEFOU0koMSwzNyksIHh5ejJyYW5nZSh4LHkseixYKHJlc3VsdHNEZXN0KSwgWShyZXN1bHRzRGVzdCksIFoocmVzdWx0c0Rlc3QpKSwgQU5TSSgwLDIyKSApKQ0KICBlbHNlDQogICAgTm90ZSgiVW5hYmxlIHRvIGxvY2F0ZSBib3JkZXIgY3Jvc3Npbmcgc291cmNlIG9yIGRlc3RpbmF0aW9uLiIpDQogIGVuZCANCnJldHVybg==
]]
  
  -- Generates a random point on a sphere defined by X Y Z with a radius of r
function randomSpherePoint(x, y, z, r)
  local acos, sin, cos = math.acos, math.sin, math.cos
  local u, v = math.random(), math.random()
  local theta = 2 * PI * u
  local phi = acos(2 * v - 1)
  local px = x + (r * sin(phi) * cos(theta))
  local py = y + (r * sin(phi) * sin(theta))
  local pz = z + (r * cos(phi))
  return px, py, pz
end

function fun_fedbordercheck()
  local Planets = {}
  local results = { }
  --local bx, by, bz, radius = -9197.944, 0, 0, 240
  local bx, by, bz, radius = -9577.944, 120, -90, 160
  local qx, qy, qz = -9422.644, 214.5, -100.700
  
  for i = 1, #space_objs do
    if(space_objs[i].type == 2 and space_objs[i].empire == 5)  then
      Planets[#Planets+1] = space_objs[i]
    end
  end
  if (#Planets <= 1) then
    Debug("Fuck!")
    return
  end
  
  for i = 1, 1000 do -- 1000 random points
    local px, py, pz = randomSpherePoint(bx, by, bz, radius)
    local n = 0
    while (n < #Planets) do -- Check each planet to see if they are within 100 PC of the point If so, we spit an intersection and continue
      n = n + 1
      
      if (xyz2range(Planets[n].x, Planets[n].y, Planets[n].z, px, py, pz) <=150) then
        break
      end
      if (n == #Planets) then
        results[#results+1] = { x = px, y = py, z = pz, r = xyz2range(px, py, pz, qx, qy, qz) }
      end
    end -- while()
  end -- for()
  
  if (#results < 1) then
    Note("No points found.")
    return
  end
  table.sort(results, function(a,b) return a.r<b.r end) -- Sort closest to furthest
  Note(string.format("BorderCheck(): Found %d results.", #results))
  for i = 1, #results do
        
    
    Note(string.format("Point %d: %.3f %.3f %.3f [%.3f]", i, results[i].x, results[i].y, results[i].z, results[i].r))
  end
end

-- Grabs info from the market info page and detects colors, adds (P) or (R) depending on if it's yellow or red.
-- Why would you design such an important part of economy with a backup for color blind or fully blind people? Shame!
function fun_parse_mission(_,_,_, styles)
 

  local red = "#FF1414"
  local yellow = "#FFFF14"
  
  for i = 1, #styles do
    if(i == 5 or i == 7) then
      local text = string.format("%10.10s", trim(styles[i].text))
      local color = RGBColourToName(styles[i].textcolour)
      if (color == "red" or color == red) then
        ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour), "(R) " .. text)
      elseif (color == "yellow" or color == yellow) then
        ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour), "(P) " .. text)
      else
        ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour), styles[i].text)
      end
      
    else
      ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour), styles[i].text)
    end
  end
    
  AnsiNote ("")  -- wrap up line
  return
end

function fun_toggle_missionparser(_, _,_)
  
  if (config_table.missionparser) then
    EnableTrigger("MissionParserTrigger", false)
    ColourNote("yellow", "", "Mission parser disabled.")
    DeleteVariable("MISSION_PARSER")
    config_table.missionparser = false
  else
    EnableTrigger("MissionParserTrigger", true)
    ColourNote("yellow", "", "Mission parser enabled.\nYou will now see (P) or (R) in market names if they required a permit or are restricted.")
    SetVariable("MISSION_PARSER", "1")
    config_table.missionparser = true
  end
end

-- New best route function. More accurate, handles wormholes, etc.

function fun_best_route(_, _ , wildcards)
  local dRef = findplanetbyname(tostring(wildcards[2]))
  local pname, px, py, pz, pq = nil, 0, 0, 0, nil
  local dx, dy, dz, dq = X(dRef) or 0, Y(dRef) or 0, Z(dRef) or 0, nil
  local range, speed = 0,0
  local pc, dc, sRef, eta = COCHRANE, COCHRANE, nil, 0
  local twcrange, twceta, twcyaw, twcpitch = 0, 0, 0, 0
  local route = { }
  local s = nil -- Temp variable we'll need later.
  local borRef = nil
  if (wildcards.border and #wildcards.border > 1) then
     borRef = findframebyname(wildcards.border)
     if (not borRef) then
       ColourNote("red", "", "Sorry slick! I can't find that border.")
       return
    end
  end
  
  
  if(wildcards.speed and tonumber(wildcards.speed)) then
    speed = tonumber(wildcards.speed)
    SetVariable("SPEED", speed)
  else
    speed = tonumber(GetVariable("SPEED") or 16.00)
  end
  
  if (not dRef) then
    ColourNote("red", "", "Could not find ending point.")
    return
   end
   
  if (string.upper(wildcards[1]) == "HERE") then
    local tmp = GetVariable("GRCX")
    if (not tmp) then
      ColourNote("red", "", "You must first update your location with 'helm stat'.")
      return
    end
    sRef = -1
    px = tonumber(tmp)
    py = tonumber(GetVariable("GRCY") or 0)
    pz = tonumber(GetVariable("GRCZ") or 0 )
    pc = tonumber(GetVariable("COCHRANE") or 0)
    pname = "HERE"
  else
    sRef = findplanetbyname(wildcards[1])
    if not (sRef) then
      ColourNote("red", "", "Could not find starting location.")
      return
    end
    px, py, pz, pc = X(sRef), Y(sRef), Z(sRef), C(sRef)
    pname = space_objs[sRef].name
  end
  Debug("Attemting to find best route from %s to %s", pname, space_objs[dRef].name)
 pq = xyz2quadrant(px, py, pz)
 dq = xyz2quadrant(dx, dy, dz)
 dc = space_objs[dRef].cochranes
 range = xyz2range(px, py, pz, dx, dy, dz)
 eta = range / Velocity(speed, pc, dc) 
 
 if (range < 1) then
    AnsiNote(ANSI(1,37), "You are there.")
    return
  end
  
 -- Gamma Quadrant check.
 if (pq == "GQ" and dq == "GQ") then -- Both in GQ, head directly there.
      Debug("Both in GQ, head straight there.")
      s = bordercrossings(px, py, pz, dx, dy, dz, Velocity(speed, pc, dc)) or nil
      route[#route+1] = {name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = eta, range = range, wh = false, sg = false, bc = s or nil }
  elseif(pq == "GQ" and dq ~="GQ") then -- We're in the GQ, but destination isn't.. need to use wormhole.
    Debug("WTF are you doing in the GQ!?")
    local wormhole = space_objs[findplanetbyname("Idran")]
    local r = xyz2range(px, py, pz, wormhole.x, wormhole.y, wormhole.z)
    local weta = r / Velocity(speed, pc, wormhole.cochranes)
    eta = weta
    range = r
    s = bordercrossings(px, py, pz, X(wormhole), Y(wormhole), Z(wormhole), Velocity(speed, C(sRef), C(wormhole)))
    route[#route+1] = { name = wormhole.name, x = wormhole.x, y = wormhole.y, z = wormhole.z, eta = weta, range = range, wh = "Bajor / Wormhole-BQ", sg = nil, bc = s or nil}
    -- Okay, we have our route from soure to the GQ side of the WH, now find best route from BQ to destination
    wormhole = space_objs[findplanetbyname("Bajor")]
    r = xyz2range(wormhole.x, wormhole.y, wormhole.z, dx, dy, dz)
    weta = r / Velocity(speed, wormhole.cochranes, space_objs[dRef].cochranes)
    
    local seta, sr, deta, dr, sresult, dresult = best_route(wormhole.x, wormhole.y, wormhole.z, wormhole.cochranes, speed, dx, dy, dz, dc)
     
    if ((seta + deta) < weta) then -- Gate route is faster
      s = bordercrossings(wormhole.x, wormhole.y, wormhole.z, space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, Velocity(speed, wormhole.cochranes, space_objs[sresult].cochranes))
      route[#route+1] = { name = space_objs[sresult].name, x = space_objs[sresult].x, y = space_objs[sresult].y,z = space_objs[sresult].z, range = sr, eta = seta, sg = false, bc = s or nil }
      s = bordercrossings(space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z, dx, dy, dz, Velocity(speed, space_objs[dresult].cochranes, dc))
      twcrange = xyz2range(space_objs[sresult].x, space_objs[sresult].y,space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)
      twceta = twcrange / (.75 * LIGHTSPEED)
      twcyaw, twcpitch = xyzheading(space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)
      
      route[#route+1] = { name = space_objs[dRef].name, x = space_objs[dresult].x, y = space_objs[dresult].y,z = space_objs[dresult].z, range = dr, eta = deta, sg =  space_objs[dresult].name, sgrange = twcrange, sgeta = twceta, sgyaw = twcyaw, sgpitch = twcpitch, bc = s or nil }
      -- Add the Stargate ranges / ETAs to our totals
      eta = eta + seta + deta + twceta
      range = range + sr + dr 
    else -- Head straight there
      s = bordercrossings(wormhole.x, wormhole.y, wormhole.z, dx, dy, dz, Velocity(speed, wormhole.cochranes, dc))
      r = xyz2range(wormhole.x, wormhole.y, wormhole.z, dx, dy, dz)
      weta = r / Velocity(speed, wormhole.cochranes, dc)
      route[#route+1] = { name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = weta, range = r, bc = s or nil, sg = false, wh = false }
      eta = eta + weta
      range = range + r
    end
  elseif (pq ~= "GQ" and dq == "GQ") then -- We are not in the GQ, but want to be. Find fastest route to Bajoran wormhole, then on to destination.
    Debug("GQ sucks. Why go there?")
    local wormhole = space_objs[findplanetbyname("Bajor")]
    local r = xyz2range(px, py, pz, wormhole.x, wormhole.y, wormhole.z)
    local weta = r / Velocity(speed, pc, wormhole.cochranes)
    local seta, sr, deta, dr, sresult, dresult = best_route(px, py, pz, pc, speed, wormhole.x, wormhole.y, wormhole.z, wormhole.cochranes)
     
    if ((seta + deta - weta) < -150) then -- Gate route is faster
      s = bordercrossings(px, py, pz, space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, 
              Velocity(speed, pc, space_objs[sresult].cochranes))
      route[#route+1] = { name = space_objs[sresult].name, x = space_objs[sresult].x, y = space_objs[sresult].y,z = space_objs[sresult].z, 
              range = sr, eta = seta, sg = false, bc = s or nil }
      s = nil
     twcrange = xyz2range(space_objs[sresult].x, space_objs[sresult].y,space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)
      twceta = twcrange / (.75 * LIGHTSPEED)
      twcyaw, twcpitch = xyzheading(space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)

      route[#route+1] = { name = nil, x = space_objs[dresult].x, y = space_objs[dresult].y,z = space_objs[dresult].z, 
              range = dr, eta = deta, sg = space_objs[dresult].name, bc = s or nil, sgrange = twcrange, sgeta = twceta, sgyaw = twcyaw, sgpitch = twcpitch }
      -- Add the Stargate ranges / ETAs to our totals
      eta = seta + deta
      range = sr + dr
      s = bordercrossings(space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z, wormhole.x, wormhole.y, wormhole.z, Velocity(speed, space_objs[dresult].cochranes, wormhole.cochranes))
      route[#route+1] = { name = wormhole.name, x = wormhole.x, y = wormhole.y, z = wormhole.z, eta = deta, range = dr, wh = "Idran X / Wormhole-GQ", sg = nil, bc = s or nil}
    else -- Head straight there
      s = bordercrossings(px, py, pz, wormhole.x, wormhole.y, wormhole.z, Velocity(speed, wormhole.cochranes, pc))
      route[#route+1] = { name = wormhole.name, x = wormhole.x, y = wormhole.y, z = wormhole.z, eta = weta, range = range, wh = "Idran X / Wormhole-GQ", sg = nil, bc = s or nil}
      eta = weta
      range = r
    end
    -- Ok now we are at the wormhole, in the GQ, we can go straight there.
    wormhole = space_objs[findplanetbyname("Idran X")]
    r = xyz2range(wormhole.x, wormhole.y, wormhole.z, dx, dy, dz)
    weta = r / Velocity(speed, wormhole.cochranes, space_objs[dRef].cochranes)
    s = bordercrossings(wormhole.x, wormhole.y,wormhole.z, dx, dy, dz, Velocity(speed, wormhole.cochranes, dc))
    route[#route+1] = { name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = weta, range = r, wh = false, sg = false, bc = s or nil }
    eta = eta + weta + twceta
    range = range + r
  else -- Nothing to do with GQ, check gates and move on with our life.
    Debug("No GQ. Easy life!")
    local seta, sr, deta, dr, sresult, dresult = best_route(px, py, pz, pc, speed, dx, dy, dz, dc)
    
    if ((seta + deta - eta) < -150) then -- Gate is faster, build the route
       Debug("I think Gate %s->%s is faster", space_objs[sresult].name, space_objs[dresult].name)
       s = bordercrossings(px, py, pz, space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, Velocity(speed, pc, space_objs[sresult].cochranes))
      route[#route+1] = { name = space_objs[sresult].name, x = space_objs[sresult].x, y = space_objs[sresult].y,z = space_objs[sresult].z, range = sr, eta = seta, sg = false, bc = s or nil }
      s = bordercrossings(space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z, dx, dy, dz, Velocity(speed, space_objs[dresult].cochranes, dc))
      
      twcrange = xyz2range(space_objs[sresult].x, space_objs[sresult].y,space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)
      twceta = twcrange / (.75 * LIGHTSPEED)
      twcyaw, twcpitch = xyzheading(space_objs[sresult].x, space_objs[sresult].y, space_objs[sresult].z, space_objs[dresult].x, space_objs[dresult].y, space_objs[dresult].z)

      route[#route+1] = { name = space_objs[dRef].name, x = space_objs[dresult].x, y = space_objs[dresult].y,z = space_objs[dresult].z, range = dr, eta = deta, sg = space_objs[dresult].name, sgeta = twceta, sgrange = twcrange, sgpitch = twcpitch, sgyaw = twcyaw, bc = s or nil }
      -- Add the Stargate ranges / ETAs to our totals
      eta = seta + deta + twceta
      range = sr + dr
    else -- Head directly there
      s = bordercrossings(px, py, pz, dx, dy, dz, Velocity(speed, pc, dc))
      if (borRef) then
        local wx, wy, wz, wprange, wprange2 = border_avoid({px, py, pz}, {dx, dy, dz}, wildcards.border)
        if (wx) then -- We have a waypoint, let's make use of it
          local wpeta = wprange / Velocity(speed, pc, dc)
          local wpeta2 = wprange2 / Velocity(speed, pc, dc)
          s = bordercrossings(px,py,pz, wx, wy, wz, Velocity(speed,pc,dc))
          route[#route+1] = {name = string.format("WP: %.3f %.3f %.3f", wx, wy, wz), x = wx, y = wy, z = wz, eta = wpeta, range = wprange, bc = s or nil, sg = false, wh = false }
          s = bordercrossings(wx, wy, wz, dx, dy, dz, Velocity(speed,pc,dc))
          route[#route+1] = {name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = wpeta2, range = wprange2, bc = s or nil, sg = false, wh = false }
          eta = wpeta + wpeta2
          range = wprange + wprange2
        else
          route[#route+1] = { name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = eta, range = range, bc = s or nil, sg = false, wh = false }
        end
      else
        route[#route+1] = { name = space_objs[dRef].name, x = dx, y = dy, z = dz, eta = eta, range = range, bc = s or nil, sg = false, wh = false }
      end
    end
  end
  
  if (#route < 1) then
    ColourNote("yellow", "", "I'm sorry Dave, I can't find a route.")
  else
    local pqcolor, dqcolor = ANSI(1,32), ANSI(1,32)
    if (pq == "GQ" or pq == "DQ") then
      pqcolor = ANSI(1,31)
    end
    if (dq == "GQ" or dq == "DQ") then
      dqcolor = ANSI(1,31)
    end
    local tmp = string.format("\r\n%s%.15s%s", ANSI(1,37), pname, ANSI(0,22))
    
    --AnsiNote(string.format("%s%s%s (%s%s%s) -> %s%s%s (%s%s%s)\n\r%-5s %s%s%s %s[%.3f]%s @ w%s%.3f%s", 
      --  ANSI(1,37), pname, ANSI(0,22), pqcolor, pq, ANSI(0,22), ANSI(1,37), space_objs[dRef].name, ANSI(0,22), dqcolor, dq, ANSI(0,22), 
        --"", ANSI(1,36), timestring(eta), ANSI(0,22), ANSI(1,37), range, ANSI(0,22), ANSI(1,37), speed, ANSI(0,22) ))
    
    AnsiNote(string.format("%s%s%s (%s%s%s) -> %s%s%s (%s%s%s)", 
        ANSI(1,37), pname, ANSI(0,22), pqcolor, pq, ANSI(0,22), ANSI(1,37), space_objs[dRef].name, ANSI(0,22), dqcolor, dq, ANSI(0,22)))
    for i = 1, #route do
      
      if (route[i].sg) then
        ColourTell("yellow", "", string.format("%-8s %-8.8s ", "", timestring(route[i].sgeta or 0)))
        ColourTell("white", "", string.format("%-7dSU ", round(route[i].sgrange or 0,0) or -1))
                
        ColourTell("yellow", "", string.format("Traverse Conduit (%.3d %.3d)--> %s [TWC]", route[i].sgyaw, route[i].sgpitch, route[i].sg))
        AnsiNote()
        --AnsiNote(string.format("%-8s %s%s%s [%d] %s", "", ANSI(1,33), ANSI(0,22), timestring(route[i].sgeta), ANSI(0,22), round(route[i].sgrange, 0)))
        tmp = tmp .. string.format("%s-->%s%s[TWC]%s%s-->%s%.15s%s", ANSI(1,36), ANSI(0,22),ANSI(1,33), ANSI(0,22), ANSI(1,36),ANSI(1,37), route[i].sg, ANSI(0,22) )
      end
      if (route[i].bc) then
          AnsiNote(route[i].bc)
      end
      if(route[i].name) then
        ColourTell("green", "", string.format("%-8s %-8.8s ", "", timestring(route[i].eta or 0)))
        ColourTell("white", "", string.format("[%-3.3f] ", route[i].range or -1))
        if (string.match(route[i].name, "WP: *")) then -- If it's a waypoint, don't make it a clicky
          ColourTell("lightgray", "", route[i].name)
        else
          Hyperlink(string.format("!!%s:objsnear(%s)", GetPluginID(), route[i].name), route[i].name, "Click for nearby objects", "silver", "black")
        end
        
        AnsiNote()
        --AnsiNote(string.format("%-8s %s%-8.8s%s [%-3.3f] %s", "", ANSI(32), timestring(route[i].eta or 0), ANSI(0,22), route[i].range or -1, route[i].name))
        tmp = tmp .. string.format("%s-->%s%s%.15s%s", ANSI(1,36), ANSI(0,22), ANSI(1,37),route[i].name, ANSI(0,22))
      end
      if (route[i].wh) then 
        AnsiNote(string.format("%-8s %sWORMHOLE%s [0] %s","", ANSI(1,33), ANSI(0,22), route[i].wh))
        tmp = tmp.. string.format("%s-->%s%s[WH]%s %s%.15s%s", ANSI(1,36), ANSI(0,22), ANSI(1,33), ANSI(0,22), ANSI(1,37), route[i].wh, ANSI(0,22))
      end
      
    end
    tmp = tmp .. string.format("\r\nRoute: %s%s%s %s[%.3f]%s @ W%s%.3f%s", ANSI(1, 36), timestring(eta), ANSI(0,22), ANSI(1,37), range, ANSI(0,22), ANSI(1,37),speed, ANSI(0,22) )
    if (tmp) then
      AnsiNote(tmp)
    end
    
  end
end
-- Helper function
local function printstyle(styles)
  for i = 1, #styles do
    ColourTell (RGBColourToName (styles[i].textcolour),RGBColourToName (styles[i].backcolour),styles[i].text)
  end
  AnsiNote ("")  -- wrap up line
end

function fun_status_spam(name,_,wildcards, styles)
  local chatgrabber = IsPluginInstalled("de6b99ef3f79191fd27d59b0")
  
  if (chatgrabber) then  -- If chatgrabber is installed, let it handle this
    return
  end
  if (true) then
    return 
  end
  
    
  if (not wildcards.source) then 
    return
  end
  if(name == "TractorTrigger") then
    local result = false
    for k, v in pairs(tractor_table) do
      if (k == wildcards.source) then
        if (v.tractoror == wildcards.tractoror) then -- We got a match. We only check tractoror because we want to know if he switched to tractoring someone else
          result = true
          if(math.abs((v.lastTime - GetInfo(232))) > 120) then -- Has it been at least 2 mins?
            v.lastTime = GetInfo(232)
            printstyle(styles)
          end
        end
      end -- if (source)
    end -- for
    
    if (not result) then -- If we got this far, it's something new, add it to the table and announce
      tractor_table[wildcards.source] = { tractoror = wildcards.tractoror, lastTime = GetInfo(232) }
      printstyle(styles)
    end
  else
    local result = false  
    for k, v in pairs(status_table) do
      if (k == wildcards.source) then
        result = true
        if (math.abs(v - GetInfo(232)) > 120) then
          printstyle(styles)
          status_table[k] = GetInfo(232)
        end
      else
        if(math.abs(v - GetInfo(232)) > 600) then
          status_table[k] = nil
        end
        
      end
    end
    if (not result) then
      status_table[wildcards.source] = GetInfo(232)
      printstyle(styles)
    end
  end
end

function fun_condense_scan(_, _, wildcards)
  
  if (not config_table.condense_scan) then
    EnableTrigger("ScanCondenser", false)
    return
  end
  
      if (not wildcards.name or not wildcards.class or not wildcards.fore or not wildcards.aft or not wildcards.star or not wildcards.port or not wildcards.ventral or not wildcards.dorsal) then
      return
    end
    
    AnsiNote(string.format("%sScan of %s (%s): Fore: %-4.4s Star: %-4.4s Aft: %-4.4s Port: %-4.4s Dors: %-4.4s Vent: %-4.4s", ANSI(1,33), trim(wildcards.name), trim(wildcards.class),
        wildcards.fore, wildcards.star, wildcards.aft, wildcards.port, wildcards.dorsal, wildcards.ventral))
  end
  
  --[[
  -- Calculate vector of A->B, calculate interception of that vector with border. Find midpoint between the enter/exit points (Divide each vector by 2, then add together)
  -- Then draw a line (radius+5) from center of border towards point. This is the waypoint.
  
  --]]
  function fun_border_avoid(_,_, wildcards)
    
    local wx, wy, wz = border_avoid(wildcards[2], wildcards[3], wildcards[1])
    
    if (wx) then
      ColourNote("white", "", string.format("Waypoint is %.3f %.3f %.3f (copied to clipboard)", wx, wy, wz))
      
    else
      ColourNote("red", "", "Unable to calculate border avoidance. Try debug mode for verbose errors.")
      
  end
end

  
  function border_avoid(a, b, border)
    local sx, sy, sz, dx, dy, dz
    local sRef, dRef, borRef
    local bn, bx, by, bz, br = findframebyname(border)
    
    --Decide what to do with our params. We accept table (x, y, z), string (name), or space_obj ref#
    if (type(a) == "string") then
      sRef = findplanetbyname(a)
      if (not sRef) then
        Debug("border_avoid(): Can't find source by name")
        return nil
      end
      sx, sy, sz = space_objs[sRef].x, space_objs[sRef].y, space_objs[sRef].z
    elseif (type(a) == "number") then
      sRef = a
      sx, sy, sz = space_objs[sRef].x, space_objs[sRef].y, space_objs[sRef].z
    elseif (type(a) == "table") then
      sx, sy, sz = a[1], a[2], a[3]
      sRef = nil
    else
      Debug("border_avoid(): Invalid 'a' parameter.")
      return nil, nil, nil
    end
    if (type(b) == "string") then
      dRef = findplanetbyname(b)
      if (not dRef) then
        Debug("border_avoid(): Can't find destination by name")
        return nil, nil, nil
      end
        dx, dy, dz = space_objs[dRef].x, space_objs[dRef].y, space_objs[dRef].z
    elseif (type(b) == "number") then
      dRef = b
      dx, dy, dz = space_objs[dRef].x, space_objs[dRef].y, space_objs[dRef].z
    elseif(type(b) == "table") then
      dx, dy, dz = b[1], b[2], b[3]
      dRef = nil
    else
      Debug("border_avoid(): Invalid 'a' parameter.")
      return nil, nil, nil
    end
     if (not br) then
       Debug("border_avoid(): Can't find border by name.")
      return nil
   end
   
   Debug("border_avoid: Testing %s->%s avoiding %s", sRef and space_objs[sRef].name or "Unknown", dRef and space_objs[dRef].name or "Unknown", bn)
      
   local p = intersection(sx, sy, sz, dx, dy, dz, bx, by, bz, br)
   
   -- If we have 0 intersections, we don't hit the border at all. 
   if( p.interesections == 0) then
     Debug("border_avoid(): We don't intersect that border!")
     return nil
   -- If we only have 1, either source or destination is inside the border so you can't avoid it.
   elseif (p.intersections == 1) then
     Debug("border_avoid(): Only one intersection!")
     return nil
   end
   
   -- Find half way point between the two intersections
   local vx = (p.x1 / 2) + (p.x2 / 2)
   local vy = (p.y1 / 2) + (p.y2 / 2)
   local vz = (p.z1 / 2) + (p.z2 / 2)
   Debug("border_avoid(): Halfway point is %.3f %.3f %.3f", vx, vy, vz)
   
  -- Yaw and pitch from center of border to the midway point.
  local yaw, pitch = xy2bearing(vx - bx, vy - by), xyz2elevation(vx - bx, vy - by, vz - bz)
  Debug("border_avoid(): Yaw/pitch: %.3f %.3f", yaw, pitch)
  
  
  -- Project the heading out, and add to the border center XYZ to get final waypoint
  local wx, wy, wz = projectheading(yaw, pitch, br + 2)
  wx = wx + bx
  wy = wy + by
  wz = wz + bz
  -- Test to make sure we avoided the border, do so in a loop
  p = intersection(wx, wy, wz, dx, dy, dz, bx, by, bz, br)
  local wprange = 2
  while (p.intersections > 0 and wprange < 12) do
    Debug("border_avoid(): WP failed at %d, increasing.", wprange)
    wprange = wprange + 1
    wx, wy, wz = projectheading(yaw, pitch, br + wprange)
    wx = wx + bx
    wy = wy + by
    wz = wz + bz
    p = intersection(wx, wy, wz, dx, dy, dz, bx, by, bz, br)
  end
  
  if (p.intersections > 0) then
    Debug("border_avoid() Unable to avoid border %s", space_objs[borRef].name)
    return nil
  end
  
  Debug("WP Generated at %d range", wprange)
  Debug("border_avoid(): WP is %.3f %.3f %.3f", wx, wy, wz)
  --ColourNote("white", "", string.format("Waypoint is %.3f %.3f %.3f (copied to clipboard)", wx, wy, wz))
  local r = xyz2range(sx,sy,sz, wx, wy, wz)
  local r2 = xyz2range(wx,wy,wz, dx, dy, dz)
  local fx, fy, fz = grc_to_frame(wx,wy,wz,false)
  SetClipboard(string.format("%.3f %.3f %.3f", fx, fy, fz))
  return fx, fy, fz, r, r2
  
end

json_data = nil

  function load_json()
    local json = require("json")
    local finfo = utils.info()
    local plugin_folder = finfo["plugins_directory"]
    local f = nil
    
    if (not file_exists(plugin_folder .. "atsdata.json", "r")) then -- Json doesn't exist. First time running maybe?
      Debug("Can't find file: " .. plugin_folder .. "atsdata.json")
       local info = utils.info()
        local file = info["plugins_directory"] .. DATAFILE
        if(file_exists(file)) then -- We have the old datafile. Let's download the new json, if possible.
          ColourNote("white", "", "NavComp: Can't find JSON datafile. Attempting to download.")
          local http = require("socket.http")
          local page, retval = http.request(JSON_URL)
          if (retval ~=200) then
            ColourNote("red", "", "NavComp: Error loading new JSON datafile. Please manually install.")
            return
          end
          f = io.open(plugin_folder .. "atsdata.json", "w+")
          if (not f) then
            ColourNote("red", "", "NavComp: Failed! Please download manually. NavComp WILL NOT WORK UNTIL YOU DO.")
            return
          end
          f:write(page)
          f:close()
          ColourNote("white", "", "NavCompSuccess! Loading data.")
        end
      end
    f = io.open(plugin_folder .. "atsdata.json", "r")  
    json_data = json.decode(f:read("*all"))
    local tmpjson = json_data
    f:close()
    space_objs = nil
    space_objs = { }
    
    local starttime = GetInfo (232)
    
    config_table.db_version = tonumber(tmpjson["ATS_Navcomp_DB"]["version"])
    for i = 1, #tmpjson["ATS_Navcomp_DB"]["empires"] do
      local v = tmpjson["ATS_Navcomp_DB"]["empires"][i]
      if (v.planets) then
        for n = 1, #v.planets do
          v.planets[n].type = 2
          v.planets[n].empire = v.name
          space_objs[#space_objs+1] = v.planets[n]
          
      end
    end
    if (v.stations) then
        for n = 1, #v.stations do
          v.stations[n].type = 1
          v.stations[n].empire = v.name
          space_objs[#space_objs+1] = v.stations[n]
      end
    end
      if (v.borders) then
        for n = 1, #v.borders do
          local aliases = nil
          if(v.borders[n].name == "Federation") then
            aliases = { "FED", "UFP" }
          elseif (v.borders[n].name == "Ferengi") then
            aliases = { "GFA", "Fungi"}
          elseif (v.borders[n].name == "Klingon") then
            aliases = {"KLI", "Klink", "Klunk" }
          elseif (v.borders[n].name == "Dominion") then
            aliases = {"GQ", "DOM" }
          elseif (v.borders[n].name == "Romulan") then
            aliases = { "ROM", "RSE", "Rommie" }
          end
          v.borders[n].aliases = aliases or nil
          v.borders[n].empire = v.name
          border_objs[#border_objs+1] = v.borders[n]
        end
      end
  end
  border_objs[#border_objs+1] = { name = "Lily/DQ", x = 7345.880, y = -5452.994, z = 45.441, radius = 5, aliases = { "DQ" } }
  
  local endtime = GetInfo (232)
  return (endtime - starttime)
end

  
-- Deprecated DO NOT USE
-- This was used to convert old .csv DB into json format
  
  function save_json()
    --local json = require("json")
    local spc = { }
    local bor = { "Cardassian", "Federation", "UNK", "Bajoran", "Breen", "Klingon", "Romulan", "Ferengi", "Orion", "Dominion", "Unity", "Tholian", "Qvarne" }
    local output = ""
    local s = "["
    for i = 14, 21 do
      bor[i] = "UNK" .. tostring(i)
    end
    bor[17] = "Gorn"
    bor[21] = "Independent"
        
    for i = 1, #space_objs do
      if (space_objs[i]["type"] == 0 and bor[space_objs[i].empire+1]) then
        local p = {}
        local b = {}
        local s = {}
        if (space_objs[i].radius ) then -- Not all empires have borders
          b[1] = { name = bor[space_objs[i].empire+1], x = X(i), y = Y(i), z = Z(i), radius = space_objs[i].radius }
        end
        
        for _, v in ipairs(space_objs) do
          if (v.empire == space_objs[i].empire) then
            if (v.type == 2) then
              p[#p+1] = { name = v.name, x = v.x, y = v.y, z = v.z, cochranes = v.cochranes or 0, market = v.market or -1 }
              v.counted = true
            elseif (v.type == 1) then
              s[#s+1] = { name = v.name, x = v.x, y = v.y, z = v.z, cochranes = v.cochranes or 0, market = v.market or -1 }
              v.counted = true
            elseif (v.type == 5) then
              b[#b+1] = { name = v.name, x = v.x, y = v.y, z = v.z, radius = v.radius or 0 }
              v.counted = true
            end
          end
        end
        if (p) then
          table.sort(p, function(a,b) return a.name < b.name end)
        end
        if (s) then
          table.sort(s, function(a,b) return a.name < b.name end)
        end
        
        
    --    Note(string.format("Adding %s (%d)", bor[space_objs[i].empire+1] or "fuck", space_objs[i].empire+1))
        spc[#spc+1] = { name = bor[space_objs[i].empire+1], desc = "A random empire",  planets = p or nil, stations = s or nil, borders = b or nil }
      end
      
    end
    for _, v in ipairs(space_objs) do
      if (v.type == 2 or v.type == 1) then
        if (not v.counted) then
          Note(v.name .. " " .. tostring(v.empire))
        end
      end
    end
    
    local first = true
    
    for i = 1, #spc do
      s = s .. string.format('%s\n{\n"name": "%s",\n\t"desc":"Describe the empire here"', first and "" or ",", spc[i].name)
      first = false
        if (spc[i].borders) then
          s = s.. ',\n\t"borders":['
          for k = 1, #spc[i].borders do
            s = s .. string.format('%s\n\t\t{ "name":"%s", "x": %f, "y": %f, "z": %f, "radius":%d }', k == 1 and "" or ",", spc[i].borders[k].name, spc[i].borders[k].x, spc[i].borders[k].y, spc[i].borders[k].z, spc[i].borders[k].radius)
          end
          s = s .. '\n\t],'
        end
        if (spc[i].planets and #spc[i].planets > 0) then
          s = s .. '\n\t"planets":['
          for k = 1, #spc[i].planets do
              s = s .. string.format('%s\n\t\t{ "name":"%s", "x": %f, "y": %f, "z": %f, "cochranes":%d, "market":%d }', k == 1 and "" or ",", spc[i].planets[k].name, spc[i].planets[k].x, spc[i].planets[k].y, spc[i].planets[k].z, spc[i].planets[k].cochranes or 0, spc[i].planets[k].market or -1)
          end
          s = s .. '\n\t]'
        end
        if (spc[i].stations and #spc[i].stations > 0) then
          s = s .. ',\n\t"stations":['
          for k = 1, #spc[i].stations do
              s = s .. string.format('%s\n\t\t{ "name":"%s", "x": %f, "y": %f, "z": %f, "cochranes":%d, "market":%d }', k == 1 and "" or ",", spc[i].stations[k].name, spc[i].stations[k].x, spc[i].stations[k].y, spc[i].stations[k].z, spc[i].stations[k].cochranes or 0, spc[i].stations[k].market or -1)
          end
          s = s .. '\n\t]'
          end
      s = s .. '}'
    end
    s = s .. ']'
    
    local finfo = utils.info()
    local plugin_folder = finfo["plugins_directory"]
    local f = io.open(plugin_folder .. "test.json", "w+")
    f:write(s)
    f:close()
    
   end
   
   -- Shows info about an empire, planet, etc.
   -- Who we want to see (object name)
   -- What kind of info (empire, planet)
   function fun_empire_info(_,_, wildcards)
     local who = string.upper(wildcards[1]) .. "*"
     local planets = ""
     local stations = ""
     local borders = ""
     local market_type = { }
     market_type[1] = ANSI(1,31) .. "(R)" .. ANSI(0,22)
     market_type[2] = ANSI(1,33) .. "(P)" .. ANSI(0,22)
     market_type[3] = ANSI(1,32) .. "(O)" .. ANSI(0,22)
     empData = nil
     
     if (string.match(who, "GFA")) then
       who = "FERENGI"
     elseif (string.match(who, "KE")) then
       who = "KLINGON"
     elseif (string.match(who, "UFP")) then
       who = "FEDERATION"
     elseif (string.match(who, "CU")) then
       who = "CARDASSIAN"
     end
     
     for i = 1, #json_data["ATS_Navcomp_DB"]["empires"] do
       
      if(string.match(string.upper(json_data["ATS_Navcomp_DB"]["empires"][i].name), who)) then
        empData = json_data["ATS_Navcomp_DB"]["empires"][i]
        break
      end
    end
      if (not empData) then
        ColourNote("red", "", "Empire not found")
        return
      end
      
      
    if (empData.planets) then
      for n = 1, #empData.planets do
        if ( n == #empData.planets) then
          planets = planets .. string.format("%s %s", empData.planets[n].name, market_type[empData.planets[n].market+1] or "")
        else
          planets = planets .. string.format("%s %s, ", empData.planets[n].name, market_type[empData.planets[n].market+1] or "")
        end
      end
    end
    
    
    if (empData.stations) then
        for n = 1, #empData.stations do
          if ( n == #empData.stations) then
            if (empData.stations[n].market and empData.stations[n].market > -1) then -- Special case for space colony
              stations = stations .. string.format("%s %s", empData.stations[n].name, market_type[empData.stations[n].market+1] or "")
            else
              stations = stations .. empData.stations[n].name
            end
            
        else
          if (empData.stations[n].market and  empData.stations[n].market> -1) then -- Special case for space colony
              stations = stations .. string.format("%s %s, ", empData.stations[n].name, market_type[empData.stations[n].market+1] or "")
            else
              stations = stations .. string.format("%s, ", empData.stations[n].name)
            end

        end
      end
    end
    
      if (empData.borders) then
        for n = 1, #empData.borders do
          local s = string.format("%.3f %.3f %.3f", empData.borders[n].x, empData.borders[n].y,empData.borders[n].z)
          if (n == #empData.borders) then
            borders = borders .. string.format("\n%s: %-20s [%.3f]", empData.borders[n].name, s, empData.borders[n].radius)
          else
            borders = borders .. string.format("\n%s: %-20s [%.3f]", empData.borders[n].name, s, empData.borders[n].radius)
          end
        end
      end
      
    local s = string.format("%s--[%sEmpire Information System 1.0]%s--------------------------------------------%s\n", ANSI(1,34), ANSI(1,33), ANSI(1,34), ANSI(0,22) )
    s = s .. string.format("%sName: %s%-20s%sGovernment: %s%s", ANSI(36), ANSI(0), empData.name, ANSI(36), ANSI(0), empData.government or "Unknown")
    s = s .. string.format("\n%sHomeworld: %s%s (%.3f %.3f %.3f)\n%sLeader: %s%s\n%s------------------------------------------------------------------------------\n%s", ANSI(36), ANSI(0), empData.homeworld or "Unknown", empData.hwx or 0, empData.hwy or 0,empData.hwz or 0, ANSI(36), ANSI(0),
            empData.leader or "Unknown", ANSI(34), ANSI(0,22))
    
    if (empData.desc) then
      s = s .. ANSI(1) .. empData.desc .. ANSI(22) .. "\n"
      s = s .. string.format("%s------------------------------------------------------------------------------%s\n", ANSI(34), ANSI(0))
    else
      s = s .. "\n"
    end
    
    if (borders and #borders > 1) then
      s = s .. string.format("\n%sBorder(s): %s%s\n", ANSI(36), ANSI(0), borders)
    end
    if (planets and #planets > 1) then
      s = s .. string.format("\n%sPlanet(s): %s%s\n", ANSI(36), ANSI(0), planets)
    end
    if (stations and #stations > 1) then
      s = s .. string.format("\n%sStations(s): %s%s\n", ANSI(36), ANSI(0), stations)
    end
    s = s .. string.format("%s------------------------------------------------------------------------------%s", ANSI(1,34), ANSI(0,22))
    AnsiNote(s)
  end
  
  function fun_set_wisdom(_, _, wildcards)
    if (wildcards.wisbonus and tonumber(wildcards.wisbonus)) then
        skill_info.wisdom = tonumber(wildcards.wisbonus)
        Debug("Wisdom Set to %d", tonumber(wildcards.wisbonus))
      end
    end
    
    
function fun_set_skills(_,_, wildcards)
    local sqrt = math.sqrt
    
      skill_info.eng = tonumber(wildcards.eng) or 0
      skill_info.sci = tonumber(wildcards.sci) or 0
      skill_info.helm = tonumber(wildcards.helm) or 0
      skill_info.tact = tonumber(wildcards.tact) or 0
      skill_info.oper = tonumber(wildcards.oper) or 0
      skill_info.damcon = tonumber(wildcards.damcon) or 0
      
      -- Calculate percentages
      skill_info.ecalc = (sqrt((50+skill_info.eng+skill_info.wisdom)/50)-1)+1
      skill_info.hcalc = (sqrt((50+skill_info.helm+skill_info.wisdom)/50)-1)+1
      skill_info.tcalc = (sqrt((50+skill_info.tact+skill_info.wisdom)/50)-1)+1
      skill_info.scalc = (sqrt((50+skill_info.sci+skill_info.wisdom)/50)-1)+1
      skill_info.ocalc = (sqrt((50+skill_info.oper+skill_info.wisdom)/50)-1)+1
      skill_info.dcalc = (sqrt((50+skill_info.damcon+skill_info.wisdom)/50)-1)+1
      SetVariable("CHAR_SKILLS", serialize.save("skill_info"))
      Debug("Setting skills.")
      
    end
    
 function reset_spec_info()
  spec_info = { mainmax = 0, auxmax = 0, maingw = 0, auxgw = 0, structure = 0, repair = 0, mr = 0, wc = 0, we = 0, wm = 0, wcc = 0, wec = 0, wmc = 0, ic = 0, ie = 0, im = 0, icc = 0, iec = 0, imc = 0, sm = 0, sc1 = 0, sc2 = 0, sc3 = 0, sc4 = 0, beams = {}, torps = {}, battgw = 0, firing = 0, fueleff = 0, stealth = 0, cloak = 0, sensors = 0, armor = 0, fuelmax = 0, twc = 0, twe = 0, twm = 0, wmr, beamqty = 0, beamdps = 0, beamstdps = 0, beamscounted = 0, missilestdps = 0, missilescounted = 0 }
end

--[[
  Structure: 1077              Repair: 1077                Mass: 10000000    
     Firing: 100              FuelEff: 100              Stealth: 100         
      Cloak: 100              Sensors: 100               AuxMax: 100         
    MainMax: 100                Armor: 100              FuelMax: 1000          
       Main: 564                  Aux: 51                  Batt: 51          
  MoveRatio: 14.1        
 WarpCruise: 14.0            WarpEmer: 15.0             WarpMax: 16.0        
       Cost: 276.36              Cost: 317.25              Cost: 360.96      
  ImpCruise: 0.25             ImpEmer: 0.50              ImpMax: 0.75        
       Cost: 16.92               Cost: 25.38               Cost: 50.76       
  ShieldMax: 20           ShieldRatio: 4           
 1x Cost: 5          2x Cost: 10         3x Cost: 15         4x Cost: 20       
 Defense: 95         Defense: 96.6667    Defense: 97.1429    Defense: 97.3333  
  ShieldMax: 22           ShieldRatio: 4.000000    
 1x Cost: 5.5        2x Cost: 11         3x Cost: 16.5       4x Cost: 22       
 Defense: 95.4545    Defense: 96.9697    Defense: 97.4026    Defense: 97.5758  
       
--]]
function fun_grab_specsheet(name, _, wildcards, styles)
    if (name == "SpecClassTrigger" ) then -- New spec, clear old one, prepare for incoming spec
      if (not skill_info.ecalc) then
        ColourNote("white", "", "SpecCalculator cannot work until you load your skills into the system using 'sheet'")
        return
      end
      
    reset_spec_info()
    printstyle(styles)
    EnableTrigger("SpecStructTrigger", true)
    EnableTrigger("SpecClassTrigger", false)
  elseif (name == "SpecStructTrigger") then
    spec_info.structure = tonumber(wildcards.structure)
    spec_info.repair = tonumber(wildcards.repair)
    spec_info.mass = tonumber(wildcards.mass)
    local s = string.format("%d (%d)", spec_info.structure, spec_info.structure * skill_info.dcalc)
    local d = spec_info.repair * skill_info.dcalc
    local p = string.format("%d (%d)", spec_info.repair, spec_info.repair + (d - spec_info.repair) *3)
    AnsiNote(string.format("%s%12s%s %-17s %sRepair:%s %-20s %sMass:%s %d", ANSI(36), "Structure:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.mass))
    EnableTrigger("SpecFiringTrigger", true)
    EnableTrigger("SpecStructTrigger", false)
  elseif (name == "SpecFiringTrigger") then
    spec_info.firing = tonumber(wildcards.firing)
    spec_info.fueleff = tonumber(wildcards.fueleff)
    spec_info.stealth = tonumber(wildcards.stealth)
    local s = string.format("%d (%.3f)", spec_info.firing, spec_info.firing + (spec_info.firing * skill_info.tcalc))
    local p = string.format("%d (%.3f)", spec_info.fueleff, spec_info.fueleff + (spec_info.fueleff * skill_info.ecalc))
    AnsiNote(string.format("%s%12s%s %-16s %sFuelEff:%s %-16s %sStealth:%s %d (%.3f)", ANSI(36), "Firing:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.stealth, spec_info.stealth + (spec_info.stealth * skill_info.hcalc)))
    EnableTrigger("SpecFiringTrigger", false)
    EnableTrigger("SpecCloakTrigger", true)
  elseif (name == "SpecCloakTrigger") then
    spec_info.cloak = tonumber(wildcards.cloak)
    spec_info.sensors = tonumber(wildcards.sensors)
    spec_info.auxmax = tonumber(wildcards.auxmax)
    local s = string.format("%d (%.3f)", spec_info.cloak, spec_info.cloak + (spec_info.cloak * skill_info.scalc))
    local p = string.format("%d (%.3f)", spec_info.sensors, spec_info.sensors + (spec_info.sensors * skill_info.scalc))
    AnsiNote(string.format("%s%12s%s %-16s %sSensors:%s %-17s %sAuxMax:%s %d (%.3f)", ANSI(36), "Cloak:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.auxmax, spec_info.auxmax + (spec_info.auxmax/100 * skill_info.ecalc)))
    EnableTrigger("SpecCloakTrigger", false)
    EnableTrigger("SpecMainmaxTrigger", true)
  elseif (name == "SpecMainmaxTrigger") then
    spec_info.mainmax = tonumber(wildcards.mainmax)
    spec_info.armor = tonumber(wildcards.armor)
    spec_info.fuelmax = tonumber(wildcards.fuelmax)
    local s = string.format("%d (%.3f)", spec_info.mainmax, spec_info.mainmax + (spec_info.mainmax/100 * skill_info.ecalc))
    local p = string.format("%d (%.3f)", spec_info.armor, spec_info.armor + (spec_info.armor * skill_info.ocalc))
    AnsiNote(string.format("%s%12s%s %-18s %sArmor:%s %-16s %sFuelMax:%s %d (%d)", ANSI(36), "MainMax:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.auxmax, spec_info.auxmax + (spec_info.auxmax/100 * skill_info.ecalc)))
    EnableTrigger("SpecMainmaxTrigger", false)
    EnableTrigger("SpecMainTrigger", true)
  elseif (name == "SpecMainTrigger") then
    spec_info.maingw = tonumber(wildcards.maingw)
    spec_info.auxgw = tonumber(wildcards.auxgw)
    spec_info.battgw = tonumber(wildcards.battgw)
    
    local mm = (spec_info.mainmax + (spec_info.mainmax/100 * skill_info.ecalc)) / 100
    local am = (spec_info.auxmax + (spec_info.auxmax/100 * skill_info.ecalc)) / 100
    local s = string.format("%d (%.3f)", spec_info.maingw, spec_info.maingw * mm)
    local p = string.format("%d (%.3f)", spec_info.auxgw, spec_info.auxgw * am)
    AnsiNote(string.format("%s%12s%s %-20s %sAux:%s %-19s %sBatt:%s %d", ANSI(36), "Main:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.battgw))
    EnableTrigger("SpecMainTrigger", false)
    EnableTrigger("SpecMRTrigger", true)
  elseif (name == "SpecMRTrigger") then
    spec_info.mr = tonumber(wildcards.mr)
    spec_info.tmr = spec_info.mr * (1 / (skill_info.hcalc))
    AnsiNote(string.format("%s%12s%s %.1f (%.3f)", ANSI(36), "MoveRatio:", ANSI(0), spec_info.mr, spec_info.tmr))
    EnableTrigger("SpecMRTrigger", false)
    EnableTrigger("SpecWarpCruTrigger", true)
  elseif (name == "SpecWarpCruTrigger") then
    spec_info.wc = tonumber(wildcards.wc)
    spec_info.we = tonumber(wildcards.we)
    spec_info.wm = tonumber(wildcards.wm)
    spec_info.twc = spec_info.wc + (( skill_info.ecalc-1) * 4)
    spec_info.twe = spec_info.we + (( skill_info.ecalc-1) * 3)
    spec_info.twm = spec_info.wm + ((skill_info.ecalc-1) * 2)
    local s = string.format("%.2f (%.3f)", spec_info.wc, spec_info.twc)
    local p = string.format("%.2f (%.3f)", spec_info.we, spec_info.twe)
    AnsiNote(string.format("%s%12s%s %-18s %sEmer:%s %-18s %sMax:%s %.2f (%.3f)", ANSI(36), "WarpCruise:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.wm, spec_info.twm))
    EnableTrigger("SpecWarpCruTrigger", false)
    EnableTrigger("SpecWarpCostTrigger", true)
  elseif (name == "SpecWarpCostTrigger") then
    spec_info.wcc = tonumber(wildcards.wcc)
    spec_info.wec = tonumber(wildcards.wec)
    spec_info.wmc = tonumber(wildcards.wmc)
    local pow = math.pow
    local s = string.format("%.3f (%.3f)", spec_info.wcc, ((0.1 * spec_info.tmr) * pow(spec_info.twc,2)))
    local p = string.format("%.3f (%.3f)", spec_info.wec, ((0.1 * spec_info.tmr) * pow(spec_info.twe,2)))
    local n = string.format("%.3f (%.3f)", spec_info.wmc, ((0.1 * spec_info.tmr) * pow(spec_info.twm,2)))
    AnsiNote(string.format("%s%12s%s %-18s %sCost:%s %-16s %sCost:%s %s", ANSI(36), "Cost:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), n))
    EnableTrigger("SpecWarpCostTrigger", false)
    EnableTrigger("SpecImpCruTrigger", true)
  elseif (name == "SpecImpCruTrigger") then
    spec_info.ic = tonumber(wildcards.ic)
    spec_info.ie = tonumber(wildcards.ie)
    spec_info.im = tonumber(wildcards.im)
    spec_info.tic = (100 - (75/(1+(skill_info.ecalc/100))))
    spec_info.tie = (100 - (50/(1+(skill_info.ecalc/100))))
    spec_info.tim = (100 - (25/(1+(skill_info.ecalc/100))))
    
    local s = string.format("%d%% (%.2f%%)", spec_info.ic*100, spec_info.tic)
    local p = string.format("%d%% (%.2f%%)", spec_info.ie*100, spec_info.tie)
    AnsiNote(string.format("%s%11s%s %-17s %sImpEmer:%s %-17s %sImpMax:%s %d%% (%.2f%%)", ANSI(36), "ImpCruise:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), spec_info.im*100, spec_info.tim))
    EnableTrigger("SpecImpCruTrigger", false)
    EnableTrigger("SpecImpCostTrigger", true)
  elseif (name == "SpecImpCostTrigger") then
    spec_info.icc = tonumber(wildcards.icc)
    spec_info.iec = tonumber(wildcards.iec)
    spec_info.imc = tonumber(wildcards.imc)
    -- impcost is 0.9*MR/ (1-impPercent)
    
    local s = string.format("%.2f (%.2f)", spec_info.icc, (0.9*spec_info.tmr)/(1-(spec_info.tic/100)))
    local p = string.format("%.2f (%.2f)", spec_info.iec, (0.9*spec_info.tmr)/(1-(spec_info.tie/100)))
    local n = string.format("%.2f (%.2f)", spec_info.imc, (0.9*spec_info.tmr)/(1-(spec_info.tim/100)))
    AnsiNote(string.format("%s%11s%s %-20s %sCost:%s %-19s %sCost:%s %s", ANSI(36), "Cost:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), n))
    EnableTrigger("SpecImpCostTrigger", false)
    EnableTrigger("SpecShieldMaxTrigger", true)
  elseif (name == "SpecShieldMaxTrigger") then
    spec_info.sm = tonumber(wildcards.sm)
    spec_info.sr = tonumber(wildcards.sr)
    local s = string.format("%d (%d)", spec_info.sm, math.ceil(spec_info.sm * skill_info.ocalc))
    AnsiNote(string.format("%s%12s%s %-18s %sShieldRatio:%s %d", ANSI(36), "ShieldMax:", ANSI(0), s, ANSI(36), ANSI(0), spec_info.sr))
    EnableTrigger("SpecShieldMaxTrigger", false)
    EnableTrigger("SpecShieldCostTrigger", true)
    EnableTrigger("SpecDefenseTrigger", true)
    EnableTrigger("SpecBeamTrigger", true)
  elseif (name == "SpecShieldCostTrigger") then
    spec_info.sc1 = tonumber(wildcards.sc1)
    spec_info.sc2 = tonumber(wildcards.sc2)
    spec_info.sc3 = tonumber(wildcards.sc3)
    spec_info.sc4 = tonumber(wildcards.sc4)
    local d = math.ceil((spec_info.sm + spec_info.sm * skill_info.ocalc)) / spec_info.sr
    local s = string.format("%.1f", spec_info.sc1)
    local p = string.format("%.1f", spec_info.sc2)
    local n = string.format("%.1f ", spec_info.sc3)
    -- 1x Cost: 5.5        2x Cost: 11         3x Cost: 16.5       4x Cost: 22       
    AnsiNote(string.format("%s%9s%s %-10s %s2x Cost:%s %-10s %s3x Cost:%s %-10s %s4x Cost:%s %.1f", ANSI(36), "1x Cost:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), n, ANSI(36), ANSI(0), spec_info.sc4))
    
    EnableTrigger("SpecShieldCostTrigger", false)
    EnableTrigger("SpecDefenseTrigger", true)
  elseif (name == "SpecDefenseTrigger") then
    spec_info.d1 = tonumber(wildcards.d1)
    spec_info.d2 = tonumber(wildcards.d2)
    spec_info.d3 = tonumber(wildcards.d3)
    spec_info.d4 = tonumber(wildcards.d4)
    local s = string.format("%.2f", spec_info.d1 )
    local p = string.format("%.2f", spec_info.d2 )
    local n = string.format("%.2f", spec_info.d3 )
    AnsiNote(string.format("%s%9s%s %-10s %sDefense:%s %-10s %sDefense:%s %-10s %sDefense:%s %.1f",ANSI(36), "Defense:", ANSI(0), s, ANSI(36), ANSI(0), p, ANSI(36), ANSI(0), n, ANSI(36), ANSI(0), spec_info.d4))
    EnableTrigger("SpecDefenseTrigger", false)
    EnableTrigger("SpecBeamTrigger", true)
  end
end

function fun_grab_beams(name,_,wildcards, styles)
    if (skill_info.tact < 1) then
      Debug("No skills set")
      return
    end
    --require("tprint")
    --Debug("BeamTriggered: %s / #beams: %d", name, #spec_info.beams)
    if (name == "SpecBeamTrigger") then
      spec_info.beamqty = tonumber(wildcards.beams) -- How many do we have
      spec_info.beamdps = tonumber(wildcards.beamdps)
      spec_info.beamscounted = 0
      spec_info.beams = nil
      spec_info.beams = { }
      EnableTrigger("SpecBeamTrigger", false)
      EnableTrigger("SpecBeamCostTrigger", true)
    elseif (name == "SpecBeamCostTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.beams[i] = { cost = tonumber(t[i]), range = 0, arcs = nil, damage = 0, time = 0, dps = 0 }
      end
      --Debug("Counted %d beams.", #t)
      printstyle(styles)
      spec_info.beamscounted = spec_info.beamscounted + #t
      EnableTrigger("SpecBeamCostTrigger", false)
      EnableTrigger("SpecBeamRangeTrigger", true)
    elseif (name == "SpecBeamRangeTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.beams[i].range = tonumber(t[i])
      end
      printstyle(styles)
      EnableTrigger("SpecBeamRangeTrigger", false)
      EnableTrigger("SpecBeamArcsTrigger", true)
    elseif (name == "SpecBeamArcsTrigger") then
      printstyle(styles)
      EnableTrigger("SpecBeamArcsTrigger", false)
      EnableTrigger("SpecBeamDamageTrigger", true)
    elseif (name == "SpecBeamDamageTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.beams[i].damage = tonumber(t[i])
      end
      printstyle(styles)
      EnableTrigger("SpecBeamDamageTrigger", false)
      EnableTrigger("SpecBeamTimeTrigger", true)
    elseif (name == "SpecBeamTimeTrigger") then
      local t = wildcards[1]:split()
      local s = string.format("%s%13s%s ", ANSI(1,36), "TunedTime:", ANSI(0,22))
      for i = 1, #t do
        spec_info.beams[i].time = tonumber(t[i])
        spec_info.beams[i].ttime = math.floor(spec_info.beams[i].time / (skill_info.tcalc))
        s = s .. string.format("%-5s ", tostring(spec_info.beams[i].ttime))
        
      end
      printstyle(styles)
      AnsiNote(s)
      EnableTrigger("SpecBeamTimeTrigger", false)
      EnableTrigger("SpecBeamDPSTrigger", true)
    elseif (name == "SpecBeamDPSTrigger") then
      -- Check qty here, fire again from the top if needed
      local t = wildcards[1]:split()
      printstyle(styles)
      local s = string.format("%s%13s%s ", ANSI(1,36), "TunedDPS:", ANSI(0,22))
      for i = 1, #t do
        spec_info.beams[i].dps = tonumber(t[i])
        spec_info.beamstdps = spec_info.beamstdps + (spec_info.beams[i].damage / spec_info.beams[i].ttime)
        local d = string.format("%.1f", spec_info.beams[i].damage / spec_info.beams[i].ttime)
        s = s .. string.format("%-5s ", d)
      end
      AnsiNote(s)
      if (spec_info.beamscounted == spec_info.beamqty) then --We have enough beams, total it out and look for missiles
        AnsiNote(string.format("%s%13s%s %-34s %sDPS:%s %.1f (%.1f)", ANSI(36), "Beams", ANSI(0), spec_info.beamqty, ANSI(36), ANSI(0), spec_info.beamdps, spec_info.beamstdps))
        EnableTrigger("SpecBeamDPSTrigger", false)
        EnableTrigger("SpecMissileTrigger", true)
        DoAfterSpecial (5, 'EnableTrigger("SpecMissileTrigger", false)', sendto.script)
        DoAfterSpecial (5, 'EnableTrigger("SpecClassTrigger", true)', sendto.script)
      else -- Otherwise, fire up the triggers again
        EnableTrigger("SpecBeamDPSTrigger", false)
        EnableTrigger("SpecBeamCostTrigger", true)
    end
    
    end
end
function fun_grab_missiles(name,_,wildcards, styles)
    if (skill_info.tact < 1) then
      Debug("No skills set")
      return
    end
    --require("tprint")
    --Debug("MissileTriggered: %s / #missiles: %d", name, #spec_info.missiles)
    if (name == "SpecMissileTrigger") then
      spec_info.missileqty = tonumber(wildcards.missiles) -- How many do we have
      spec_info.missiledps = tonumber(wildcards.missiledps)
      spec_info.missilescounted = 0
      spec_info.missiles = nil
      spec_info.missiles = { }
      EnableTrigger("SpecMissileTrigger", false)
      EnableTrigger("SpecMissileCostTrigger", true)
    elseif (name == "SpecMissileCostTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.missiles[i] = { cost = tonumber(t[i]), range = 0, arcs = nil, damage = 0, time = 0, dps = 0 }
      end
      --Debug("Counted %d missiles.", #t)
      printstyle(styles)
      spec_info.missilescounted = spec_info.missilescounted + #t
      EnableTrigger("SpecMissileCostTrigger", false)
      EnableTrigger("SpecMissileRangeTrigger", true)
    elseif (name == "SpecMissileRangeTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.missiles[i].range = tonumber(t[i])
      end
      printstyle(styles)
      EnableTrigger("SpecMissileRangeTrigger", false)
      EnableTrigger("SpecMissileArcsTrigger", true)
    elseif (name == "SpecMissileArcsTrigger") then
      printstyle(styles)
      EnableTrigger("SpecMissileArcsTrigger", false)
      EnableTrigger("SpecMissileDamageTrigger", true)
    elseif (name == "SpecMissileDamageTrigger") then
      local t = wildcards.str:split()
      for i = 1, #t do
        spec_info.missiles[i].damage = tonumber(t[i])
      end
      printstyle(styles)
      EnableTrigger("SpecMissileDamageTrigger", false)
      EnableTrigger("SpecMissileTimeTrigger", true)
    elseif (name == "SpecMissileTimeTrigger") then
      local t = wildcards[1]:split()
      local s = string.format("%s%13s%s ", ANSI(1,36), "TunedTime:", ANSI(0,22))
      for i = 1, #t do
        spec_info.missiles[i].time = tonumber(t[i])
        spec_info.missiles[i].ttime = math.floor(spec_info.missiles[i].time / (skill_info.tcalc))
        s = s .. string.format("%-5s ", tostring(spec_info.missiles[i].ttime))
        
      end
      printstyle(styles)
      AnsiNote(s)
      EnableTrigger("SpecMissileTimeTrigger", false)
      EnableTrigger("SpecMissileDPSTrigger", true)
    elseif (name == "SpecMissileDPSTrigger") then
      -- Check qty here, fire again from the top if needed
      local t = wildcards[1]:split()
      printstyle(styles)
      local s = string.format("%s%13s%s ", ANSI(1,36), "TunedDPS:", ANSI(0,22))
      for i = 1, #t do
        spec_info.missiles[i].dps = tonumber(t[i])
        spec_info.missilestdps = spec_info.missilestdps + (spec_info.missiles[i].damage / spec_info.missiles[i].ttime)
        local d = string.format("%.1f", spec_info.missiles[i].damage / spec_info.missiles[i].ttime)
        s = s .. string.format("%-5s ", d)
      end
      AnsiNote(s)
      if (spec_info.missilescounted == spec_info.missileqty) then --We have enough missiles, total it out and look for missiles
        AnsiNote(string.format("%s%13s%s %-34s %sDPS:%s %.1f (%.1f)", ANSI(36), "Missiles", ANSI(0), spec_info.missileqty, ANSI(36), ANSI(0), spec_info.missiledps, spec_info.missilestdps))
        EnableTrigger("SpecMissileDPSTrigger", false)
        EnableTrigger("SpecClassTrigger", true)
      else -- Otherwise, fire up the triggers again
        EnableTrigger("SpecMissileDPSTrigger", false)
        EnableTrigger("SpecMissileCostTrigger", true)
    end
    
    end
end
function traceheading_from_coords(yaw, pitch, sx, sy, sz, speed)
  local RANGE = 1
  local px, py, pz = 0, 0, 0
  local results = { }
  local i = 1
  
  if (not yaw or not pitch or not sx or not sy or not sz) then
    Debug("THFC: Invalid arguments: %d %d / %d %d %d", yaw or -1, pitch or -1, sx or -1, sy or -1, sz or -1)
    return -1 
  end
  if (not speed) then
    speed = 14.0
  end
  
  if (GetVariable("FRAMENAME")) then
    sx, sy, sz  = frame_to_grc(sx, sy, sz, GetVariable("FRAMENAME"))
    end
    
   px, py, pz = projectheading(yaw, pitch, 1200)
   px = px + sx
   py = py + sy
   pz = pz + sz
  
  while ( space_objs[i] ) do 
  if (space_objs[i].type == 1 or space_objs[i].type == 2) then
    local dx, dy, dz = space_objs[i].x, space_objs[i].y, space_objs[i].z
    local rng = xyz2range(sx,sy,sz,dx,dy,dz)
    if (rng > 1) then  -- This is so we don't hit nearby space objs..e.g a moon or spacestation
      local p = {}
      p = intersection(sx, sy, sz, px, py, pz, dx, dy, dz, RANGE)
      if (p.intersections > 0) then -- Possible match.. save it.
        Debug("NTHFC() Possible match: %s (%fd) ",space_objs[i].name, p.id1 / p.r1 )
        p.name = space_objs[i].name
        p.type = space_objs[i].type
        p.eta = get_eta(sx, sy, sz, p.x1, p.y1, p.z1, speed, C(i), COCHRANE)
        p.time = xyz2range(sx,sy,sz,p.x1,p.y1,p.z1) / Velocity(speed, C(i), COCHRANE) 
        p.deviation = p.id1 or 1 / p.r1 or 1
        results[#results+1] = p
      end
    end
  end
  i = i+1
  if (i > #space_objs and #results < 1 and RANGE < 12) then
      i = 1
      Debug("NTHFC() Not found with range %d, increasing to %d", RANGE, (RANGE+2))
      RANGE = RANGE + 2
    end
  end
  
  if (#results > 0) then
    Debug("NTH: %d results found", #results)
    local closestmatch = { }
    
    table.sort(results, function(a,b) return ((a.id1 / a.r1) < (b.id1 / b.r1)) end) -- Sort closest to furthest 
    
    if (#results > 1 and (math.abs(results[1].deviation - results[2].deviation)) < 0.001 and results[1]["type"] ~= 2) then
      closestmatch = results[2]
    else
      closestmatch = results[1]
    end
    
    if (closestmatch) then
      local arrival = closestmatch.time and os.date("%I:%M%p", os.time() + closestmatch.time) or ""
      local deviation = nil
      if (closestmatch.id1 / closestmatch.r1 < 0.027) then
        deviation = string.format(" %s(%.3fd)%s ", ANSI(1,32), (closestmatch.id1 / closestmatch.r1), ANSI(1,37))
      else
        deviation = string.format(" %s(%.3fd)%s ", ANSI(31,1), (closestmatch.id1 / closestmatch.r1) , ANSI(1,37))
      end
      return string.format("%s%s [%.3f]%s%s%s %s%s", ANSI(1,32), closestmatch.name, closestmatch.r1, ANSI(1,37), deviation, closestmatch.eta or "ETA N/A", arrival or "",
        (closestmatch.id1 / closestmatch.r1) > 0.07 and "\r\nNote: Deviation indicates this may be inaccurate." or "")
    else
      return -1
    end
    else -- if (#results >0)
      return -1 -- No results
    end
end
]]>
</script>

</muclient>
